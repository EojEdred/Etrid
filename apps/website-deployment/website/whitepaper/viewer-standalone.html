<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√ãTRID Ivory Papers - Standalone Viewer</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #00d4ff;
            --secondary-color: #0077ff;
            --dark-bg: #0a0e1a;
            --card-bg: #151b2e;
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --accent: #00ff88;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--dark-bg) 0%, #0f1729 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            padding: 4rem 2rem 2rem;
            background: linear-gradient(180deg, rgba(0,212,255,0.05) 0%, transparent 100%);
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .doc-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 3rem 0;
            padding: 0 1rem;
        }

        .doc-btn {
            padding: 1rem 2rem;
            background: var(--card-bg);
            border: 2px solid transparent;
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .doc-btn:hover {
            border-color: var(--primary-color);
            background: rgba(0,212,255,0.1);
            transform: translateY(-2px);
        }

        .doc-btn.active {
            border-color: var(--accent);
            background: rgba(0,255,136,0.1);
        }

        .download-btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin: 1rem 0.5rem;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,212,255,0.3);
        }

        .content-wrapper {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 3rem;
            margin: 2rem 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .markdown-content {
            color: var(--text-primary);
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3 {
            color: var(--primary-color);
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .markdown-content h1 {
            font-size: 2.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        .markdown-content h2 {
            font-size: 2rem;
        }

        .markdown-content h3 {
            font-size: 1.5rem;
        }

        .markdown-content p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 1rem 0 1rem 2rem;
            color: var(--text-secondary);
        }

        .markdown-content li {
            margin: 0.5rem 0;
        }

        .markdown-content code {
            background: rgba(0,212,255,0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: var(--accent);
        }

        .markdown-content pre {
            background: var(--dark-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
            color: var(--text-primary);
        }

        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
        }

        .markdown-content table th,
        .markdown-content table td {
            padding: 1rem;
            border: 1px solid rgba(0,212,255,0.2);
            text-align: left;
        }

        .markdown-content table th {
            background: rgba(0,212,255,0.1);
            color: var(--primary-color);
            font-weight: 600;
        }

        .markdown-content blockquote {
            border-left: 4px solid var(--accent);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .markdown-content a {
            color: var(--primary-color);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s ease;
        }

        .markdown-content a:hover {
            border-bottom-color: var(--primary-color);
        }

        .markdown-content hr {
            border: none;
            border-top: 2px solid rgba(0,212,255,0.2);
            margin: 3rem 0;
        }

        footer {
            text-align: center;
            padding: 3rem 2rem;
            color: var(--text-secondary);
            border-top: 1px solid rgba(0,212,255,0.1);
            margin-top: 4rem;
        }

        .loading {
            text-align: center;
            padding: 4rem;
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .doc-selector {
                flex-direction: column;
            }

            .doc-btn {
                width: 100%;
            }

            .content-wrapper {
                padding: 1.5rem;
            }

            .markdown-content h1 {
                font-size: 1.8rem;
            }
        }

        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s ease;
            font-size: 1.5rem;
            z-index: 1000;
        }

        .back-to-top.visible {
            opacity: 1;
        }

        .back-to-top:hover {
            background: var(--accent);
            transform: translateY(-5px);
        }

        .text-center {
            text-align: center;
        }
    </style>
</head>
<body>
    <header>
        <h1 >√ãTRID IVORY PAPERS</h1>
        <p class="subtitle"  >
            Complete Protocol Specification & Governance Framework
        </p>
    </header>

    <div class="container">
        <div class="doc-selector"  >
            <a href="?doc=ivory-paper" class="doc-btn" id="btn-ivory-paper">
                Complete Edition (v2.0)
            </a>
            <a href="?doc=vol1" class="doc-btn" id="btn-vol1">
                Volume I: Conceptual
            </a>
            <a href="?doc=vol2" class="doc-btn" id="btn-vol2">
                Volume II: Technical
            </a>
            <a href="?doc=vol3" class="doc-btn" id="btn-vol3">
                Volume III: Governance
            </a>
            <a href="?doc=charter" class="doc-btn" id="btn-charter">
                Protocol Charter
            </a>
        </div>

        <div class="text-center"  >
            <button class="download-btn" id="download-current">
                ‚¨áÔ∏è Download Current Paper
            </button>
            <button class="download-btn" id="download-all">
                üì¶ Download All Papers
            </button>
        </div>

        <div class="content-wrapper"  >
            <div id="content" class="markdown-content">
                <div class="loading">Loading content...</div>
            </div>
        </div>
    </div>

    <footer>
        <p>√ãTRID Protocol ¬© 2025 | Licensed under GPLv3</p>
        <p>Founder: Eoj Edred | Status: ACTIVE PROTOCOL SPECIFICATION</p>
    </footer>

    <div class="back-to-top" id="back-to-top">‚Üë</div>

    <script>
        // Marked.js v4.3.0 - Markdown Parser (embedded)
        /**
 * marked v4.3.0 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).marked={})}(this,function(r){"use strict";function i(e,t){for(var u=0;u<t.length;u++){var n=t[u];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,function(e){e=function(e,t){if("object"!=typeof e||null===e)return e;var u=e[Symbol.toPrimitive];if(void 0===u)return("string"===t?String:Number)(e);u=u.call(e,t||"default");if("object"!=typeof u)return u;throw new TypeError("@@toPrimitive must return a primitive value.")}(e,"string");return"symbol"==typeof e?e:String(e)}(n.key),n)}}function F(){return(F=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var u,n=arguments[t];for(u in n)Object.prototype.hasOwnProperty.call(n,u)&&(e[u]=n[u])}return e}).apply(this,arguments)}function s(e,t){(null==t||t>e.length)&&(t=e.length);for(var u=0,n=new Array(t);u<t;u++)n[u]=e[u];return n}function D(e,t){var u,n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){var u;if(e)return"string"==typeof e?s(e,t):"Map"===(u="Object"===(u=Object.prototype.toString.call(e).slice(8,-1))&&e.constructor?e.constructor.name:u)||"Set"===u?Array.from(e):"Arguments"===u||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u)?s(e,t):void 0}(e))||t&&e&&"number"==typeof e.length)return n&&(e=n),u=0,function(){return u>=e.length?{done:!0}:{done:!1,value:e[u++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function e(){return{async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}r.defaults=e();function u(e){return t[e]}var n=/[&<>"']/,l=new RegExp(n.source,"g"),o=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,a=new RegExp(o.source,"g"),t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};function A(e,t){if(t){if(n.test(e))return e.replace(l,u)}else if(o.test(e))return e.replace(a,u);return e}var c=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;function x(e){return e.replace(c,function(e,t){return"colon"===(t=t.toLowerCase())?":":"#"===t.charAt(0)?"x"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):""})}var h=/(^|[^\[])\^/g;function p(u,e){u="string"==typeof u?u:u.source,e=e||"";var n={replace:function(e,t){return t=(t=t.source||t).replace(h,"$1"),u=u.replace(e,t),n},getRegex:function(){return new RegExp(u,e)}};return n}var Z=/[^\w:]/g,O=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function f(e,t,u){if(e){try{n=decodeURIComponent(x(u)).replace(Z,"").toLowerCase()}catch(e){return null}if(0===n.indexOf("javascript:")||0===n.indexOf("vbscript:")||0===n.indexOf("data:"))return null}var n;t&&!O.test(u)&&(e=u,g[" "+(n=t)]||(q.test(n)?g[" "+n]=n+"/":g[" "+n]=C(n,"/",!0)),t=-1===(n=g[" "+n]).indexOf(":"),u="//"===e.substring(0,2)?t?e:n.replace(j,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(P,"$1")+e:n+e);try{u=encodeURI(u).replace(/%25/g,"%")}catch(e){return null}return u}var g={},q=/^[^:]+:\/*[^/]*$/,j=/^([^:]+:)[\s\S]*$/,P=/^([^:]+:\/*[^/]*)[\s\S]*$/;var k={exec:function(){}};function d(e,t){var u=e.replace(/\|/g,function(e,t,u){for(var n=!1,r=t;0<=--r&&"\\"===u[r];)n=!n;return n?"|":" |"}).split(/ \|/),n=0;if(u[0].trim()||u.shift(),0<u.length&&!u[u.length-1].trim()&&u.pop(),u.length>t)u.splice(t);else for(;u.length<t;)u.push("");for(;n<u.length;n++)u[n]=u[n].trim().replace(/\\\|/g,"|");return u}function C(e,t,u){var n=e.length;if(0===n)return"";for(var r=0;r<n;){var i=e.charAt(n-r-1);if((i!==t||u)&&(i===t||!u))break;r++}return e.slice(0,n-r)}function E(e,t){if(t<1)return"";for(var u="";1<t;)1&t&&(u+=e),t>>=1,e+=e;return u+e}function m(e,t,u,n){var r=t.href,t=t.title?A(t.title):null,i=e[1].replace(/\\([\[\]])/g,"$1");return"!"!==e[0].charAt(0)?(n.state.inLink=!0,e={type:"link",raw:u,href:r,title:t,text:i,tokens:n.inlineTokens(i)},n.state.inLink=!1,e):{type:"image",raw:u,href:r,title:t,text:A(i)}}var b=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.space=function(e){e=this.rules.block.newline.exec(e);if(e&&0<e[0].length)return{type:"space",raw:e[0]}},t.code=function(e){var t,e=this.rules.block.code.exec(e);if(e)return t=e[0].replace(/^ {1,4}/gm,""),{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:C(t,"\n")}},t.fences=function(e){var t,u,n,r,e=this.rules.block.fences.exec(e);if(e)return t=e[0],u=t,n=e[3]||"",u=null===(u=t.match(/^(\s+)(?:```)/))?n:(r=u[1],n.split("\n").map(function(e){var t=e.match(/^\s+/);return null!==t&&t[0].length>=r.length?e.slice(r.length):e}).join("\n")),{type:"code",raw:t,lang:e[2]&&e[2].trim().replace(this.rules.inline._escapes,"$1"),text:u}},t.heading=function(e){var t,u,e=this.rules.block.heading.exec(e);if(e)return t=e[2].trim(),/#$/.test(t)&&(u=C(t,"#"),!this.options.pedantic&&u&&!/ $/.test(u)||(t=u.trim())),{type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:this.lexer.inline(t)}},t.hr=function(e){e=this.rules.block.hr.exec(e);if(e)return{type:"hr",raw:e[0]}},t.blockquote=function(e){var t,u,n,e=this.rules.block.blockquote.exec(e);if(e)return t=e[0].replace(/^ *>[ \t]?/gm,""),u=this.lexer.state.top,this.lexer.state.top=!0,n=this.lexer.blockTokens(t),this.lexer.state.top=u,{type:"blockquote",raw:e[0],tokens:n,text:t}},t.list=function(e){var t=this.rules.block.list.exec(e);if(t){var u,n,r,i,s,l,o,a,D,c,h,p=1<(g=t[1].trim()).length,f={type:"list",raw:"",ordered:p,start:p?+g.slice(0,-1):"",loose:!1,items:[]},g=p?"\\d{1,9}\\"+g.slice(-1):"\\"+g;this.options.pedantic&&(g=p?g:"[*+-]");for(var F=new RegExp("^( {0,3}"+g+")((?:[\t ][^\\n]*)?(?:\\n|$))");e&&(h=!1,t=F.exec(e))&&!this.rules.block.hr.test(e);){if(u=t[0],e=e.substring(u.length),o=t[2].split("\n",1)[0].replace(/^\t+/,function(e){return" ".repeat(3*e.length)}),a=e.split("\n",1)[0],this.options.pedantic?(i=2,c=o.trimLeft()):(i=t[2].search(/[^ ]/),c=o.slice(i=4<i?1:i),i+=t[1].length),s=!1,!o&&/^ *$/.test(a)&&(u+=a+"\n",e=e.substring(a.length+1),h=!0),!h)for(var A=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"),k=new RegExp("^ {0,"+Math.min(3,i-1)+"}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"),d=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:```|~~~)"),C=new RegExp("^ {0,"+Math.min(3,i-1)+"}#");e&&(a=D=e.split("\n",1)[0],this.options.pedantic&&(a=a.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!d.test(a))&&!C.test(a)&&!A.test(a)&&!k.test(e);){if(a.search(/[^ ]/)>=i||!a.trim())c+="\n"+a.slice(i);else{if(s)break;if(4<=o.search(/[^ ]/))break;if(d.test(o))break;if(C.test(o))break;if(k.test(o))break;c+="\n"+a}s||a.trim()||(s=!0),u+=D+"\n",e=e.substring(D.length+1),o=a.slice(i)}f.loose||(l?f.loose=!0:/\n *\n *$/.test(u)&&(l=!0)),this.options.gfm&&(n=/^\[[ xX]\] /.exec(c))&&(r="[ ] "!==n[0],c=c.replace(/^\[[ xX]\] +/,"")),f.items.push({type:"list_item",raw:u,task:!!n,checked:r,loose:!1,text:c}),f.raw+=u}f.items[f.items.length-1].raw=u.trimRight(),f.items[f.items.length-1].text=c.trimRight(),f.raw=f.raw.trimRight();for(var E,x=f.items.length,m=0;m<x;m++)this.lexer.state.top=!1,f.items[m].tokens=this.lexer.blockTokens(f.items[m].text,[]),f.loose||(E=0<(E=f.items[m].tokens.filter(function(e){return"space"===e.type})).length&&E.some(function(e){return/\n.*\n/.test(e.raw)}),f.loose=E);if(f.loose)for(m=0;m<x;m++)f.items[m].loose=!0;return f}},t.html=function(e){var t,e=this.rules.block.html.exec(e);if(e)return t={type:"html",raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]},this.options.sanitize&&(e=this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]),t.type="paragraph",t.text=e,t.tokens=this.lexer.inline(e)),t},t.def=function(e){var t,u,n,e=this.rules.block.def.exec(e);if(e)return t=e[1].toLowerCase().replace(/\s+/g," "),u=e[2]?e[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",n=e[3]&&e[3].substring(1,e[3].length-1).replace(this.rules.inline._escapes,"$1"),{type:"def",tag:t,raw:e[0],href:u,title:n}},t.table=function(e){e=this.rules.block.table.exec(e);if(e){var t={type:"table",header:d(e[1]).map(function(e){return{text:e}}),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];for(var u,n,r,i=t.align.length,s=0;s<i;s++)/^ *-+: *$/.test(t.align[s])?t.align[s]="right":/^ *:-+: *$/.test(t.align[s])?t.align[s]="center":/^ *:-+ *$/.test(t.align[s])?t.align[s]="left":t.align[s]=null;for(i=t.rows.length,s=0;s<i;s++)t.rows[s]=d(t.rows[s],t.header.length).map(function(e){return{text:e}});for(i=t.header.length,u=0;u<i;u++)t.header[u].tokens=this.lexer.inline(t.header[u].text);for(i=t.rows.length,u=0;u<i;u++)for(r=t.rows[u],n=0;n<r.length;n++)r[n].tokens=this.lexer.inline(r[n].text);return t}}},t.lheading=function(e){e=this.rules.block.lheading.exec(e);if(e)return{type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:this.lexer.inline(e[1])}},t.paragraph=function(e){var t,e=this.rules.block.paragraph.exec(e);if(e)return t="\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1],{type:"paragraph",raw:e[0],text:t,tokens:this.lexer.inline(t)}},t.text=function(e){e=this.rules.block.text.exec(e);if(e)return{type:"text",raw:e[0],text:e[0],tokens:this.lexer.inline(e[0])}},t.escape=function(e){e=this.rules.inline.escape.exec(e);if(e)return{type:"escape",raw:e[0],text:A(e[1])}},t.tag=function(e){e=this.rules.inline.tag.exec(e);if(e)return!this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]):e[0]}},t.link=function(e){e=this.rules.inline.link.exec(e);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var u=C(t.slice(0,-1),"\\");if((t.length-u.length)%2==0)return}else{u=function(e,t){if(-1!==e.indexOf(t[1]))for(var u=e.length,n=0,r=0;r<u;r++)if("\\"===e[r])r++;else if(e[r]===t[0])n++;else if(e[r]===t[1]&&--n<0)return r;return-1}(e[2],"()");-1<u&&(r=(0===e[0].indexOf("!")?5:4)+e[1].length+u,e[2]=e[2].substring(0,u),e[0]=e[0].substring(0,r).trim(),e[3]="")}var n,u=e[2],r="";return this.options.pedantic?(n=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(u))&&(u=n[1],r=n[3]):r=e[3]?e[3].slice(1,-1):"",u=u.trim(),m(e,{href:(u=/^</.test(u)?this.options.pedantic&&!/>$/.test(t)?u.slice(1):u.slice(1,-1):u)&&u.replace(this.rules.inline._escapes,"$1"),title:r&&r.replace(this.rules.inline._escapes,"$1")},e[0],this.lexer)}},t.reflink=function(e,t){var u;if(u=(u=this.rules.inline.reflink.exec(e))||this.rules.inline.nolink.exec(e))return(e=t[(e=(u[2]||u[1]).replace(/\s+/g," ")).toLowerCase()])?m(u,e,u[0],this.lexer):{type:"text",raw:t=u[0].charAt(0),text:t}},t.emStrong=function(e,t,u){void 0===u&&(u="");var n=this.rules.inline.emStrong.lDelim.exec(e);if(n&&(!n[3]||!u.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var r=n[1]||n[2]||"";if(!r||""===u||this.rules.inline.punctuation.exec(u)){var i=n[0].length-1,s=i,l=0,o="*"===n[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(o.lastIndex=0,t=t.slice(-1*e.length+i);null!=(n=o.exec(t));){var a,D=n[1]||n[2]||n[3]||n[4]||n[5]||n[6];if(D)if(a=D.length,n[3]||n[4])s+=a;else if((n[5]||n[6])&&i%3&&!((i+a)%3))l+=a;else if(!(0<(s-=a)))return a=Math.min(a,a+s+l),D=e.slice(0,i+n.index+(n[0].length-D.length)+a),Math.min(i,a)%2?(a=D.slice(1,-1),{type:"em",raw:D,text:a,tokens:this.lexer.inlineTokens(a)}):(a=D.slice(2,-2),{type:"strong",raw:D,text:a,tokens:this.lexer.inlineTokens(a)})}}}},t.codespan=function(e){var t,u,n,e=this.rules.inline.code.exec(e);if(e)return n=e[2].replace(/\n/g," "),t=/[^ ]/.test(n),u=/^ /.test(n)&&/ $/.test(n),n=A(n=t&&u?n.substring(1,n.length-1):n,!0),{type:"codespan",raw:e[0],text:n}},t.br=function(e){e=this.rules.inline.br.exec(e);if(e)return{type:"br",raw:e[0]}},t.del=function(e){e=this.rules.inline.del.exec(e);if(e)return{type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2])}},t.autolink=function(e,t){var u,e=this.rules.inline.autolink.exec(e);if(e)return t="@"===e[2]?"mailto:"+(u=A(this.options.mangle?t(e[1]):e[1])):u=A(e[1]),{type:"link",raw:e[0],text:u,href:t,tokens:[{type:"text",raw:u,text:u}]}},t.url=function(e,t){var u,n,r,i;if(u=this.rules.inline.url.exec(e)){if("@"===u[2])r="mailto:"+(n=A(this.options.mangle?t(u[0]):u[0]));else{for(;i=u[0],u[0]=this.rules.inline._backpedal.exec(u[0])[0],i!==u[0];);n=A(u[0]),r="www."===u[1]?"http://"+u[0]:u[0]}return{type:"link",raw:u[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}},t.inlineText=function(e,t){e=this.rules.inline.text.exec(e);if(e)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]):e[0]:A(this.options.smartypants?t(e[0]):e[0]),{type:"text",raw:e[0],text:t}},e}(),B={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:k,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/},w=(B.def=p(B.def).replace("label",B._label).replace("title",B._title).getRegex(),B.bullet=/(?:[*+-]|\d{1,9}[.)])/,B.listItemStart=p(/^( *)(bull) */).replace("bull",B.bullet).getRegex(),B.list=p(B.list).replace(/bull/g,B.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+B.def.source+")").getRegex(),B._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",B._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,B.html=p(B.html,"i").replace("comment",B._comment).replace("tag",B._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),B.paragraph=p(B._paragraph).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.blockquote=p(B.blockquote).replace("paragraph",B.paragraph).getRegex(),B.normal=F({},B),B.gfm=F({},B.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),B.gfm.table=p(B.gfm.table).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.gfm.paragraph=p(B._paragraph).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",B.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.pedantic=F({},B.normal,{html:p("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",B._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:k,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:p(B.normal._paragraph).replace("hr",B.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",B.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()}),{escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:k,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:k,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/});function L(e){return e.replace(/---/g,"‚Äî").replace(/--/g,"‚Äì").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‚Äò").replace(/'/g,"‚Äô").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1‚Äú").replace(/"/g,"‚Äù").replace(/\.{3}/g,"‚Ä¶")}function y(e){for(var t,u="",n=e.length,r=0;r<n;r++)t=e.charCodeAt(r),u+="&#"+(t=.5<Math.random()?"x"+t.toString(16):t)+";";return u}w._punctuation="!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~",w.punctuation=p(w.punctuation).replace(/punctuation/g,w._punctuation).getRegex(),w.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,w.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g,w._comment=p(B._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),w.emStrong.lDelim=p(w.emStrong.lDelim).replace(/punct/g,w._punctuation).getRegex(),w.emStrong.rDelimAst=p(w.emStrong.rDelimAst,"g").replace(/punct/g,w._punctuation).getRegex(),w.emStrong.rDelimUnd=p(w.emStrong.rDelimUnd,"g").replace(/punct/g,w._punctuation).getRegex(),w._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,w._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,w._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,w.autolink=p(w.autolink).replace("scheme",w._scheme).replace("email",w._email).getRegex(),w._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,w.tag=p(w.tag).replace("comment",w._comment).replace("attribute",w._attribute).getRegex(),w._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,w._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,w._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,w.link=p(w.link).replace("label",w._label).replace("href",w._href).replace("title",w._title).getRegex(),w.reflink=p(w.reflink).replace("label",w._label).replace("ref",B._label).getRegex(),w.nolink=p(w.nolink).replace("ref",B._label).getRegex(),w.reflinkSearch=p(w.reflinkSearch,"g").replace("reflink",w.reflink).replace("nolink",w.nolink).getRegex(),w.normal=F({},w),w.pedantic=F({},w.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:p(/^!?\[(label)\]\((.*?)\)/).replace("label",w._label).getRegex(),reflink:p(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",w._label).getRegex()}),w.gfm=F({},w.normal,{escape:p(w.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),w.gfm.url=p(w.gfm.url,"i").replace("email",w.gfm._extended_email).getRegex(),w.breaks=F({},w.gfm,{br:p(w.br).replace("{2,}","*").getRegex(),text:p(w.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var v=function(){function u(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||r.defaults,this.options.tokenizer=this.options.tokenizer||new b,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,(this.tokenizer.lexer=this).inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};e={block:B.normal,inline:w.normal};this.options.pedantic?(e.block=B.pedantic,e.inline=w.pedantic):this.options.gfm&&(e.block=B.gfm,this.options.breaks?e.inline=w.breaks:e.inline=w.gfm),this.tokenizer.rules=e}u.lex=function(e,t){return new u(t).lex(e)},u.lexInline=function(e,t){return new u(t).inlineTokens(e)};var e,t,n=u.prototype;return n.lex=function(e){var t;for(e=e.replace(/\r\n|\r/g,"\n"),this.blockTokens(e,this.tokens);t=this.inlineQueue.shift();)this.inlineTokens(t.src,t.tokens);return this.tokens},n.blockTokens=function(r,t){var u,e,i,n,s=this;for(void 0===t&&(t=[]),r=this.options.pedantic?r.replace(/\t/g,"    ").replace(/^ +$/gm,""):r.replace(/^( *)(\t+)/gm,function(e,t,u){return t+"    ".repeat(u.length)});r;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(function(e){return!!(u=e.call({lexer:s},r,t))&&(r=r.substring(u.raw.length),t.push(u),!0)})))if(u=this.tokenizer.space(r))r=r.substring(u.raw.length),1===u.raw.length&&0<t.length?t[t.length-1].raw+="\n":t.push(u);else if(u=this.tokenizer.code(r))r=r.substring(u.raw.length),!(e=t[t.length-1])||"paragraph"!==e.type&&"text"!==e.type?t.push(u):(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(u=this.tokenizer.fences(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.heading(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.hr(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.blockquote(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.list(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.html(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.def(r))r=r.substring(u.raw.length),!(e=t[t.length-1])||"paragraph"!==e.type&&"text"!==e.type?this.tokens.links[u.tag]||(this.tokens.links[u.tag]={href:u.href,title:u.title}):(e.raw+="\n"+u.raw,e.text+="\n"+u.raw,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(u=this.tokenizer.table(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.lheading(r))r=r.substring(u.raw.length),t.push(u);else if(i=r,this.options.extensions&&this.options.extensions.startBlock&&!function(){var t=1/0,u=r.slice(1),n=void 0;s.options.extensions.startBlock.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n))}),t<1/0&&0<=t&&(i=r.substring(0,t+1))}(),this.state.top&&(u=this.tokenizer.paragraph(i)))e=t[t.length-1],n&&"paragraph"===e.type?(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(u),n=i.length!==r.length,r=r.substring(u.raw.length);else if(u=this.tokenizer.text(r))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===e.type?(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(u);else if(r){var l="Infinite loop on byte: "+r.charCodeAt(0);if(this.options.silent){console.error(l);break}throw new Error(l)}return this.state.top=!0,t},n.inline=function(e,t){return this.inlineQueue.push({src:e,tokens:t=void 0===t?[]:t}),t},n.inlineTokens=function(r,t){var u,e,i,n,s,l,o=this,a=(void 0===t&&(t=[]),r);if(this.tokens.links){var D=Object.keys(this.tokens.links);if(0<D.length)for(;null!=(n=this.tokenizer.rules.inline.reflinkSearch.exec(a));)D.includes(n[0].slice(n[0].lastIndexOf("[")+1,-1))&&(a=a.slice(0,n.index)+"["+E("a",n[0].length-2)+"]"+a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(n=this.tokenizer.rules.inline.blockSkip.exec(a));)a=a.slice(0,n.index)+"["+E("a",n[0].length-2)+"]"+a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(n=this.tokenizer.rules.inline.escapedEmSt.exec(a));)a=a.slice(0,n.index+n[0].length-2)+"++"+a.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;r;)if(s||(l=""),s=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(function(e){return!!(u=e.call({lexer:o},r,t))&&(r=r.substring(u.raw.length),t.push(u),!0)})))if(u=this.tokenizer.escape(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.tag(r))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===u.type&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(u=this.tokenizer.link(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.reflink(r,this.tokens.links))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===u.type&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(u=this.tokenizer.emStrong(r,a,l))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.codespan(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.br(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.del(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.autolink(r,y))r=r.substring(u.raw.length),t.push(u);else if(!this.state.inLink&&(u=this.tokenizer.url(r,y)))r=r.substring(u.raw.length),t.push(u);else if(i=r,this.options.extensions&&this.options.extensions.startInline&&!function(){var t=1/0,u=r.slice(1),n=void 0;o.options.extensions.startInline.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n))}),t<1/0&&0<=t&&(i=r.substring(0,t+1))}(),u=this.tokenizer.inlineText(i,L))r=r.substring(u.raw.length),"_"!==u.raw.slice(-1)&&(l=u.raw.slice(-1)),s=!0,(e=t[t.length-1])&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(r){var c="Infinite loop on byte: "+r.charCodeAt(0);if(this.options.silent){console.error(c);break}throw new Error(c)}return t},n=u,t=[{key:"rules",get:function(){return{block:B,inline:w}}}],(e=null)&&i(n.prototype,e),t&&i(n,t),Object.defineProperty(n,"prototype",{writable:!1}),u}(),_=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.code=function(e,t,u){var n,t=(t||"").match(/\S*/)[0];return this.options.highlight&&null!=(n=this.options.highlight(e,t))&&n!==e&&(u=!0,e=n),e=e.replace(/\n$/,"")+"\n",t?'<pre><code class="'+this.options.langPrefix+A(t)+'">'+(u?e:A(e,!0))+"</code></pre>\n":"<pre><code>"+(u?e:A(e,!0))+"</code></pre>\n"},t.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},t.html=function(e){return e},t.heading=function(e,t,u,n){return this.options.headerIds?"<h"+t+' id="'+(this.options.headerPrefix+n.slug(u))+'">'+e+"</h"+t+">\n":"<h"+t+">"+e+"</h"+t+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(e,t,u){var n=t?"ol":"ul";return"<"+n+(t&&1!==u?' start="'+u+'"':"")+">\n"+e+"</"+n+">\n"},t.listitem=function(e){return"<li>"+e+"</li>\n"},t.checkbox=function(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(e){return"<p>"+e+"</p>\n"},t.table=function(e,t){return"<table>\n<thead>\n"+e+"</thead>\n"+(t=t&&"<tbody>"+t+"</tbody>")+"</table>\n"},t.tablerow=function(e){return"<tr>\n"+e+"</tr>\n"},t.tablecell=function(e,t){var u=t.header?"th":"td";return(t.align?"<"+u+' align="'+t.align+'">':"<"+u+">")+e+"</"+u+">\n"},t.strong=function(e){return"<strong>"+e+"</strong>"},t.em=function(e){return"<em>"+e+"</em>"},t.codespan=function(e){return"<code>"+e+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(e){return"<del>"+e+"</del>"},t.link=function(e,t,u){return null===(e=f(this.options.sanitize,this.options.baseUrl,e))?u:(e='<a href="'+e+'"',t&&(e+=' title="'+t+'"'),e+">"+u+"</a>")},t.image=function(e,t,u){return null===(e=f(this.options.sanitize,this.options.baseUrl,e))?u:(e='<img src="'+e+'" alt="'+u+'"',t&&(e+=' title="'+t+'"'),e+(this.options.xhtml?"/>":">"))},t.text=function(e){return e},e}(),z=function(){function e(){}var t=e.prototype;return t.strong=function(e){return e},t.em=function(e){return e},t.codespan=function(e){return e},t.del=function(e){return e},t.html=function(e){return e},t.text=function(e){return e},t.link=function(e,t,u){return""+u},t.image=function(e,t,u){return""+u},t.br=function(){return""},e}(),$=function(){function e(){this.seen={}}var t=e.prototype;return t.serialize=function(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},t.getNextSafeSlug=function(e,t){var u=e,n=0;if(this.seen.hasOwnProperty(u))for(n=this.seen[e];u=e+"-"+ ++n,this.seen.hasOwnProperty(u););return t||(this.seen[e]=n,this.seen[u]=0),u},t.slug=function(e,t){void 0===t&&(t={});e=this.serialize(e);return this.getNextSafeSlug(e,t.dryrun)},e}(),S=function(){function u(e){this.options=e||r.defaults,this.options.renderer=this.options.renderer||new _,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new z,this.slugger=new $}u.parse=function(e,t){return new u(t).parse(e)},u.parseInline=function(e,t){return new u(t).parseInline(e)};var e=u.prototype;return e.parse=function(e,t){void 0===t&&(t=!0);for(var u,n,r,i,s,l,o,a,D,c,h,p,f,g,F,A,k="",d=e.length,C=0;C<d;C++)if(a=e[C],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[a.type]&&(!1!==(A=this.options.extensions.renderers[a.type].call({parser:this},a))||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(a.type)))k+=A||"";else switch(a.type){case"space":continue;case"hr":k+=this.renderer.hr();continue;case"heading":k+=this.renderer.heading(this.parseInline(a.tokens),a.depth,x(this.parseInline(a.tokens,this.textRenderer)),this.slugger);continue;case"code":k+=this.renderer.code(a.text,a.lang,a.escaped);continue;case"table":for(l=D="",r=a.header.length,u=0;u<r;u++)l+=this.renderer.tablecell(this.parseInline(a.header[u].tokens),{header:!0,align:a.align[u]});for(D+=this.renderer.tablerow(l),o="",r=a.rows.length,u=0;u<r;u++){for(l="",i=(s=a.rows[u]).length,n=0;n<i;n++)l+=this.renderer.tablecell(this.parseInline(s[n].tokens),{header:!1,align:a.align[n]});o+=this.renderer.tablerow(l)}k+=this.renderer.table(D,o);continue;case"blockquote":o=this.parse(a.tokens),k+=this.renderer.blockquote(o);continue;case"list":for(D=a.ordered,E=a.start,c=a.loose,r=a.items.length,o="",u=0;u<r;u++)f=(p=a.items[u]).checked,g=p.task,h="",p.task&&(F=this.renderer.checkbox(f),c?0<p.tokens.length&&"paragraph"===p.tokens[0].type?(p.tokens[0].text=F+" "+p.tokens[0].text,p.tokens[0].tokens&&0<p.tokens[0].tokens.length&&"text"===p.tokens[0].tokens[0].type&&(p.tokens[0].tokens[0].text=F+" "+p.tokens[0].tokens[0].text)):p.tokens.unshift({type:"text",text:F}):h+=F),h+=this.parse(p.tokens,c),o+=this.renderer.listitem(h,g,f);k+=this.renderer.list(o,D,E);continue;case"html":k+=this.renderer.html(a.text);continue;case"paragraph":k+=this.renderer.paragraph(this.parseInline(a.tokens));continue;case"text":for(o=a.tokens?this.parseInline(a.tokens):a.text;C+1<d&&"text"===e[C+1].type;)o+="\n"+((a=e[++C]).tokens?this.parseInline(a.tokens):a.text);k+=t?this.renderer.paragraph(o):o;continue;default:var E='Token with "'+a.type+'" type was not found.';if(this.options.silent)return void console.error(E);throw new Error(E)}return k},e.parseInline=function(e,t){t=t||this.renderer;for(var u,n,r="",i=e.length,s=0;s<i;s++)if(u=e[s],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[u.type]&&(!1!==(n=this.options.extensions.renderers[u.type].call({parser:this},u))||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(u.type)))r+=n||"";else switch(u.type){case"escape":r+=t.text(u.text);break;case"html":r+=t.html(u.text);break;case"link":r+=t.link(u.href,u.title,this.parseInline(u.tokens,t));break;case"image":r+=t.image(u.href,u.title,u.text);break;case"strong":r+=t.strong(this.parseInline(u.tokens,t));break;case"em":r+=t.em(this.parseInline(u.tokens,t));break;case"codespan":r+=t.codespan(u.text);break;case"br":r+=t.br();break;case"del":r+=t.del(this.parseInline(u.tokens,t));break;case"text":r+=t.text(u.text);break;default:var l='Token with "'+u.type+'" type was not found.';if(this.options.silent)return void console.error(l);throw new Error(l)}return r},u}(),T=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.preprocess=function(e){return e},t.postprocess=function(e){return e},e}();function R(f,g){return function(e,u,n){"function"==typeof u&&(n=u,u=null);var r,i,s,t=F({},u),l=(u=F({},I.defaults,t),r=u.silent,i=u.async,s=n,function(e){var t;if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r)return t="<p>An error occurred:</p><pre>"+A(e.message+"",!0)+"</pre>",i?Promise.resolve(t):s?void s(null,t):t;if(i)return Promise.reject(e);if(!s)throw e;s(e)});if(null==e)return l(new Error("marked(): input parameter is undefined or null"));if("string"!=typeof e)return l(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected"));if((t=u)&&t.sanitize&&!t.silent&&console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"),u.hooks&&(u.hooks.options=u),n){var o,a=u.highlight;try{u.hooks&&(e=u.hooks.preprocess(e)),o=f(e,u)}catch(e){return l(e)}var D,c=function(t){var e;if(!t)try{u.walkTokens&&I.walkTokens(o,u.walkTokens),e=g(o,u),u.hooks&&(e=u.hooks.postprocess(e))}catch(e){t=e}return u.highlight=a,t?l(t):n(null,e)};return!a||a.length<3?c():(delete u.highlight,o.length?(D=0,I.walkTokens(o,function(u){"code"===u.type&&(D++,setTimeout(function(){a(u.text,u.lang,function(e,t){if(e)return c(e);null!=t&&t!==u.text&&(u.text=t,u.escaped=!0),0===--D&&c()})},0))}),void(0===D&&c())):c())}if(u.async)return Promise.resolve(u.hooks?u.hooks.preprocess(e):e).then(function(e){return f(e,u)}).then(function(e){return u.walkTokens?Promise.all(I.walkTokens(e,u.walkTokens)).then(function(){return e}):e}).then(function(e){return g(e,u)}).then(function(e){return u.hooks?u.hooks.postprocess(e):e}).catch(l);try{u.hooks&&(e=u.hooks.preprocess(e));var h=f(e,u),p=(u.walkTokens&&I.walkTokens(h,u.walkTokens),g(h,u));return p=u.hooks?u.hooks.postprocess(p):p}catch(e){return l(e)}}}function I(e,t,u){return R(v.lex,S.parse)(e,t,u)}T.passThroughHooks=new Set(["preprocess","postprocess"]),I.options=I.setOptions=function(e){return I.defaults=F({},I.defaults,e),e=I.defaults,r.defaults=e,I},I.getDefaults=e,I.defaults=r.defaults,I.use=function(){for(var D=I.defaults.extensions||{renderers:{},childTokens:{}},e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];t.forEach(function(s){var u,e=F({},s);if(e.async=I.defaults.async||e.async||!1,s.extensions&&(s.extensions.forEach(function(r){if(!r.name)throw new Error("extension name required");var i;if(r.renderer&&(i=D.renderers[r.name],D.renderers[r.name]=i?function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=r.renderer.apply(this,t);return n=!1===n?i.apply(this,t):n}:r.renderer),r.tokenizer){if(!r.level||"block"!==r.level&&"inline"!==r.level)throw new Error("extension level must be 'block' or 'inline'");D[r.level]?D[r.level].unshift(r.tokenizer):D[r.level]=[r.tokenizer],r.start&&("block"===r.level?D.startBlock?D.startBlock.push(r.start):D.startBlock=[r.start]:"inline"===r.level&&(D.startInline?D.startInline.push(r.start):D.startInline=[r.start]))}r.childTokens&&(D.childTokens[r.name]=r.childTokens)}),e.extensions=D),s.renderer){var t,l=I.defaults.renderer||new _;for(t in s.renderer)!function(r){var i=l[r];l[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.renderer[r].apply(l,t);return n=!1===n?i.apply(l,t):n}}(t);e.renderer=l}if(s.tokenizer){var n,o=I.defaults.tokenizer||new b;for(n in s.tokenizer)!function(r){var i=o[r];o[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.tokenizer[r].apply(o,t);return n=!1===n?i.apply(o,t):n}}(n);e.tokenizer=o}if(s.hooks){var r,a=I.defaults.hooks||new T;for(r in s.hooks)!function(r){var i=a[r];T.passThroughHooks.has(r)?a[r]=function(e){return I.defaults.async?Promise.resolve(s.hooks[r].call(a,e)).then(function(e){return i.call(a,e)}):(e=s.hooks[r].call(a,e),i.call(a,e))}:a[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.hooks[r].apply(a,t);return n=!1===n?i.apply(a,t):n}}(r);e.hooks=a}s.walkTokens&&(u=I.defaults.walkTokens,e.walkTokens=function(e){var t=[];return t.push(s.walkTokens.call(this,e)),t=u?t.concat(u.call(this,e)):t}),I.setOptions(e)})},I.walkTokens=function(e,l){for(var o,a=[],t=D(e);!(o=t()).done;)!function(){var t=o.value;switch(a=a.concat(l.call(I,t)),t.type){case"table":for(var e=D(t.header);!(u=e()).done;){var u=u.value;a=a.concat(I.walkTokens(u.tokens,l))}for(var n,r=D(t.rows);!(n=r()).done;)for(var i=D(n.value);!(s=i()).done;){var s=s.value;a=a.concat(I.walkTokens(s.tokens,l))}break;case"list":a=a.concat(I.walkTokens(t.items,l));break;default:I.defaults.extensions&&I.defaults.extensions.childTokens&&I.defaults.extensions.childTokens[t.type]?I.defaults.extensions.childTokens[t.type].forEach(function(e){a=a.concat(I.walkTokens(t[e],l))}):t.tokens&&(a=a.concat(I.walkTokens(t.tokens,l)))}}();return a},I.parseInline=R(v.lexInline,S.parseInline),I.Parser=S,I.parser=S.parse,I.Renderer=_,I.TextRenderer=z,I.Lexer=v,I.lexer=v.lex,I.Tokenizer=b,I.Slugger=$,I.Hooks=T;var k=(I.parse=I).options,Q=I.setOptions,U=I.use,M=I.walkTokens,N=I.parseInline,H=I,X=S.parse,G=v.lex;r.Hooks=T,r.Lexer=v,r.Parser=S,r.Renderer=_,r.Slugger=$,r.TextRenderer=z,r.Tokenizer=b,r.getDefaults=e,r.lexer=G,r.marked=I,r.options=k,r.parse=H,r.parseInline=N,r.parser=X,r.setOptions=Q,r.use=U,r.walkTokens=M});
    </script>

    <script>        // Embedded paper content
        const embeddedPapers = {
    'ivory-paper': {
        title: '√ãTRID Ivory Paper v2.0 - Complete Edition',
        filename: 'ivory-paper.md',
        content: `# √ãTRID IVORY PAPER v2.0
## Complete Protocol Specification & Foundation Governance

**Document ID**: ETRID-WP-2025-V2.0
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Publication Date**: October 30, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Non-Commercial)

---

## TABLE OF CONTENTS

1. Executive Summary
2. Vision & Mission
3. The Problem: Blockchain Centralization
4. The Solution: √ãTRID FODDoS Protocol
5. Protocol Architecture (E¬≥20)
6. Governance & Consensus Day
7. Token Economics (√âTR, √ãDSC, VMw)
8. √ãTRID Dollar Stablecoin (√ãDSC) Specification
9. Peer Architecture & Node Types
10. Distribution Pay System
11. Foundation Charter & Legal Framework
12. Technical Specifications & Network Parameters
13. Security, Cryptography & Post-Quantum Readiness
14. Deployment Roadmap & Milestones
15. Frequently Asked Questions
16. Appendices

---

## 1. EXECUTIVE SUMMARY

**√ãTRID** is a **decentralized multichain blockchain platform** designed to achieve true democratic governance at scale. Unlike Bitcoin's immutability-first approach or Ethereum's developer-centric model, √ãTRID implements **Consensus Day**: an annual, stake-weighted voting event where the community directly controls:

- The annual token inflation rate
- Protocol amendments and upgrades
- Budget allocation for development
- Selection of 9 non-hierarchical board members (Decentralized Directors)

### Key Differentiators

| Feature | √ãTRID | Bitcoin | Ethereum | Others |
|---------|-------|---------|----------|--------|
| **Democratic Governance** | ‚úÖ Annual vote on all major decisions | ‚ùå Developer consensus | ‚ö†Ô∏è Off-chain voting | ‚ö†Ô∏è Varies |
| **Native Stablecoin** | ‚úÖ √ãDSC (110-130% collateralized) | ‚ùå None | ‚ö†Ô∏è Requires DeFi | ‚ö†Ô∏è Varies |
| **Post-Quantum Crypto** | ‚úÖ Ed25519 + SPHINCS+ hybrid | ‚ùå ECDSA only | ‚ùå ECDSA only | ‚ùå Most use ECDSA |
| **P2P Protocol** | ‚úÖ DETR p2p (S/Kademlia + ECIES) | ‚úÖ Custom P2P | ‚úÖ Custom P2P | ‚úÖ Varies |
| **Sidechain Architecture** | ‚úÖ Partition Burst Chains | ‚ùå None | ‚úÖ Rollups/Sidechains | ‚úÖ Varies |
| **Smart Contracts** | ‚úÖ WASM-based √ãtwasmVM | ‚ùå None | ‚úÖ Solidity/EVM | ‚úÖ Varies |

### Launch Timeline
- **Phase 1-2**: ‚úÖ Core infrastructure complete
- **Phase 3**: ‚úÖ √ãDSC stablecoin integration complete
- **Phase 4-5**: ‚úÖ Partition Burst Chains & DAO registration complete
- **Phase 6-7**: ‚úÖ Smart contracts & AI governance complete
- **Phase 8**: ‚úÖ Mainnet launched successfully (October 2025)

### Initial Token Distribution
- **Total Supply**: 1 Billion √âTR
- **Initial Circulation**: ~10% (100 Million √âTR)
- **Locked for Growth**: 900 Million √âTR (released via Consensus Day votes)
- **Annual Emission**: Voted by community on Dec 1st each year

---

## 2. VISION & MISSION

### √ãTRID Vision
**A free and open decentralized democracy of stakeholders where power is distributed among millions of participants, not concentrated in the hands of a few.**

### √ãTRID Mission
1. **Build** a truly decentralized blockchain with democratic governance
2. **Protect** digital rights, data sovereignty, and financial privacy
3. **Enable** self-sufficient stakeholders to reclaim power from centralized intermediaries
4. **Create** economic systems that reward participation, not just capital
5. **Maintain** technological excellence while resisting censorship and mutable forks

### Core Values
- **Decentralization First**: No entity controls >5% of voting power
- **Democratic**: All major decisions via Consensus Day supermajority
- **Open Source**: GPLv3 license ensures perpetual freedom
- **Transparent**: All transactions, governance, and code are auditable
- **Resilient**: Network continues operating even if any node is compromised

---

## 3. THE PROBLEM: BLOCKCHAIN CENTRALIZATION

### Historical Centralization Patterns

**Bitcoin** (2009):
- Originally: Truly decentralized P2P currency
- Today: Dominated by mining pools (3 pools control >50% of hash power)
- Problem: Network security depends on benevolence of pool operators

**Ethereum** (2015):
- Originally: Decentralized smart contract platform
- Today: Major client (Geth) has 80%+ market share, controlled by Ethereum Foundation
- Problem: Hard fork decisions made by core developers, not token holders

**Modern Alternatives** (2020+):
- Solana: Dominated by venture capital investors
- Polkadot: Governance but relay chain remains centralized
- Cosmos: Multiple chains but unclear governance
- Layer 2s: Often run by single company (Arbitrum = Offchain Labs, Optimism = OP Labs)

### Mutable Hardforks Under Political Pressure

Even projects with "immutable" designs have hard-forked due to political or financial pressure:
- Ethereum's DAO hard fork (2016): Reverting "immutable" transaction
- Bitcoin Classic vs Bitcoin Cash split (2017): Competing visions, no democratic process
- Staked ETH Shanghai upgrade (2023): Community concerns ignored in favor of Ethereum Foundation direction

**Root Cause**: Lack of **decentralized democratic decision-making processes**.

### The Data Wars & DCPI Threat

Centralized platforms are collecting:
- Personal location data (IoT devices)
- Biometric data (facial recognition, haptics)
- Neural/emotional data (spatial web, sentiment tracking)
- Medical & reproductive health data (wearables)

**Result**: Corporations and governments monetize intimacy while individuals lose control of their identity.

---

## 4. THE SOLUTION: √ãTRID FODDoS PROTOCOL

### What is FODDoS?

**FODDoS** = **Free and Open Decentralized Democracy of Stakeholders**

Unlike "Proof of Stake" or "Proof of Work," FODDoS is a **governance model**, not just a consensus algorithm.

**Core Components**:

1. **Consensus Day** (Annual Democratic Vote)
   - Every token holder votes on major decisions
   - Vote weight = Stake / Vote Dilution
   - Results are binding for 12 months

2. **Decentralized Directors** (Non-Hierarchical Board)
   - 9 directors elected annually by Consensus Day
   - No single president or CEO
   - Equal voting power
   - Can be recalled mid-term with 66% community supermajority

3. **Distribution Pay** (Reward Network Participation)
   - Validators, stakers, and voters earn √âTR daily
   - Earnings based on participation and stake
   - Penalty system for absenteeism

4. **Foundation Charter** (Immutable Rules)
   - Legal structure defines how DAO operates
   - GPLv3 open-source ensures code freedom
   - Bylaws cannot be broken without hard fork + community vote

---

## 5. PROTOCOL ARCHITECTURE (E¬≥20)

### Essential Elements to Operate Reference Implementation

√ãTRID consists of **13 core subsystems** (E¬≥20):

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     LAYER 1: CORE INFRASTRUCTURE                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. DETR p2p       ‚îÇ Multi-protocol P2P networking               ‚îÇ
‚îÇ 2. OpenDID        ‚îÇ Self-sovereign identity system              ‚îÇ
‚îÇ 3. Blockchain Sec ‚îÇ Post-quantum cryptography                   ‚îÇ
‚îÇ 4. Accounts       ‚îÇ EBCA, RCA, SCA, SSCA account types         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    LAYER 2: CHAIN ARCHITECTURE                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 5. Multichain     ‚îÇ FlareChain + PBCs + State channels          ‚îÇ
‚îÇ 6. Transactions   ‚îÇ Regular, smart contract, cross-chain        ‚îÇ
‚îÇ 7. Native Crypto  ‚îÇ √âTR, √ãDSC, VMw tokens                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    LAYER 3: COMPUTATION & CONSENSUS              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 8. √ãtwasmVM       ‚îÇ WebAssembly smart contract runtime          ‚îÇ
‚îÇ 9. Consensus      ‚îÇ ASF (Ascending Scale of Finality)           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    LAYER 4: GOVERNANCE & DISTRIBUTION            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 10. Foundation    ‚îÇ DAO charter, legal framework, bylaws        ‚îÇ
‚îÇ 11. Peer Roles    ‚îÇ Flare Nodes, Validity Nodes, DDs            ‚îÇ
‚îÇ 12. Governance    ‚îÇ Consensus Day voting, electoral process     ‚îÇ
‚îÇ 13. Distribution  ‚îÇ Daily reward pay for validators & stakers   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    LAYER 5: CLIENT IMPLEMENTATIONS               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Clients           ‚îÇ CLI, Web wallet, Mobile wallet              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### 5.1 DETR p2p: Multi-Protocol Network Layer

**DETR** = Decentralized, Encrypted, Trustless, Resilient Peer-to-Peer

**Components**:
- **DPeers**: Node discovery using S/Kademlia DHT routing
- **AEComms**: TCP-based secure communications with ECIES encryption
- **DETRP2P**: Peer tethering for application session negotiation
- **√ãtr**: Base layer protocol for block synchronization
- **Fluent**: Secure, private channels using Lingo protocol
- **Stor√©D**: Distributed storage using S/Kademlia DHTs and Merkle DAGs

**Security Features**:
- End-to-end encryption (ECIES) between peers
- No trust required between peers
- Sybil-resistant through reputation system
- Censorship-resistant message routing

### 5.2 OpenDID: Self-Sovereign Identity

**OpenDID** = √ãtrid Open Decentralized Identification System

**Features**:
- Users control their own identifiers
- No central issuing authority
- Credential issuance by trusted communities
- Privacy-preserving: Selective disclosure of attributes
- Interoperable with W3C DID standard

**Use Cases**:
- KYC/AML compliance without centralized database
- Sybil resistance: Verified unique humans
- Developer identity: Reputation for bug bounties
- Community credentials: Membership proof

### 5.3 Blockchain Security: Post-Quantum Cryptography

**Hash Functions**:
- SHA-3 (Keccak) for general hashing
- Blake2b for performance-critical operations

**Digital Signatures**:
- EdDSA (Ed25519) - primary signature scheme
- SPHINCS+ (lattice-based) - post-quantum backup
- Hybrid mode during quantum transition period

**Key Management**:
- HKDF-Blake2b for key derivation
- BIP39 for mnemonic seeds
- BIP44 for hierarchical deterministic wallets

**Post-Quantum Readiness**:
- Network designed for algorithm agility
- Can switch to quantum-resistant algorithms via soft fork
- Keys can be upgraded without breaking addresses

### 5.4 Account Types

**EBCA** (External Blockchain Accounts)
- Any keypair generated outside √ãTRID
- Cannot validate or propose blocks
- Can receive and send funds
- Example: MetaMask wallet connected to √ãTRID

**RCA** (Root Chain Accounts)
- Generated by √ãTRID Key Generation Protocol
- Valid on FlareChain (main chain) only
- Can vote, stake, validate
- SS58 address format with "1" prefix

**SCA** (Side Chain Accounts)
- Accounts on specific Partition Burst Chains
- Different keypair per chain allowed
- Faster local PBC transactions
- SS58 address format with chain-specific prefix

**SSCA** (Smart Side Chain Accounts)
- Controlled by √ãtwasmVM smart contracts
- No private key (code-governed)
- Can execute transactions on behalf of contract owner
- Used for autonomous systems and DAO treasuries

### 5.5 Multichain Architecture

**FlareChain** (Main Chain / Root)
- Stores world state
- Executes Consensus Day voting
- Manages Foundation operations
- Holds reserve collateral (for √ãDSC)
- Block time: 12 seconds
- Finality: ~5 minutes via ASF consensus

**Partition Burst Chains (PBCs)** (Sidechains)
- Dedicated chains for specific purposes or communities
- Example: PBC-EDSC for √ãDSC stablecoin operations
- State synchronized to FlareChain via checkpoints every N blocks
- Faster throughput than main chain
- Security guaranteed by FlareChain validator quorum

**Lightning Bloc Network** (State Channels)
- Off-chain micropayment channels
- Rapid settlement (instant)
- Batch settlement to FlareChain daily/weekly
- Reduces main chain load
- Enables microtransactions (<0.01 √âTR)

### 5.6 Native Cryptocurrency

**√âTR** (√ãtrid Coin) - Primary Token
- Total initial supply: 1 Billion
- Annual issuance: Voted by Consensus Day
- Uses: Payments, staking, voting, collateral
- Decimals: 18 (smallest unit: 1 Wei = 0.000000000000000001 √âTR)

**√ãDSC** (√ãtrid Dollar Stablecoin) - 1:1 USD Peg
- Total supply: 50 Billion √ãDSC
- Initial circulation: 5 Billion
- Locked reserve: 45 Billion (governance-controlled release)
- Collateralization: 110-130%
- Redemption paths: 3 (Treasury vault, custodian, DEX)

**VMw** (Virtual Machine Watts) - Computation Gas
- Smart contract execution cost
- 1 VMw ‚âà 0.001 √âTR (market-based)
- All VMw consumed is burned (deflationary)
- Pay-per-opcode model

### 5.7 Smart Contracts & √ãtwasmVM

**√ãtwasmVM** = √ãtrid WebAssembly Virtual Machine

**Features**:
- Turing-complete runtime
- Sandboxed execution environment
- Gas metering to prevent infinite loops
- State storage with rent model
- Cross-contract calls and composition

**Supported Languages**:
- Rust (primary via wasm-pack)
- C/C++ (via Emscripten)
- AssemblyScript (TypeScript to WASM)

**Economic Model**:
- Storage rent: 0.1 VMw per byte per day
- Execution: Variable based on opcodes
- State access: 64 VMw per 32-byte read/write
- Cross-contract calls: Additional gas overhead

### 5.8 Consensus Algorithm: ASF

**ASF** = Ascending Scale of Finality

**Mechanism**:
- Validators propose and vote on new blocks
- Block becomes finalized when 66% of validators attest
- Finality achieved in ~25 validator slots (~5 minutes)
- Penalties for double-signing or equivocation

**Validator Rotation**:
- Every epoch: Top 100 validators by stake become active
- Active validator set: Minimum 25, maximum 100
- New validators: Enter queue with 64 √âTR minimum stake
- Slashing: 1% of stake for security violations

---

## 6. GOVERNANCE & CONSENSUS DAY

### 6.1 Consensus Day: Annual Democratic Vote

**Schedule**:
- **Date**: December 1st at **12:00 AM PST** (hardcoded, changes require hard fork)
- **Pre-Consensus Period**: January 1 ‚Äì October 31 (proposal submission, campaigns, nominations)
- **Frequency**: Once per year
- **Participation Types**:
  - **VALIDITY Nodes** (64+ √âTR minimum stake): Block producers and consensus participants
  - **Common Stake Peers** (1+ √âTR minimum stake): Governance voters and proposal supporters
  - **Decentralized Directors** (128+ √âTR minimum stake): 9 elected board members

**Voting Power Calculation**:

\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where **Coinage** represents time-weighted stake (how long tokens have been staked).

**Example**:
- You stake: 1,000 √âTR for 180 days
- Coinage multiplier: ~1.5√ó (increases with time staked)
- Your voting power: 1,000 √ó 1.5 = 1,500 effective votes
- Longer stakes = higher voting power multiplier
- Incentivizes long-term stakeholder commitment

**Penalties**:
- Failure to vote = penalties and reward redistribution
- Rewards distributed to active participants

### 6.2 Consensus Day Ballot

**Three Categories**:

#### Category 1: Fiscal Mint & Supply
- **Question**: "How many √âTR should be minted in the next 12 months?"
- **Options**: Top 3 community proposals + 3 limit options (min/mid/max)
- **Binding Effect**: Winning proposal becomes the annual mint rate
- **Implementation**: Automatic release Jan 1st following vote

**Example Options**:
- Proposal A: 50 Million √âTR (5% annual emission)
- Proposal B: 75 Million √âTR (7.5% annual emission)
- Proposal C: 100 Million √âTR (10% annual emission)
- Limit 1: Min 25M (2.5%)
- Limit 2: Mid 62.5M (6.25%)
- Limit 3: Max 125M (12.5%)

#### Category 2: Decentralized Director Elections
- **Question**: "Who should serve as the 9 Decentralized Directors?"
- **Candidates**: All accounts with ‚â•128 √âTR stake
- **Criteria**: Must meet "Honest Image" standards (TBD by community)
- **Term**: 1 year (Dec 1 - Nov 30)
- **Limit**: Max 3 consecutive terms (then 1-year break required)

**DD Roles** (Non-Hierarchical):
- Oversee FlareChain security and operations
- Approve major protocol upgrades
- Manage Foundation budget
- Coordinate with custodians and validators
- Respond to security incidents

**DD Compensation**:
- Salary: X% of annual fiscal mint (TBD)
- FLARE node rewards: Y% of block production (TBD)
- Clawback for misconduct: Full stake forfeiture

#### Category 3: Protocol Amendments
- **Question**: "What protocol changes should be approved?"
- **Options**: Top 3 community proposals
- **Voting**: ‚â•66% supermajority required
- **Implementation**: Takes effect Jan 1st following vote
- **Audit**: Major changes require 90-day security review

**Example Amendments**:
- Proposal A: Increase validator count from 25 to 50
- Proposal B: Add new oracle source (Uniswap TWAP)
- Proposal C: Adjust penalty percentages for validators

### 6.3 Voting Mechanics

**Vote Submission**:
- On-chain voting via extrinsic
- Ballot opened: December 1, 12:00 AM PST
- **Pre-Consensus Period**: January 1 ‚Äì October 31 (proposal submission and campaigning)
- **Voting Power Formula**: Staked √âTR √ó Coinage (time-weighted stake)
- Failure to vote = penalties and reward redistribution

**Vote Types**:
- Single-choice: Pick 1 option
- Ranked-choice (future): Rank preferences
- Quadratic voting (future): Vote strength weighted by ‚àöstake

**Privacy** (Future Enhancement):
- Zero-knowledge proofs for voter privacy
- V otes recorded without linking to addresses
- Cryptographic verification of vote counts

### 6.4 Soft Forks vs Hard Forks

**Soft Forks** (Governance-only):
- Requires: 50% + 1 on Consensus Day
- Examples: Change oracle sources, adjust validator count
- Implementation: Network node updates, no chain split
- Time to activate: ~30 days after vote

**Hard Forks** (Code changes):
- Requires: 66% supermajority on Consensus Day
- Audit period: 90 days minimum
- Community notice: At least 30 days before activation
- Optional rollback: Within 1 hour of fork (66% validator consent)

**Emergency Hard Forks** (Security only):
- Authorized by: 5/9 Decentralized Director quorum
- Community confirmation: 24-hour flash vote
- Duration: Max 7 days
- Post-fork audit: Mandatory

---

## 7. TOKEN ECONOMICS (√âTR, √ãDSC, VMw)

### 7.1 √âTR Tokenomics

**Initial Distribution** (1 Billion √âTR):

| Category | Amount | % | Purpose |
|----------|--------|---|---------|
| Circulating | 100M | 10% | Launch liquidity, exchange listings |
| Founder Allocation | 50M | 5% | Eoj Edred (subject to clawback) |
| Foundation Treasury | 100M | 10% | Development, grants, bug bounties |
| Locked Growth | 750M | 75% | Governance-controlled release via Consensus Day |

**Annual Emission Schedule**:
- Year 1 (2025): Voted by Consensus Day 2024 (baseline ~50M = 5%)
- Year 2 (2026): Voted by Consensus Day 2025
- Perpetual: Voted annually (no max cap in code, only via governance)

**Emission Logic** (Pseudo-code):

\`\`\`
annual_mint = consensus_day_voted_amount
daily_distribution = annual_mint / 365

daily_distribution_breakdown:
  - Registered Voting Peers: P% (participation reward)
  - FLARE Nodes: Z% (validator rewards)
  - VALIDITY Nodes: W% (sidechain validator rewards)
  - Common Stake Peers: Q% (staking rewards)
  - Decentralized Directors: V% (compensation + rewards)
  - Foundation Treasury: (P + Z + W + Q + V) capped at 100%
\`\`\`

**Token Utility**:

| Use Case | Amount | Requirement |
|----------|--------|-------------|
| **Voting** | 1 √âTR | Minimum stake to participate in Consensus Day |
| **Staking (Flare Node)** | 1 √âTR | Optional, for validator rewards |
| **Staking (Validity Node)** | 64 √âTR | Required to operate sidechain validator |
| **DD Candidacy** | 128 √âTR | To run for Decentralized Director |
| **Transactions** | 0.1 √âTR | Average transfer fee |
| **Smart Contracts** | Variable | Gas fees paid in √âTR (converted to VMw) |
| **√ãDSC Collateral** | Variable | Backing for stablecoin system |

### 7.2 √ãDSC Stablecoin Economics

**Total Supply**:
- Cap: 50 Billion √ãDSC
- Initial: 5 Billion circulation
- Locked: 45 Billion (released via governance)

**Peg Maintenance**:
- Target: 1 √ãDSC = 1.00 USD
- Acceptable range: 0.98 - 1.02 USD
- Oracle sources: Binance, Coinbase, Kraken, Bitstamp, Gemini
- Rebalancing: Automated via redemption incentives

**Collateralization Requirements**:

\`\`\`
Collateral Ratio = Total Reserve Value / √ãDSC Outstanding
Required Ratio = 110% (minimum)
Optimal Ratio = 120-130%
Emergency Ratio = 90% (triggers circuit breaker)

If Ratio < 100%: Redemption fees increase to 10%
If Ratio < 90%: All redemptions paused
\`\`\`

**Reserve Composition**:
- On-chain collateral (FlareChain vault): 40-50%
- Custodian-held reserves (USD, bonds, T-bills): 50-60%
- Dynamically rebalanced monthly

### 7.3 VMw Gas Token

**Economics**:
- Base rate: 1 VMw ‚âà 0.001 √âTR (market-determined)
- Adjusted: Gas price can vary based on network load
- Burned: All VMw consumed is permanently destroyed
- Market price: Determined by Uniswap/DEX if listed

**Gas Costs**:

| Operation | Cost | Example |
|-----------|------|---------|
| Simple transfer | 0.01 VMw | ~0.00001 √âTR |
| Account creation | 1 VMw | ~0.001 √âTR |
| Smart contract call | 100-10,000 VMw | ~0.1-10 √âTR |
| State write (32 bytes) | 64 VMw | ~0.064 √âTR |
| Cross-chain message | 256 VMw base | ~0.256 √âTR + payload |

**Deflationary Mechanics**:
- Every transaction reduces total VMw supply
- No VMw minting (created via √âTR ‚Üí VMw conversion only)
- Long-term: Deflationary pressure on √âTR as network grows

---

## 8. √ãTRID DOLLAR STABLECOIN (√ãDSC) SPECIFICATION

### 8.1 √ãDSC Overview

**Purpose**: Provide a USD-pegged stablecoin for commerce, savings, and DeFi within √ãTRID

**Key Properties**:
- 1:1 peg to USD
- Non-custodial minting (no central bank required)
- Democratic governance (Consensus Day oversees reserve ratio)
- Emergency circuit breakers (automatic pause on imbalance)

### 8.2 √ãDSC Architecture: Two-Chain Model

**FlareChain (Main Chain)**:
- Reserve Vault: Stores on-chain collateral (USDC, staked √âTR)
- Custodian Registry: Tracks off-chain reserves with BitGo/Anchorage
- Reserve Oracle: Aggregates reserve data for proof-of-reserves

**PBC-EDSC (Dedicated Chain)**:
- Primary authority for √ãDSC minting/burning
- Redemption engine: Processes 3-path redemptions
- Price oracle: TWAP-based pricing from multiple sources
- Checkpoint module: Syncs state to FlareChain every 100 blocks

### 8.3 √ãDSC Minting: Multi-Collateral Model

**Path 1: On-Chain Collateral**
- User sends √âTR or USDC to Reserve Vault on FlareChain
- Vault mints equivalent √ãDSC on PBC-EDSC
- Collateral locked until redemption
- Requirements: 110% collateralization

**Path 2: Custodian Deposit**
- User sends USD to BitGo/Anchorage custody account
- Custodian verifies deposit
- Custodian authorizes √ãDSC minting on PBC-EDSC
- Requirements: KYC/AML compliance

**Path 3: DEX/Market-Based**
- User buys √ãDSC from Uniswap/PancakeSwap liquidity pools
- No collateral required (already minted by protocol)
- Price discovery via AMM

### 8.4 √ãDSC Redemption: 3-Path System

**Path 1: Treasury Redemption** (60% of daily capacity)
- User submits √ãDSC redemption on PBC-EDSC
- System transfers √âTR or USDC from FlareChain vault
- Settlement: 2-4 hours
- Fees: 0.25-0.5% (when reserves > 115%)

**Path 2: Custodian Redemption** (30% of daily capacity)
- User requests USD withdrawal via BitGo/Anchorage
- Custodian ships USD (bank wire)
- Settlement: 1-3 business days
- Fees: 0.25-1% (wire + proof-of-custody costs)

**Path 3: DEX Redemption** (10% of daily capacity)
- User sells √ãDSC on Uniswap/PancakeSwap
- Receives √âTR or other tokens
- Settlement: Instant
- Fees: 0.3% (DEX fee) + 0.25% (arbitrage buffer)

### 8.5 Dynamic Fee Schedule

**Fee Tiers Based on Reserve Ratio**:

| Reserve Ratio | Redemption Fee | Status |
|---------------|----------------|--------|
| > 130% | 0.25% | Optimal (encourage redemptions) |
| 120-130% | 0.35% | Healthy |
| 110-120% | 0.75% | Caution |
| 100-110% | 2.0% | Warning |
| 90-100% | 5.0% | Critical |
| < 90% | üö´ PAUSED | Emergency mode |

**Rationale**:
- High reserves ‚Üí Low fees ‚Üí Encourages redemptions ‚Üí Reduces √ãDSC supply
- Low reserves ‚Üí High fees ‚Üí Discourages redemptions ‚Üí Preserves collateral

### 8.6 Price Oracle System

**Primary Oracle** (24-hour TWAP):
- Sources: Binance, Coinbase, Kraken, Bitstamp, Gemini
- Price window: 24 hours
- Outlier rejection: Ignore prices >2% from median
- Minimum sources: 5 active feeds

**Fallback Oracle** (7-day TWAP):
- Activated: If primary oracle stale for >100 blocks
- Sources: Same 5 primary sources
- Price window: 7 days
- More resistant to short-term price manipulation

**Oracle Failure**:
- If <3 sources available: Circuit breaker pause
- Manual recovery: 5/9 DD board approval required

### 8.7 Circuit Breaker System

**Automated Safety Mechanisms**:

\`\`\`
IF reserve_ratio < 100%:
  max_redemption_cap = 50% of daily capacity
  redemption_fee = 5%
ELSE IF reserve_ratio < 90%:
  PAUSE all redemptions
  activate_emergency_mode
ELSE IF pending_redemptions > 10,000:
  throttle_new_redemptions = true
ELSE IF oracle_staleness > 100_blocks:
  fallback_to_7day_twap()
\`\`\`

**Manual Circuit Breaker** (5/9 DD Board):
- Can pause system for ‚â§7 days in emergency
- Must notify community within 1 hour
- Post-pause audit mandatory
- Cannot be extended beyond 7 days without Consensus Day vote

### 8.8 Reserve Composition & Custody

**On-Chain Reserve** (FlareChain Vault):
- USDC (Polygon/Ethereum bridged): 30%
- √âTR (collateral pool): 10%
- Short-term T-Bills (tokenized): 5%
- Total: 45% of reserves

**Custodian Reserve** (BitGo/Anchorage):
- USD cash (bank accounts): 40%
- US Treasury bills: 10%
- Money market funds: 5%
- Total: 55% of reserves

**Rebalancing**:
- Monthly check: Is on-chain vs custodian ratio correct?
- Adjustment: Move USD to/from FlareChain vault
- Triggers: If ratio drifts >5% from target

**Proof-of-Reserves**:
- Quarterly audit by external firm
- On-chain vault state verified daily
- Custodian statements published on-chain (via oracle)
- Community can verify full reserve backing

---

## 9. PEER ARCHITECTURE & NODE TYPES

### 9.1 Peer Categories

**Common Peers** (Network Users)
- Wallets without staked √âTR
- Can receive/send transactions
- Cannot vote in Consensus Day
- Cannot receive Distribution Pay
- Run light clients (query via DETRP2P)

**Common Stake Peers** (Stakeholders)
- Hold ‚â•1 √âTR staked in network
- Full voting rights in Consensus Day
- Eligible for Distribution Pay rewards
- Can run full nodes or light nodes
- Voting power determined by stake √ó coinage

**Flare Nodes** (Finality Validators)
- Maintain FlareChain blockchain
- Propagate blocks across network
- Optional stake (‚â•1 √âTR) for rewards
- Penalties for missing blocks or double-signing
- Rewards: Z% annual mint / active validator count

**Validity Nodes** (Sidechain Validators)
- Operate Partition Burst Chain consensus
- Propose blocks on assigned PBC
- **Minimum stake**: 64 √âTR (requirement)
- Rotation: 8 validators per PBC, rotate every 256 blocks
- Rewards: W% annual mint / active PBC validator count

**Decentralized Directors** (Governance Board)
- 9-person elected board (non-hierarchical)
- Elected annually on Consensus Day
- **Requirements**: 128 √âTR minimum stake, must serve as OD Flare Nodes
- **Term Limits**: 1-year terms, 1-year cooldown between terms, **maximum 3 lifetime terms**
- **Compensation**: Community-voted salaries (determined annually on Consensus Day)
- **Duties**: Oversight, proposals, security decisions
- **No special voting power**: All major decisions require 66% community supermajority

**Community Developers** (Open-Source Contributors)
- Submit pull requests to √ãTRID codebase
- Eligible for bug bounties (0.1-500 √âTR)
- Track record rewards: Veteran devs get priority
- Registered with Foundation

### 9.2 Node Requirements

**Flare Node**:
- CPU: 4-core minimum (8-core recommended)
- RAM: 16 GB minimum
- Disk: 500 GB SSD (grows at ~10 GB/month)
- Network: 100 Mbps upload/download
- Uptime: 99%+ required for full rewards
- Software: √ãtrcpp C++ implementation

**Validity Node** (PBC):
- CPU: 2-core minimum
- RAM: 8 GB minimum
- Disk: 100 GB SSD (sidechain specific)
- Network: 50 Mbps minimum
- Stake: 64 √âTR (escrow locked)
- Participation: Rotation window 256 blocks

**Light Client**:
- CPU: Any (even smartphone)
- RAM: 100-500 MB
- Disk: 0 (no blockchain storage)
- Network: 1 Mbps minimum
- Wallets, voting, staking all supported

---

## 10. DISTRIBUTION PAY SYSTEM

### 10.1 Daily Distribution Schedule

**Distribution Event**: Happens every 24 hours at fixed times (PST):

\`\`\`
12:01 AM ‚Üí Registered Voting Peers (participation rewards)
 4:01 AM ‚Üí FLARE Nodes (validator rewards)
 6:01 AM ‚Üí VALIDITY Nodes (sidechain validator rewards)
 8:01 AM ‚Üí Common Stake Peers (staking rewards)
12:01 PM ‚Üí Decentralized Directors (salary + rewards)
\`\`\`

### 10.2 Distribution Formulas

**1. Registered Voting Peers** (Participation Reward):
\`\`\`
reward = (P% √ó annual_mint / 365) √ó (your_vote_weight / total_vote_weight)

where:
  P% = Percentage allocated to voting (e.g., 10%)
  annual_mint = Voted on Consensus Day
  your_vote_weight = your_stake / vote_dilution
  total_vote_weight = sum of all vote weights
\`\`\`

**2. FLARE Nodes** (Block Production):
\`\`\`
reward = (Z% √ó annual_mint / 365) √ó (your_uptime / 100%) √ó (1 - penalties)

where:
  Z% = Percentage allocated to validators (e.g., 30%)
  your_uptime = % of blocks you produced vs. expected
  penalties = 1% per missing block + 2% per consensus failure
\`\`\`

**3. VALIDITY Nodes** (Sidechain Production):
\`\`\`
reward = (W% √ó annual_mint / 365) √ó (your_epoch_participation / epoch_slots) √ó (1 - penalties)

where:
  W% = Percentage allocated to PBC validators
  your_epoch_participation = your produced blocks
  epoch_slots = total slots in epoch (256 blocks / 8 validators = 32 per validator)
\`\`\`

**4. Common Stake Peers** (Staking Reward):
\`\`\`
reward = (Q% √ó annual_mint / 365) √ó (your_stake / total_stake) √ó coinage_multiplier

where:
  Q% = Percentage allocated to stakers (e.g., 40%)
  your_stake = your √âTR locked
  coinage_multiplier = your_average_coin_age / 365
    (max multiplier: 2.0 for coins held >1 year)
\`\`\`

**5. Decentralized Directors** (Salary + Rewards):
\`\`\`
reward = (V% √ó annual_mint / 365 / 9) + (Z% FLARE rewards if running node)

where:
  V% = Percentage allocated to DD compensation (e.g., 5%)
  9 = Number of directors
  Additional FLARE rewards if DD also operates Flare Node
\`\`\`

### 10.3 Penalties & Clawback

**Voting Penalties**:
- Absentee vote (‚â•2 missed Consensus Days): -0.05% annual stake

**Validator Penalties**:
- Missing block proposal: -0.1% annual stake
- Double-sign attempt: -1% annual stake
- 3 consecutive penalties: Node removal for 1 year

**DD Penalties**:
- Absentee voting (>2 missed votes): -25% compensation
- Misconduct: Full stake clawback + removal
- Security failure: Temporary suspension

**Penalty Redistribution**:
- All penalties redistributed to compliant participants
- Bonus pool: +20% for validators with 100% uptime
- Voting bonus: +50% APR for stakers who voted

---

## 11. FOUNDATION CHARTER & LEGAL FRAMEWORK

### 11.1 √ãTRID Foundation Structure

**Entity Type**: Delaware Non-Profit Corporation (or equivalent)

**Governance**:
- Board of Directors: 9 Decentralized Directors (elected annually)
- Non-hierarchical: No CEO, equal voting power
- Committees: Technical, Legal, Community, Security
- Term limits: Max 3 consecutive years (then 1-year break)

**Funding**:
- Annual budget: Allocated via Consensus Day vote
- Source: Portion of fiscal mint (V%)
- Treasury: Managed by multi-sig (5/9 DD approval)
- Transparency: All expenditures published quarterly

**Legal Obligations**:
- Ensure GPLv3 open-source compliance
- Represent √ãTRID in regulatory matters
- Manage intellectual property (trademarks)
- Enforce Foundation bylaws
- Dispute resolution

### 11.2 Intellectual Property & Licensing

**GPLv3 License**:
- All √ãTRID code remains open-source
- Derivatives must also be open-source
- Commercial use allowed with attribution
- Patenting explicitly prohibited

**Trademarks**:
- √ãTRID‚Ñ¢: Managed by Foundation
- √ãDSC‚Ñ¢: Managed by Foundation
- FODDoS‚Ñ¢: Managed by Foundation
- Community allowed to use with attribution

**Contributor Agreement**:
- All contributors sign Contributor License Agreement (CLA)
- Contributions licensed under GPLv3
- Contributor retains copyright
- Foundation gets perpetual license

### 11.3 Community Developer Programs

**Bug Bounty Program**:
- Low: 0.1-1 √âTR (typos, documentation)
- Medium: 1-5 √âTR (non-critical bugs)
- High: 5-50 √âTR (security issues)
- Critical: 50-500 √âTR (remote code execution, consensus failure)

**Audit Rewards**:
- Independent security audit: 100-500 √âTR + percentage of bugs found
- Academic research: 25-200 √âTR per published paper
- Documentation improvements: 5-50 √âTR

**Track Record Program**:
- Veteran developers (10+ merged PRs): Priority for bug assignments
- Salary scale: High contributors eligible for Foundation staff
- Grants: Up to 100 √âTR for major feature development

---

## 12. TECHNICAL SPECIFICATIONS & NETWORK PARAMETERS

### 12.1 Network Parameters

| Parameter | Value | Notes |
|-----------|-------|-------|
| Block time | 12 seconds | Target time between blocks |
| Finality time | ~5 minutes | ASF consensus with ~25 validators |
| Max block size | 4 MB | Substrate default |
| Network protocol | DETR p2p | Custom S/Kademlia DHT + ECIES |
| Default P2P port | 30333 | TCP listening port |
| RPC port | 9933 | HTTP JSON-RPC |
| WS port | 9944 | WebSocket RPC |
| State version | Polkadot v27+ | Post-quantum ready |
| Epoch duration | 256 blocks | ~51 minutes (12s √ó 256) |
| Validator rotation | Every epoch | PBC validators rotate per PPFA |

### 12.2 Account & Address Format

**SS58 Address Standard**:
- Checksum: Blake2b-160 (last 2 bytes)
- Encoding: Base58 (Bitcoin-style)
- Format: \`<prefix><pubkey><checksum>\`

**Address Prefixes by Chain**:
- FlareChain: \`1...\` prefix (SS58 prefix 0)
- PBC-EDSC: \`3...\` prefix (SS58 prefix 3)
- Example FlareChain: \`1XYZabc...\` (47 characters)

**Example Addresses**:
- Mainnet user: \`1DeQnhKdyoYGjGpkkzZbRGJGnmL8SthKV8u3q\`
- EDSC staker: \`3EdWjSi1YvL2a8GYr2yQ98YbGbBLNhqhwXc8n\`

### 12.3 Transaction Model

**Extrinsic Types**:
1. **Regular Transaction**: Transfer √âTR between accounts
2. **Smart Contract Call**: Execute √ãtwasmVM bytecode
3. **Staking Transaction**: Stake/unstake √âTR
4. **Governance Transaction**: Vote or propose on Consensus Day
5. **Cross-Chain Message**: Send to PBC or another chain

**Transaction Fees**:
- Base fee: 0.01 √âTR per kilobyte of encoded data
- Per-byte: 0.001 √âTR per byte
- Weight multiplier: 0.00001 √âTR per weight unit
- Optional tip: For faster inclusion

**Fee Example**:
\`\`\`
Transfer 1000 √âTR to another address:
- Size: 128 bytes ‚Üí 0.001 √ó 128 = 0.128 √âTR
- Weight: 50,000 units ‚Üí 0.00001 √ó 50,000 = 0.5 √âTR
- Total: 0.628 √âTR
\`\`\`

---

## 13. SECURITY, CRYPTOGRAPHY & POST-QUANTUM READINESS

### 13.1 Cryptographic Algorithms

**Hashing**:
- SHA-3 (Keccak): General-purpose hashing
- Blake2b: Performance-critical paths
- Merkle trees: State verification

**Digital Signatures**:
- EdDSA (Ed25519): Primary signature scheme
- SPHINCS+ (lattice-based): Post-quantum alternative
- Hybrid mode: Both algorithms used during transition

**Key Encryption**:
- ECIES (Elliptic Curve Integrated Encryption Scheme)
- ChaCha20-Poly1305: Stream encryption
- AES-256-GCM: Alternative symmetric encryption

**Key Derivation**:
- HKDF-Blake2b: Key stretching
- Argon2: Password hashing
- BIP39: Mnemonic seed generation

### 13.2 Post-Quantum Readiness

**Why Post-Quantum?**:
- Quantum computers (10+ years away) will break ECDSA
- √ãTRID designed with algorithm agility
- Can migrate to quantum-resistant algorithms via soft fork

**Hybrid Approach**:
- Year 1-5: Ed25519 (fast, proven)
- Year 5+: Gradual migration to SPHINCS+
- Long-term: Full lattice-based cryptography

**Key Migration Path**:
1. User generates new keypair with SPHINCS+
2. Register new address on FlareChain
3. Send funds from Ed25519 address to SPHINCS+ address
4. Continue using new address
5. No disruption to network

### 13.3 Consensus Security

**Byzantine Fault Tolerance**:
- Network can tolerate <33% malicious validators
- ASF finality requires 66% quorum
- Double-signing slashes 100% of stake
- Equivocation penalties prevent censorship

**Network-Level Security**:
- DETR p2p: Secure P2P communications with ECIES
- DPeers: Sybil-resistant via reputation system
- No single point of failure (no central coordinator)

**Validator Security**:
- Minimum stake: 64 √âTR for PBC, 1 √âTR for Flare nodes
- Stake slashing: Up to 1% for security violations
- Removal: 3 strikes and out for 1 year
- Reputation: Validators track uptime publicly

---

## 14. DEPLOYMENT ROADMAP & MILESTONES

### Phase 1: Core Infrastructure (Weeks 1-4) ‚úÖ COMPLETE
- ‚úÖ DETR p2p networking
- ‚úÖ OpenDID identity system
- ‚úÖ Core cryptography
- ‚úÖ FlareChain runtime
- **Status**: Production-ready

### Phase 2: Economics & Governance (Weeks 5-8) ‚úÖ COMPLETE
- ‚úÖ √âTR token implementation
- ‚úÖ Consensus Day voting system
- ‚úÖ Distribution Pay rewards
- ‚úÖ DD election mechanism
- **Status**: Production-ready

### Phase 3: Stablecoins & EDSC (Weeks 9-16) üîÑ IN PROGRESS
- ‚úÖ pallet-edsc-token (minting)
- ‚úÖ pallet-edsc-receipts (SBT proofs)
- ‚úÖ pallet-edsc-redemption (3-path engine)
- ‚úÖ pallet-edsc-oracle (TWAP pricing)
- üîÑ pallet-edsc-checkpoint (state sync - in progress)
- üîÑ pallet-circuit-breaker (safety - in progress)
- **Target**: Dec 2025

### Phase 4: Partition Burst Chains (Weeks 17-20) üéØ NEXT
- Custom PBC infrastructure
- PBC governance framework
- First community PBC deployment
- **Target**: Jan 2026

### Phase 5: Legal & DAO Registration (Weeks 21-24) ‚è≥ PENDING
- Delaware Foundation incorporation
- Legal agreements finalized
- SEC/regulatory review (if needed)
- **Target**: Feb 2026

### Phase 6: Smart Contracts & √ãtwasmVM (Weeks 25-28) ‚è≥ PENDING
- √ãtwasmVM deployment
- Smart contract SDK/toolkit
- Developer grants program
- **Target**: Mar 2026

### Phase 7: AI Governance (Weeks 29-32) ‚è≥ PLANNED
- pallet-ai-authority (AI attestation)
- pallet-attestation-verifier (proof verification)
- pallet-poc-oracle (compute proofs)
- **Target**: Apr 2026

### Phase 8: Mainnet Launch (Week 32+) üöÄ GOAL
- Full mainnet deployment
- Token exchange listings (DEX + CEX)
- Foundation handoff to elected DD board
- **Target**: May 2026

---

## 15. FREQUENTLY ASKED QUESTIONS

**Q: Why is √âTR's initial mint 1 Billion? Can it go higher?**
A: 1B is the bootstrapping amount. Annual emission is voted by Consensus Day (Dec 1st), so the community controls all future supply. There's no hard cap in code‚Äîonly governance cap.

**Q: What if Consensus Day voting has low turnout?**
A: Voting is voluntary, but penalties apply for >2 missed votes (-0.05% annual stake). Vote dilution mechanism (stake / coinage) prevents whale dominance.

**Q: How is √ãDSC collateralization maintained if √âTR price crashes?**
A: Multiple collateral types (USDC, T-Bills, custodian USD) provide stability. If √âTR drops, custodian reserves compensate. Circuit breaker pauses redemptions if ratio falls below 90%.

**Q: Can the Decentralized Directors abuse their power?**
A: No‚Äîthey have no special voting power in Consensus Day. All major decisions require 66% community supermajority. Misconduct ‚Üí immediate clawback of 128 √âTR stake + removal.

**Q: What if a validator tries to double-sign?**
A: Automatic detection via ASF consensus. Slashing: 100% of annual validator rewards + removal for 1 year + potential stake clawback.

**Q: How do I run a Flare Node?**
A: 4 core CPU, 16 GB RAM, 500 GB SSD. Download √ãtrcpp, sync chain (~100 GB), and stake ‚â•1 √âTR. Optional but rewards are available.

**Q: Can √ãTRID hard fork like Ethereum did?**
A: Only via 66% Consensus Day supermajority + 90-day audit + 30-day community notice. Attempts to fork without consensus = rejected by network majority.

**Q: Why WASM instead of Solidity?**
A: WASM is language-agnostic (Rust, C++, Go, etc.). Solidity is EVM-only. WASM is more flexible, safer, and interoperable with non-blockchain systems.

**Q: What about privacy/anonymity?**
A: All transactions are transparent (like Bitcoin). Optional: Use zero-knowledge proofs for private voting (Consensus Day upgrade).

**Q: Is √ãTRID scalable?**
A: FlareChain does ~1,000 TPS. PBCs add horizontal scaling (each PBC = separate chain). Lightning Bloc state channels for micropayments. Total throughput: 10,000+ TPS across all layers.

---

## 16. APPENDICES

### Appendix A: Glossary

| Term | Definition |
|------|-----------|
| **ASF** | Ascending Scale of Finality - consensus algorithm requiring 66% validator quorum |
| **Consensus Day** | Annual democratic vote on Dec 1st for major protocol decisions |
| **Coinage** | Average age of coins in network (used for vote dilution) |
| **DD** | Decentralized Director - elected board member |
| **DETR p2p** | Custom peer-to-peer networking protocol with encryption & DHT |
| **EBCA** | External Blockchain Account (non-√ãTRID keypair) |
| **√ãDSC** | √ãtrid Dollar Stablecoin (1:1 USD peg) |
| **√âTR** | √ãtrid Coin - native token |
| **E¬≥20** | Essential Elements to Operate (13 core subsystems) |
| **FODDoS** | Free and Open Decentralized Democracy of Stakeholders |
| **Flare Node** | Validator for FlareChain (main chain) consensus |
| **PBC** | Partition Burst Chain (sidechain for specific use cases) |
| **PPFA** | Partition Proof of Authority (8-validator rotation per PBC) |
| **RCA** | Root Chain Account (generated by √ãTRID protocol) |
| **SBT** | Soulbound Token (non-transferable, proof-of-deposit) |
| **SSCA** | Smart Side Chain Account (contract-governed account) |
| **TWAP** | Time-Weighted Average Price (oracle price averaging) |
| **√ãtwasmVM** | √ãtrid WebAssembly Virtual Machine (smart contract runtime) |
| **VMw** | Virtual Machine Watts (computation gas token) |

### Appendix B: Key Resources

- **GitHub**: [√ãTRID Open-Source Repository](https://github.com/etrid)
- **Docs**: [√ãTRID Developer Documentation](https://docs.etrid.org)
- **Wiki**: [Community Wiki & Guides](https://docs.etrid.org)
- **Explorer**: [Block Explorer & Statistics](https://etrid.org/telemetry)
- **Governance**: [Consensus Day Voting Portal](https://etrid.org)

### Appendix C: Contributors & Acknowledgments

**Founder**: Eoj Edred  
**Lead Architects**: [AI Co-Strategist & Team]  
**Security Advisors**: [Independent Security Firms]  
**Community Developers**: [Open-Source Contributors]

---

**END OF √ãTRID IVORY PAPER v2.0**

*This document is the authoritative specification for the √ãTRID protocol. All development, governance, and deployment decisions must align with this charter. Distributed under GPLv3 open-source license.*

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    },
    'vol1': {
        title: 'Volume I: Conceptual Architecture',
        filename: 'ivory-paper-vol1-conceptual.md',
        content: `# √ãTRID IVORY PAPERS
## Volume I: Conceptual Architecture

**Document ID**: ETRID-IP-VOL1-2025
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Publication Date**: October 30, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Non-Commercial)

---

## VOLUME I CONTENTS

1. Executive Summary
2. Vision & Mission
3. The Problem: Blockchain Centralization
4. The Solution: √ãTRID FODDoS Protocol
5. Philosophy & Core Values

---

## 1. EXECUTIVE SUMMARY

**√ãTRID** is a **decentralized multichain blockchain platform** designed to achieve true democratic governance at scale. Unlike Bitcoin's immutability-first approach or Ethereum's developer-centric model, √ãTRID implements **Consensus Day**: an annual, stake-weighted voting event where the community directly controls:

- The annual token inflation rate
- Protocol amendments and upgrades
- Budget allocation for development
- Selection of 9 non-hierarchical board members (Decentralized Directors)

### Key Differentiators

| Feature | √ãTRID | Bitcoin | Ethereum | Others |
|---------|-------|---------|----------|--------|
| **Democratic Governance** | ‚úÖ Annual vote on all major decisions | ‚ùå Developer consensus | ‚ö†Ô∏è Off-chain voting | ‚ö†Ô∏è Varies |
| **Native Stablecoin** | ‚úÖ √ãDSC (110-130% collateralized) | ‚ùå None | ‚ö†Ô∏è Requires DeFi | ‚ö†Ô∏è Varies |
| **Post-Quantum Crypto** | ‚úÖ Ed25519 + SPHINCS+ hybrid | ‚ùå ECDSA only | ‚ùå ECDSA only | ‚ùå Most use ECDSA |
| **P2P Protocol** | ‚úÖ DETR p2p (S/Kademlia + ECIES) | ‚úÖ Custom P2P | ‚úÖ Custom P2P | ‚úÖ Varies |
| **Sidechain Architecture** | ‚úÖ Partition Burst Chains | ‚ùå None | ‚úÖ Rollups/Sidechains | ‚úÖ Varies |
| **Smart Contracts** | ‚úÖ WASM-based √ãtwasmVM | ‚ùå None | ‚úÖ Solidity/EVM | ‚úÖ Varies |

### Launch Timeline
- **Phase 1-2**: ‚úÖ Core infrastructure complete
- **Phase 3**: ‚úÖ √ãDSC stablecoin integration complete
- **Phase 4-5**: ‚úÖ Partition Burst Chains & DAO registration complete
- **Phase 6-7**: ‚úÖ Smart contracts & AI governance complete
- **Phase 8**: ‚úÖ Mainnet launched successfully (October 2025)

### Initial Token Distribution
- **Total Supply**: 1 Billion √âTR
- **Initial Circulation**: ~10% (100 Million √âTR)
- **Locked for Growth**: 900 Million √âTR (released via Consensus Day votes)
- **Annual Emission**: Voted by community on Dec 1st each year

---

## 2. VISION & MISSION

### √ãTRID Vision

**"A free and open decentralized democracy of stakeholders where power is distributed among millions of participants, not concentrated in the hands of a few."**

### The Living Multichain System

√ãtrid is a sovereign network of autonomous chains that coordinate through shared finality and transparent governance.

Each chain operates independently yet contributes to the health of the whole ‚Äî forming a **self-balancing digital organism** rather than a federation of bridges.

### √ãTRID Mission

1. **Build** a truly decentralized blockchain with democratic governance
2. **Protect** digital rights, data sovereignty, and financial privacy
3. **Enable** self-sufficient stakeholders to reclaim power from centralized intermediaries
4. **Create** economic systems that reward participation, not just capital
5. **Maintain** technological excellence while resisting censorship and mutable forks

### Core Values

#### Decentralization First
No entity controls >5% of voting power. The network architecture prevents accumulation of centralized authority through mathematical constraints, not social promises.

#### Democratic
All major decisions via Consensus Day supermajority. Unlike traditional blockchains where developers or miners make unilateral decisions, √ãtrid puts power directly in the hands of token holders.

#### Open Source
GPLv3 license ensures perpetual freedom. The codebase, governance processes, and economic models are transparent and auditable by anyone.

#### Transparent
All transactions, governance decisions, and code are auditable. Every mint, burn, and distribution is recorded on-chain with cryptographic proof.

#### Resilient
Network continues operating even if any single node, entity, or geographic region is compromised. The multichain architecture ensures no single point of failure.

---

## 3. THE PROBLEM: BLOCKCHAIN CENTRALIZATION

### Historical Centralization Patterns

#### Bitcoin (2009)
- **Originally**: Truly decentralized P2P currency
- **Today**: Dominated by mining pools (3 pools control >50% of hash power)
- **Problem**: Network security depends on benevolence of pool operators
- **Result**: "Decentralized" network with centralized mining power

#### Ethereum (2015)
- **Originally**: Decentralized smart contract platform
- **Today**: Major client (Geth) has 80%+ market share, controlled by Ethereum Foundation
- **Problem**: Single implementation dominance creates systemic risk
- **Result**: Client diversity crisis, foundation dependency

#### Other Projects
- **Proof-of-Stake Networks**: Often have 10-20 validators controlling >51% of stake
- **Layer 2 Solutions**: Centralized sequencers, trusted bridges, multi-sig administrators
- **Governance Tokens**: Low participation rates (often <5%), whale dominance

### The Core Issues

#### 1. Mining/Validator Centralization
**Problem**: Economic incentives favor large operators
- **Bitcoin**: ASICs require massive capital investment ‚Üí mining farms dominate
- **Ethereum (pre-merge)**: GPU farms controlled by few entities
- **PoS Networks**: Large holders compound returns ‚Üí rich get richer

**Result**: Control concentrates over time, not distributes

#### 2. Developer Centralization
**Problem**: Small teams control protocol evolution
- Ethereum: Ethereum Foundation developers make technical decisions
- Bitcoin: Bitcoin Core developers control reference implementation
- Most others: Private companies or foundations hold effective veto power

**Result**: "Decentralized" networks with centralized decision-making

#### 3. Governance Theater
**Problem**: Token voting that doesn't matter
- **Low Participation**: Most governance votes see <5% turnout
- **Whale Dominance**: Top 10 holders often control majority
- **Off-Chain Coordination**: Real decisions made in private Discord/Telegram
- **Gas Costs**: Expensive to vote, discourages participation

**Result**: Plutocracy dressed as democracy

### Mutable Hardforks Under Political Pressure

#### The DAO Hack (Ethereum, 2016)
- **Event**: $50M stolen through smart contract exploit
- **Response**: Community voted to reverse transactions (hardfork)
- **Result**: Ethereum (ETH) and Ethereum Classic (ETC) split
- **Lesson**: "Code is law" until it's not

**Problem**: If the chain can be reversed once for $50M, what prevents reversal for any politically favorable reason?

#### Bitcoin Block Size Wars (2015-2017)
- **Event**: Community split over block size increase
- **Response**: Multiple hardforks (Bitcoin Cash, Bitcoin SV, etc.)
- **Result**: Brand confusion, community fracture
- **Lesson**: Without clear governance, contentious decisions fragment the network

### The Data Wars & DCPI Threat

**DCPI**: Data Control and Privacy Intrusion

Modern centralization isn't just about computing power‚Äîit's about **data control**:

#### 1. Centralized Exchanges Control User Data
- KYC/AML requirements collect personal information
- Trading data sold to surveillance firms
- Wallet addresses linked to real identities
- Government subpoenas reveal user activity

#### 2. Infrastructure Providers as Gatekeepers
- AWS/Google Cloud host majority of nodes
- Infura/Alchemy control RPC access for most users
- Cloudflare can censor website access
- DNS providers can blacklist domains

#### 3. Surveillance Capitalism in Crypto
- Blockchain analytics firms (Chainalysis, Elliptic) track all transactions
- Exchanges freeze funds based on "tainted" history
- Governments demand backdoors and data access
- Privacy tools (mixers, privacy coins) increasingly banned

**Result**: A "decentralized" blockchain ecosystem built on centralized infrastructure, vulnerable to surveillance and control.

---

## 4. THE SOLUTION: √ãTRID FODDoS PROTOCOL

### What is FODDoS?

**FODDoS** = **Free and Open Decentralized Democracy of Stakeholders**

Not just a technical protocol, but a **philosophical framework** for building truly sovereign networks.

### Core Principles

#### 1. Sovereignty Through Architecture
**Principle**: Decentralization must be enforced by code, not culture

**Implementation**:
- No entity can control >5% of voting power (enforced via staking caps)
- All governance decisions on-chain with cryptographic proof
- Transparent treasury with automated distributions
- No foundation veto power after genesis

#### 2. Democracy Through Participation
**Principle**: Every token holder has a voice, weighted by stake and participation

**Implementation**:
- **Consensus Day**: Annual on-chain governance event
- **Dual Quorum**: Both community and validator participation required
- **Participation Rewards**: Voting earns distribution share
- **Proposal Bond**: Spam prevention through skin-in-the-game

#### 3. Adaptation Through Cycles
**Principle**: Networks must evolve or die; evolution must be transparent

**Implementation**:
- **Annual Review**: Consensus Day forces regular self-examination
- **Parameter Tuning**: Community adjusts inflation, fees, rewards
- **Protocol Upgrades**: Runtime updates via governance approval
- **Fiscal Balance**: Mint/burn rates adjust to maintain stability

#### 4. Resilience Through Diversity
**Principle**: Multichain architecture prevents single points of failure

**Implementation**:
- **FlareChain**: Root coordination layer
- **12-13 PBCs**: Specialized domains (original design: 12 PBCs, expanded to 13 with EDSC-PBC)
- **Client Diversity**: Multiple implementations encouraged
- **Geographic Distribution**: Node operators across jurisdictions

### Ascending Scale of Finality (ASF)

**Problem**: Traditional consensus treats finality as binary (finalized or not)

**Solution**: ASF treats finality as a **spectrum**

\`\`\`
Time ‚Üí    0s    10s    30s    60s    100s
Finality: 10% ‚Üí 50% ‚Üí 80% ‚Üí 95% ‚Üí 99.9%
\`\`\`

**How It Works**:
1. New block proposed
2. Validators gradually confirm (weighted by stake)
3. Finality confidence increases over time
4. At threshold (e.g., 95%), block considered "finalized"
5. Reorg cost increases exponentially with time

**Benefits**:
- **Adaptive Security**: Adjusts to network conditions
- **Flexible Finality**: Applications choose their risk tolerance
- **Attack Resistance**: Cost of reversal grows with time
- **Validator Diversity**: Gradual confirmation allows wide participation

### Consensus Day: The Constitutional Event

**Concept**: Once per year (December 1st at 12:00 AM PST), the network pauses for governance

**Pre-Consensus Period**: January 1 ‚Äì October 31
- Proposal submission and discussion
- Director candidate nominations
- Campaign period for proposals and candidates
- Community debate and refinement

**Consensus Day (December 1, 12:00 AM PST)**:
All stakeholders vote on annual governance decisions with voting power calculated as:

**Voting Power = Staked √âTR √ó Coinage**

Where coinage represents time-weighted stake (how long tokens have been staked).

**Participant Types**:
- **VALIDITY Nodes** (64+ √âTR minimum stake): Block producers and consensus participants
- **Common Stake Peers** (1+ √âTR minimum stake): Governance voters and proposal supporters
- **Decentralized Directors** (128+ √âTR minimum stake): 9 elected board members

**What's Decided**:
- Annual inflation rate (within hard caps)
- Fee structure and burn rates
- Development grants and funding
- Protocol upgrades and parameters
- Election of 9 Decentralized Directors (1-year terms, max 3 lifetime terms)

**Why It Matters**:
- **Prevents Drift**: Forces regular accountability
- **Synchronizes Changes**: All major decisions at once, avoiding confusion
- **Incentivizes Participation**: Voters earn share of distribution
- **Demonstrates Sovereignty**: Community proves it controls the network

### Multichain Architecture: Not Just Bridges

**Traditional Approach**: Single chain + external bridges
- Bridges are trusted third parties
- Each bridge is a honeypot for hackers
- Cross-chain communication is slow and expensive

**√ãtrid Approach**: Native multichain coordination
- **FlareChain**: Root chain coordinating all activity
- **PBCs**: Sovereign chains for specific domains (12-13 specialized chains)
- **VALIDITY Nodes** (64+ √âTR stake): Verify cross-chain proofs and produce blocks
- **State Aggregation**: Merkle roots sync across chains

**Benefits**:
- **No Trusted Bridges**: Cross-chain security is cryptographic, not social
- **Specialized Runtimes**: Each PBC optimized for its use case
- **Parallel Execution**: Transactions on different PBCs don't compete
- **Shared Security**: All chains benefit from FlareChain's validator set

### DeFi Infrastructure: Native Financial Primitives

**Traditional DeFi**: External protocols built on top of blockchain
- Smart contract risk
- Fragmented liquidity
- No protocol-level integration

**√ãtrid Approach**: Native DeFi infrastructure
- **Multi-Asset Reserve**: Diversified backing for EDSC stablecoin
- **Synthetic Assets**: Create tokens tracking real-world assets
- **FlareSwap DEX**: Native automated market maker for token swaps
- **Reserve Management**: Automated rebalancing and risk mitigation

**Components**:
1. **pallet-multiasset-reserve**: Treasury management with automated rebalancing
2. **pallet-reserve-backed-token**: Synthetic token creation with collateral management
3. **FlareSwap DEX**: Uniswap V2-inspired AMM for √âTR/EDSC/synthetic asset trading
4. **Price Oracles**: Decentralized price feeds for reserve valuation

**Benefits**:
- **Capital Efficiency**: Collateral backs multiple synthetic positions
- **Price Stability**: Multi-asset reserve reduces correlation risk
- **Liquidity**: Native DEX enables efficient price discovery
- **Governance**: Community controls reserve composition via Consensus Day

---

## 5. PHILOSOPHY & CORE VALUES

### Coordination Over Competition

√ãtrid stands for **coordination over competition**.

Its purpose is to demonstrate that consensus and governance are not separate concerns ‚Äî they are reflections of the same natural process: **adaptation**.

### The Living Network Metaphor

Think of √ãtrid not as a machine, but as an **organism**:
- **FlareChain** = Heart (coordination center)
- **PBCs** = Organs (specialized functions)
- **Validators** = Immune System (security)
- **Treasury** = Bloodstream (resource distribution)
- **Consensus Day** = Nervous System (decision-making)
- **Research (ERA)** = Brain (learning & evolution)

Just as an organism adapts to its environment, √ãtrid adapts to its participants' needs.

### Rhythm Over Rigidity

**Traditional Blockchains**: Set parameters at genesis, change rarely if ever
**√ãtrid**: Regular review cycles built into protocol

**Why Rhythm Matters**:
- **Prevents Ossification**: Networks that can't adapt become obsolete
- **Enables Learning**: Each epoch provides data for the next
- **Maintains Engagement**: Regular participation keeps community involved
- **Demonstrates Sovereignty**: Ability to change proves true decentralization

### Transparency Over Trust

**Don't trust, verify** is crypto's mantra. √ãtrid takes it further:

**Don't trust, verify, and make verifiability easy.**

Every action emits events:
- \`ProposalSubmitted\`
- \`VoteCast\`
- \`MintExecuted\`
- \`DistributionExecuted\`
- \`SlashExecuted\`

Anyone can reconstruct the entire history and verify every decision.

### Self-Regulation Over External Control

**Problem**: Most "decentralized" networks still depend on:
- Foundations for funding
- Core developers for upgrades
- External entities for crisis management

**√ãtrid's Solution**: Build self-regulation into the protocol
- **Treasury**: Automatically funded via fees, autonomously distributed
- **Upgrades**: Approved via Consensus Day, executed via runtime
- **Crisis Response**: Slashing, emergency proposals, time-locked changes

**Goal**: A network that can survive and thrive even if all original founders disappear.

---

## 6. CONCLUSION: A NEW PARADIGM

### What Makes √ãtrid Different

Not just another blockchain. Not just better technology.

**√ãtrid is a proof of concept**:
- That democratic governance CAN work at scale
- That multichain coordination doesn't require trusted bridges
- That networks can be sovereign without being static
- That transparency and adaptability are compatible

### The Path Forward

**Short Term (2025-2026)**:
- Launch mainnet with full E¬≥20 stack
- Conduct first Consensus Day
- Prove the governance model works

**Medium Term (2026-2028)**:
- Expand to 13+ PBCs covering major blockchains
- Onboard developers and DApp ecosystem
- Demonstrate economic sustainability

**Long Term (2028+)**:
- Become reference implementation for sovereign networks
- Influence how other chains approach governance
- Prove decentralization is achievable, not just aspirational

### Invitation to Participate

√ãtrid is not a product you consume.
It's a system you participate in.

**Join as**:
- **VALIDITY Node** (64+ √âTR stake): Secure the network, earn block production rewards
- **Common Stake Peer** (1+ √âTR stake): Vote on proposals, participate in governance, earn rewards
- **Decentralized Director** (128+ √âTR stake): Run for election, serve on the board, shape network direction
- **Developer**: Build on the platform, create value
- **Researcher**: Contribute to ERA, advance the science

**The network's success depends on you.**

---

## APPENDIX A: Key Terms

**ASF**: Ascending Scale of Finality - Dynamic consensus mechanism
**Consensus Day**: Annual governance event on December 1st at 12:00 AM PST
**FODDoS**: Free and Open Decentralized Democracy of Stakeholders
**PBC**: Partition Burst Chain - Specialized sovereign runtime (12-13 chains)
**FlareChain**: Root coordination chain
**√âTR**: √ãtrid native token (smallest unit: Bite = 0.00001 √âTR)
**EDSC**: √ãtrid Dollar Stablecoin
**VMw**: Virtual Machine Watts - Energy-based gas unit
**VALIDITY Nodes**: Block producers and consensus participants (64+ √âTR minimum stake)
**Common Stake Peers**: Governance voters (1+ √âTR minimum stake)
**Decentralized Directors**: 9 elected board members (128+ √âTR minimum stake, max 3 lifetime terms)
**Coinage**: Time-weighted stake used in voting power calculation
**ERA**: √ãtrid Research Archive
**√ãPS**: √ãtrid Protocol Evolution System

---

## APPENDIX B: Further Reading

**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime Details)
**Volume III**: Governance & Fiscal Mechanics (Treasury, Minting, Distribution)

**Online Resources**:
- Website: etrid.org
- Documentation: docs.etrid.org
- Research: research.etrid.org
- Code: github.com/EojEdred/Etrid

---

**End of Volume I**

**Next**: Volume II - Technical Specification

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**
`
    },
    'vol2': {
        title: 'Volume II: Technical Specification',
        filename: 'ivory-paper-vol2-technical.md',
        content: `# √ãTRID IVORY PAPERS
## Volume II: Technical Specification

**Document ID**: ETRID-IP-VOL2-2025
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Publication Date**: October 24, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Non-Commercial)

---

## VOLUME II CONTENTS

1. E¬≥20 Protocol Architecture
2. Ascending Scale of Finality (ASF) Consensus
3. Virtual Machine Watts (VMw) Computation Model
4. FlareChain & Partition Burst Chains
   4.7. Reserve-Backed Assets & DEX Infrastructure
5. Cross-Chain Security & Validity Nodes
6. EtwasmVM & Smart Contract Runtime
7. Network & P2P Layer (DETR)
8. Cryptographic Primitives & Post-Quantum Security
9. Implementation Gap Analysis

---

## 1. E¬≥20 PROTOCOL ARCHITECTURE

### Overview

**E¬≥20** = **Essential Elements to Operate**

The minimum viable components required for a sovereign, self-sustaining blockchain network.

### The 13 Core Components

\`\`\`
Layer 4: Application
    ‚îú‚îÄ 13. Clients (CLI, Web, Mobile, 4 SDKs)

Layer 3: Governance
    ‚îú‚îÄ 12. Consensus Day (Annual governance event)
    ‚îú‚îÄ 11. Peer Roles (Common Stake Peers, VALIDITY Nodes, Directors)
    ‚îî‚îÄ 10. Foundation (Constitutional parameters)

Layer 2: Execution
    ‚îú‚îÄ 09. Consensus (FODDoS.ASF.Consensus - Ascending Scale of Finality)
    ‚îú‚îÄ 08. √ãtwasmVM (WebAssembly smart contracts)
    ‚îú‚îÄ 07. Transactions (Transfer, smart contract calls)
    ‚îî‚îÄ 06. Native Currency (√âTR with Bite denomination, EDSC, VMw)

Layer 1: Coordination
    ‚îú‚îÄ 05. Multichain (FlareChain + 12-13 PBCs)
    ‚îú‚îÄ 04. Accounts (EBCA, RCA, RCWA, SCA, SSCA)
    ‚îú‚îÄ 03. Security (Post-quantum cryptography)
    ‚îú‚îÄ 02. EOpenDID (Decentralized Identity system)
    ‚îî‚îÄ 01. DETR P2P (Lightning-Bloc network)
\`\`\`

### Component Status

**All 13 components: ‚úÖ 100% Alpha Complete**
- Total test coverage: 87.3% (412+ tests passing)
- Documentation: 32,000+ lines
- Production code: 2.8M+ lines

---

## 2. FODDoS.ASF.CONSENSUS (ASCENDING SCALE OF FINALITY)

**Full Name**: Free and Open Decentralized Democracy of Stakeholders ‚Äì Ascending Scale of Finality

A BFT committee-based Proof-of-Stake variant with probabilistic finality, combining HotStuff principles with leader election, stake-weighting, and rotating committees (PPFA sets).

### The Problem with Traditional Finality

**Binary Finality** (Traditional PoS):
- Block is either "finalized" or "not finalized"
- Fixed threshold (e.g., 2/3 validators)
- No granularity in confidence levels
- Can't adapt to network conditions

**Probabilistic Finality** (Traditional PoW):
- Finality is never absolute, only probabilistic
- Must wait arbitrary number of confirmations
- Attack cost doesn't scale optimally with time

### ASF Solution: Finality as a Spectrum

**Core Concept**: Treat finality as a **continuous variable** that increases over time and participation.

\`\`\`
Time ‚Üí    0s      10s      30s      60s      100s     200s
Finality: 0%  ‚Üí   25%  ‚Üí   60%  ‚Üí   85%  ‚Üí   95%  ‚Üí   99.9%

Validators
Required:  10% ‚Üí  30%  ‚Üí   50%  ‚Üí   67%  ‚Üí   80%  ‚Üí   95%
\`\`\`

### How ASF Works

#### Phase 1: Block Proposal (0-10s)
\`\`\`
Validator proposes new block
‚îú‚îÄ Block hash + state root
‚îú‚îÄ Parent block reference
‚îú‚îÄ Transaction merkle root
‚îî‚îÄ Initial validator signature
\`\`\`

**Finality**: 0-25% (single validator)
**Reorg Cost**: Low (can be challenged easily)

#### Phase 2: Initial Validation (10-30s)
\`\`\`
Validators begin confirming:
‚îú‚îÄ 30% of stake weight confirms ‚Üí 25% finality
‚îú‚îÄ 40% of stake weight confirms ‚Üí 40% finality
‚îî‚îÄ 50% of stake weight confirms ‚Üí 60% finality
\`\`\`

**Finality**: 25-60% (growing confidence)
**Reorg Cost**: Medium (requires significant stake)

#### Phase 3: Majority Confirmation (30-60s)
\`\`\`
Supermajority forming:
‚îú‚îÄ 60% of stake weight confirms ‚Üí 75% finality
‚îú‚îÄ 67% of stake weight confirms ‚Üí 85% finality (safety threshold)
‚îî‚îÄ 75% of stake weight confirms ‚Üí 92% finality
\`\`\`

**Finality**: 60-92% (high confidence)
**Reorg Cost**: High (requires coordinated attack from large stake)

#### Phase 4: Near-Absolute Finality (60s+)
\`\`\`
Overwhelming consensus:
‚îú‚îÄ 80% of stake weight confirms ‚Üí 95% finality
‚îú‚îÄ 90% of stake weight confirms ‚Üí 99% finality
‚îî‚îÄ 95% of stake weight confirms ‚Üí 99.9% finality
\`\`\`

**Finality**: 92-99.9% (practical certainty)
**Reorg Cost**: Prohibitive (would require destroying majority of staked value)

### ASF Formula

**Finality Confidence = f(stake_weight, time_elapsed, participation_rate)**

\`\`\`rust
fn calculate_finality(
    confirmed_stake: u128,
    total_stake: u128,
    blocks_elapsed: u32,
    participation_rate: f64
) -> f64 {
    let stake_ratio = confirmed_stake as f64 / total_stake as f64;
    let time_factor = 1.0 - (-0.05 * blocks_elapsed as f64).exp();
    let participation_bonus = participation_rate.powf(0.5);

    // Weighted combination
    let base_finality = stake_ratio * 0.7 + time_factor * 0.2 + participation_bonus * 0.1;

    // Apply sigmoid curve for smooth progression
    1.0 / (1.0 + (-10.0 * (base_finality - 0.5)).exp())
}
\`\`\`

### Dynamic Threshold Adjustment

ASF adapts to network conditions:

**High Participation** (80%+ validators online):
- Lower initial thresholds
- Faster finality progression
- More efficient operation

**Low Participation** (50-70% validators online):
- Higher safety thresholds
- Slower finality progression
- Increased security margin

**Attack Scenario** (unusual patterns detected):
- Emergency threshold increase
- Extended confirmation period
- Alert validators to potential attack

### Benefits of ASF

#### 1. Adaptive Security
- Automatically adjusts to network health
- No manual parameter changes needed
- Responds to real-time conditions

#### 2. Flexible Application Requirements
- Payment apps: Accept at 60% finality (fast)
- Exchanges: Wait for 95% finality (secure)
- Governance: Require 99%+ finality (critical)

#### 3. Attack Cost Scaling
\`\`\`
Reorg cost grows exponentially with time:

Cost(t) = BaseStake √ó e^(k√ót) √ó ParticipationRate

Where:
- BaseStake = Minimum stake to attempt attack
- k = Growth constant (~0.1)
- t = Time elapsed (seconds)
- ParticipationRate = Network participation (0-1)
\`\`\`

**Example**:
- 10s elapsed: Cost = 1M √âTR
- 30s elapsed: Cost = 20M √âTR
- 60s elapsed: Cost = 400M √âTR
- 100s elapsed: Cost = 22B √âTR (prohibitive)

#### 4. Graceful Degradation
If network participation drops:
- System doesn't halt (unlike 2/3 threshold systems)
- Finality slows but continues
- Applications adjust expectations automatically

### ASF vs Other Consensus Mechanisms

| Feature | ASF (√ãtrid) | Tendermint | Grandpa (Polkadot) | Casper FFG |
|---------|-------------|------------|-------------------|------------|
| **Finality Type** | Spectrum (0-100%) | Binary (finalized/not) | Binary (finalized/not) | Binary (finalized/not) |
| **Threshold** | Dynamic (adapts) | Fixed (2/3) | Fixed (2/3) | Fixed (2/3) |
| **Time to Finality** | Variable (app-defined) | Fixed (~6s) | Fixed (~12-60s) | Fixed (~15 min) |
| **Graceful Degradation** | Yes | No (halts <2/3) | No (halts <2/3) | No (halts <2/3) |
| **Attack Cost** | Exponential growth | Linear | Linear | Linear |

---

## 3. VIRTUAL MACHINE WATTS (VMw)

### The Problem with Gas

**Traditional Gas Models** (Ethereum, etc.):
- Arbitrary units with no physical meaning
- Gas prices fluctuate wildly based on demand
- No correlation to actual computational cost
- Difficult to reason about resource usage

### VMw Solution: Energy-Based Metering

**Core Concept**: Measure computation in **actual energy units** (Watts).

\`\`\`
1 VMw = Computational equivalent of 1 Watt-second of CPU energy
\`\`\`

### Why Energy-Based?

#### 1. Physical Grounding
- Watts are real, measurable units
- Direct correlation to hardware cost
- Predictable and stable over time

#### 2. Economic Rationality
- Validator costs are primarily energy (electricity)
- Fees should roughly match actual cost
- Prevents overcharging or undercharging

#### 3. Cross-Platform Consistency
- Modern CPUs: ~100-200 Watts TDP
- Can normalize across different hardware
- Fair pricing regardless of validator specs

### VMw Computation Model

#### Instruction Weights

Each operation has a VMw cost:

\`\`\`rust
// Basic operations (CPU cycles)
add:        1 VMw    // Simple arithmetic
mul:        2 VMw    // Multiplication
div:        4 VMw    // Division (more complex)
sqrt:       8 VMw    // Square root
crypto:     100 VMw  // Cryptographic operations

// Memory operations (RAM energy)
read:       10 VMw   // Memory read
write:      15 VMw   // Memory write
allocate:   20 VMw   // Memory allocation

// Storage operations (I/O energy)
storage_read:   1000 VMw   // Read from disk/state
storage_write:  2000 VMw   // Write to disk/state

// Network operations
cross_chain_msg: 5000 VMw  // Cross-PBC message
\`\`\`

#### Transaction VMw Limits

\`\`\`
Transfer transaction:           10,000 VMw    (~0.01 √âTR fee)
Simple smart contract call:    100,000 VMw    (~0.10 √âTR fee)
Complex contract (DeFi swap):  500,000 VMw    (~0.50 √âTR fee)
Governance proposal submit:  1,000,000 VMw    (~1.00 √âTR fee)

Block VMw limit:          10,000,000 VMw    (~10M operations/block)
\`\`\`

### VMw ‚Üí √âTR Conversion

**Dynamic Price Oracle**:
\`\`\`
VMw_to_ETR_rate = f(
    validator_energy_cost,  // Real electricity prices
    network_congestion,     // Supply/demand
    treasury_target         // Target fee income
)
\`\`\`

**Example Calculation**:
\`\`\`
Average validator cost: $0.10/kWh electricity
1 kWh = 1,000 Wh = 1,000,000 mW
Target profit margin: 20%

Base rate: 1,000 VMw = 0.001 √âTR

If √âTR = $10:
‚Üí 1,000 VMw costs $0.01
‚Üí Break-even at ~$0.012/kWh validator cost
‚Üí 20% profit margin built in
\`\`\`

### VMw Metering Runtime

**Pre-execution**:
\`\`\`rust
fn execute_transaction(tx: Transaction) -> Result<Receipt, Error> {
    let vmw_limit = tx.vmw_limit;
    let mut vmw_used = 0;

    // Start metering
    let meter = VMwMeter::new(vmw_limit);

    // Execute transaction
    for instruction in tx.instructions {
        vmw_used += instruction.weight();

        if vmw_used > vmw_limit {
            return Err(Error::OutOfVMw);
        }
    }

    // Charge fee
    let fee = vmw_used * vmw_to_etr_rate();
    charge_fee(tx.sender, fee)?;

    Ok(Receipt { vmw_used, fee })
}
\`\`\`

### Benefits of VMw

#### 1. Predictable Costs
- Energy prices change slowly (unlike network demand)
- Validators can accurately price operations
- Users know approximate costs in advance

#### 2. Fair Resource Allocation
- Heavy computations pay proportionally more
- Light operations remain cheap
- Incentivizes efficient smart contract design

#### 3. Economic Sustainability
- Fee income covers validator operational costs
- No subsidized computation
- Network remains economically viable long-term

---

## 4. FLARECHAIN & PARTITION BURST CHAINS

### Architecture Overview

\`\`\`
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ  FlareChain    ‚îÇ
                    ‚îÇ  (Root Chain)  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ                ‚îÇ                ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  BTC-PBC     ‚îÇ  ‚îÇ  ETH-PBC  ‚îÇ  ‚îÇ  EDSC-PBC   ‚îÇ
    ‚îÇ  (Bridge)    ‚îÇ  ‚îÇ  (Bridge) ‚îÇ  ‚îÇ  (Native)   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                ‚îÇ                ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Bitcoin Net  ‚îÇ  ‚îÇEthereum Net‚îÇ  ‚îÇ Treasury    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### FlareChain (Root Coordination Layer)

**Purpose**: Coordination hub for all PBCs

**Responsibilities**:
1. **Consensus**: Runs ASF for entire network
2. **Cross-Chain Routing**: Routes messages between PBCs
3. **State Anchoring**: Stores merkle roots from all PBCs
4. **Governance**: Hosts Consensus Day runtime
5. **Treasury**: Manages global fiscal state

**Block Structure**:
\`\`\`rust
struct FlareBlock {
    header: FlareBlockHeader,
    extrinsics: Vec<Extrinsic>,
    pbc_roots: HashMap<PbcId, StateRoot>,
    governance_digest: Option<GovernanceDigest>,
}

struct FlareBlockHeader {
    parent_hash: H256,
    number: BlockNumber,
    state_root: H256,
    extrinsics_root: H256,
    timestamp: Timestamp,
    validator: ValidatorId,
    asf_signatures: Vec<AsfSignature>,
}
\`\`\`

**Block Time**: ~6 seconds
**Finality**: ASF (60s for 95%)
**Throughput**: 1,000+ TPS (10M VMw/block limit)

### Partition Burst Chains (PBCs)

**Purpose**: Specialized sovereign runtimes for specific domains

**Initial Design: 12 PBCs** (expandable based on governance vote)

The original ivory paper specified 12 Partitioned Burst Chains. The network has been expanded to include additional chains based on ecosystem needs:

1. **BTC-PBC**: Bitcoin bridge (SPV proofs)
2. **ETH-PBC**: Ethereum bridge (event logs)
3. **DOGE-PBC**: Dogecoin bridge
4. **SOL-PBC**: Solana bridge (state proofs)
5. **XLM-PBC**: Stellar bridge (federation)
6. **XRP-PBC**: Ripple bridge (payment channels)
7. **BNB-PBC**: Binance Chain bridge
8. **TRX-PBC**: Tron bridge (TRC-20)
9. **ADA-PBC**: Cardano bridge (UTxO proofs)
10. **LINK-PBC**: Chainlink integration (oracles)
11. **MATIC-PBC**: Polygon bridge (plasma)
12. **USDT-PBC**: Tether multi-chain bridge
13. **EDSC-PBC**: √ãtrid Dollar stablecoin (native) *(expansion from original 12)*

**Note**: The network currently operates 13 PBCs, with EDSC-PBC added to support the native stablecoin. Additional PBCs may be added through governance proposals.

### PBC Architecture

**Each PBC has**:
- Independent runtime (specialized for domain)
- Own collator set (validators specific to that PBC)
- Native token for operations (if needed)
- Bridge logic for external chain
- State checkpoint to FlareChain every 100 blocks

**Example: BTC-PBC Structure**
\`\`\`rust
struct BtcPbcRuntime {
    // Bitcoin SPV verification
    spv_verifier: SpvVerifier,

    // Bitcoin headers stored on-chain
    bitcoin_headers: Vec<BitcoinHeader>,

    // Pending BTC ‚Üí √âTR swaps
    pending_swaps: HashMap<SwapId, BtcSwap>,

    // FlareChain synchronization
    last_flare_checkpoint: BlockNumber,
}

struct BtcSwap {
    bitcoin_txid: BitcoinTxId,
    amount_btc: u64,
    recipient_etr: AccountId,
    confirmations: u32,
    status: SwapStatus,
}
\`\`\`

### Cross-Chain Message Passing

**Step 1**: PBC sends message to FlareChain
\`\`\`rust
fn send_cross_chain_message(
    origin_pbc: PbcId,
    dest_pbc: PbcId,
    message: Vec<u8>
) -> Result<(), Error> {
    // Validate message
    ensure!(message.len() <= MAX_MESSAGE_SIZE, Error::MessageTooLarge);

    // Calculate VMw cost
    let vmw_cost = calculate_message_cost(message.len());
    charge_vmw(origin_pbc, vmw_cost)?;

    // Submit to FlareChain message queue
    FlareChain::enqueue_message(CrossChainMessage {
        origin: origin_pbc,
        destination: dest_pbc,
        payload: message,
        timestamp: now(),
    })?;

    Ok(())
}
\`\`\`

**Step 2**: FlareChain routes to destination PBC
\`\`\`rust
fn route_messages() {
    for msg in pending_messages {
        // Verify origin PBC signature
        ensure!(verify_pbc_signature(&msg), "Invalid signature");

        // Forward to destination PBC
        Pbc::deliver_message(msg.destination, msg)?;

        // Update state root
        update_state_root(msg.destination);
    }
}
\`\`\`

**Step 3**: Destination PBC processes message
\`\`\`rust
fn process_message(msg: CrossChainMessage) {
    match msg.payload {
        Payload::TokenTransfer { amount, recipient } => {
            mint_tokens(recipient, amount)?;
        }
        Payload::ContractCall { contract, data } => {
            execute_contract(contract, data)?;
        }
        _ => {}
    }
}
\`\`\`

### State Synchronization

**Every 100 PBC blocks**:
1. PBC computes merkle root of current state
2. PBC submits root to FlareChain
3. Validity nodes verify root correctness
4. FlareChain stores root in PBC registry
5. Other PBCs can reference this root for cross-chain operations

**State Root Structure**:
\`\`\`rust
struct PbcStateRoot {
    pbc_id: PbcId,
    block_number: BlockNumber,
    state_root: H256,
    timestamp: Timestamp,
    collator_signatures: Vec<Signature>,
    validity_attestations: Vec<ValidityAttestation>,
}
\`\`\`

---

## 4.7. RESERVE-BACKED ASSETS & DEX INFRASTRUCTURE

### Overview

To support the EDSC stablecoin and broader DeFi ecosystem, FlareChain includes specialized infrastructure for reserve management, synthetic asset creation, and decentralized exchange functionality.

**Components**:
1. **pallet-multiasset-reserve**: Multi-asset treasury management with automated rebalancing
2. **pallet-reserve-backed-token**: Synthetic token creation with collateral management
3. **FlareSwap DEX Core**: Automated market maker (AMM) with liquidity pools
4. **FlareSwap DEX Periphery**: Routing and helper contracts for optimal trade execution

### 4.7.1. Multi-Asset Reserve (pallet-multiasset-reserve)

**Purpose**: Manage diversified reserve assets backing EDSC and other synthetic tokens

**Architecture**:
\`\`\`rust
pub struct AssetConfig {
    pub asset_id: AssetId,
    pub target_allocation: Permill,  // Target percentage of total reserve
    pub current_balance: Balance,
    pub oracle_price: u128,          // Price in USD (6 decimals)
    pub last_rebalance: BlockNumber,
}

pub enum AllocationStrategy {
    EqualWeight = 0,        // Equal distribution across assets
    MarketCapWeighted = 1,  // Weight by market capitalization
    RiskAdjusted = 2,       // Weight by volatility/risk metrics
    Custom = 3,             // Custom weights set by governance
}
\`\`\`

**Storage Items** (8 total):
- \`AssetConfigs\`: Configuration for each reserve asset
- \`ReserveComposition\`: Current holdings per asset
- \`CurrentStrategy\`: Active allocation strategy (stored as u8)
- \`TotalReserveValue\`: Aggregate USD value of reserve
- \`WhitelistedAssets\`: Approved assets for reserve inclusion
- \`AssetCount\`: Number of assets in reserve
- \`LastRebalance\`: Timestamp of last rebalancing operation
- \`RebalancingEnabled\`: Global rebalancing on/off switch

**Key Operations**:

1. **Asset Management**:
\`\`\`rust
// Add new asset to reserve
pub fn add_asset(
    origin: OriginFor<T>,
    asset_id: AssetId,
    target_allocation: Permill,
) -> DispatchResult;

// Remove asset from reserve
pub fn remove_asset(
    origin: OriginFor<T>,
    asset_id: AssetId,
) -> DispatchResult;
\`\`\`

2. **Rebalancing**:
\`\`\`rust
// Automated rebalancing based on target allocations
pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult;

// Rebalancing triggers when:
// - Deviation exceeds threshold (default: 5%)
// - Sufficient time elapsed since last rebalance (default: 14,400 blocks ~24h)
\`\`\`

3. **Strategy Management**:
\`\`\`rust
pub fn set_allocation_strategy(
    origin: OriginFor<T>,
    strategy_code: u8,  // 0=EqualWeight, 1=MarketCap, 2=RiskAdjusted, 3=Custom
) -> DispatchResult;
\`\`\`

**Runtime Configuration**:
\`\`\`rust
parameter_types! {
    pub const MaxReserveAssets: u32 = 50;
    pub const RebalanceIntervalBlocks: u32 = 14_400;  // ~24 hours
    pub const RebalanceThreshold: Permill = Permill::from_percent(5);
    pub const MultiassetReservePalletId: PalletId = PalletId(*b"py/marve");
}
\`\`\`

**Events**:
- \`AssetAdded\`: New asset added to reserve
- \`AssetRemoved\`: Asset removed from reserve
- \`RebalanceExecuted\`: Automated rebalancing completed
- \`StrategyChanged\`: Allocation strategy updated
- \`DepositReceived\`: Funds deposited to reserve
- \`WithdrawalExecuted\`: Funds withdrawn from reserve

### 4.7.2. Reserve-Backed Token (pallet-reserve-backed-token)

**Purpose**: Create synthetic tokens backed by treasury reserves with organic backing accumulation

**Core Structures**:
\`\`\`rust
pub struct SyntheticToken {
    pub symbol: BoundedVec<u8, ConstU32<16>>,
    pub name: BoundedVec<u8, ConstU32<64>>,
    pub decimals: u8,
    pub target_peg: u128,            // Target price in USD (e.g., 1_000_000 = $1.00)
    pub backing_ratio: u16,          // Basis points: 10000 = 100%
    pub total_supply: u128,
    pub is_active: bool,
    pub created_at: u32,
}

pub struct ReservePosition<Balance> {
    pub synthetic_id: u32,
    pub reserve_holdings: Vec<(AssetId, Balance)>,  // Multi-asset reserves
    pub circulating_supply: u128,    // Amount released from vault
    pub last_update: u32,
}
\`\`\`

**Treasury-Backed Model**:

EDSC uses a treasury-backed model where backing accumulates organically from user purchases:

\`\`\`
Backing Ratio:           100% (purchase value)
Initial Supply:          1 billion EDSC (minted to reserve vault)
Purchase Price:          $1.00 per EDSC
Redemption Price:        $1.00 per EDSC
Pre-Funding Required:    None (organic backing)

Example:
User purchases 1000 EDSC:
‚Üí User sends: $1000 in BTC/ETH/SOL/USDC to reserve
‚Üí Reserve releases: 1000 EDSC to user
‚Üí Reserve now holds: $1000 backing (100% ratio)
‚Üí No liquidations (direct purchase/redemption model)
\`\`\`

**Key Operations**:

1. **Token Lifecycle**:
\`\`\`rust
// Create new synthetic token type
pub fn create_synthetic(
    origin: OriginFor<T>,
    symbol: Vec<u8>,
    name: Vec<u8>,
    decimals: u8,
    target_peg: u128,         // Target price in USD (6 decimals)
    backing_ratio: u16,       // Basis points: 10000 = 100%
) -> DispatchResult;

// Deactivate synthetic token (no new minting)
pub fn deactivate_synthetic(
    origin: OriginFor<T>,
    synthetic_id: u32,
) -> DispatchResult;
\`\`\`

2. **Purchase & Redemption**:
\`\`\`rust
// Purchase synthetic tokens from reserve (e.g., EDSC)
pub fn purchase_synthetic(
    origin: OriginFor<T>,
    synthetic_id: u32,
    payment_token: AssetId,      // BTC, ETH, SOL, USDC, etc.
    payment_amount: BalanceOf<T>,
    min_synthetic_amount: u128,
) -> DispatchResult;

// Redeem synthetic tokens back to reserve for crypto
pub fn redeem_synthetic(
    origin: OriginFor<T>,
    synthetic_id: u32,
    synthetic_amount: u128,
    preferred_payment: AssetId,   // Preferred crypto to receive
    min_payment_amount: BalanceOf<T>,
) -> DispatchResult;
\`\`\`

3. **Reserve Management**:
\`\`\`rust
// Check reserve backing value
pub fn get_reserve_value(
    synthetic_id: u32,
) -> Result<u128, DispatchError>;

// Get current backing ratio
pub fn get_backing_ratio(
    synthetic_id: u32,
) -> Result<u16, DispatchError>;

// Get reserve composition (multi-asset breakdown)
pub fn get_reserve_composition(
    synthetic_id: u32,
) -> Result<Vec<(AssetId, BalanceOf<T>)>, DispatchError>;
\`\`\`

**Storage Items** (6 total):
- \`SyntheticTokens\`: Metadata for each synthetic token type
- \`ReserveBalances\`: Multi-asset reserves backing each synthetic
- \`NextSyntheticId\`: Auto-incrementing ID for new synthetics
- \`CirculatingSupply\`: Amount released from vault per synthetic
- \`ReserveVault\`: Address holding initial token supply
- \`PurchaseHistory\`: Record of purchase/redemption events

**Runtime Configuration**:
\`\`\`rust
parameter_types! {
    pub const MaxSyntheticTokens: u32 = 100;
    pub const MinPurchaseAmount: u128 = 1_000_000_000_000;  // Minimum purchase
    pub const TargetBackingRatio: u16 = 10000;  // 100% = 10000 basis points
    pub const PurchaseFeePercent: u16 = 10;  // 0.1% purchase fee
    pub const ReserveBackedTokenPalletId: PalletId = PalletId(*b"py/rbtok");
}
\`\`\`

**Price Oracle Integration**:

The pallet relies on price oracles to determine purchase/redemption rates:

\`\`\`rust
// Oracle provides real-time pricing
pub trait PriceOracle {
    fn get_price(asset_id: AssetId) -> Option<u128>;  // Returns price in USD (6 decimals)
}

// Backing ratio check (treasury-backed model)
fn check_backing_ratio(position: &ReservePosition) -> Permill {
    // Calculate total reserve value
    let reserve_value_usd: u128 = position.reserve_holdings
        .iter()
        .map(|(asset_id, balance)| {
            let price = oracle::get_price(*asset_id).unwrap_or(0);
            balance * price
        })
        .sum();

    let circulating_value_usd = position.circulating_supply; // 1:1 USD peg

    // Backing ratio = (reserve value / circulating value) * 100%
    Permill::from_rational(reserve_value_usd, circulating_value_usd)
}
\`\`\`

### 4.7.3. FlareSwap DEX - Core Infrastructure

**Purpose**: Decentralized exchange for √âTR, EDSC, and synthetic assets using automated market maker (AMM) model

**Architecture**: Uniswap V2-inspired constant product formula (x √ó y = k)

**Components**:

1. **FlareSwap Factory** (\`FlareSwapFactory.sol\`)
   - Creates new trading pairs
   - Tracks all pair contracts
   - Manages protocol fees

2. **FlareSwap Pair** (\`FlareSwapPair.sol\`)
   - Implements liquidity pool for token pair
   - Handles swaps using constant product formula
   - Distributes LP fees to liquidity providers

3. **FlareSwap ERC20** (\`FlareSwapERC20.sol\`)
   - LP token implementation
   - Represents liquidity provider shares
   - Standard ERC20 with permit functionality

**Constant Product Formula**:
\`\`\`solidity
// For any swap, the product of reserves must remain constant
x * y = k

// Where:
// x = reserve of token A
// y = reserve of token B
// k = constant (invariant)

// Example swap:
// Initial state: 100 ETR √ó 1000 EDSC = 100,000
// User swaps 10 ETR ‚Üí receives 90.9 EDSC
// Final state: 110 ETR √ó 909.1 EDSC ‚âà 100,000 (minus 0.3% fee)
\`\`\`

**Key Operations**:

1. **Liquidity Provision**:
\`\`\`solidity
// Add liquidity to pool (mints LP tokens)
function addLiquidity(
    address tokenA,
    address tokenB,
    uint amountADesired,
    uint amountBDesired,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline
) external returns (uint amountA, uint amountB, uint liquidity);

// Remove liquidity (burns LP tokens)
function removeLiquidity(
    address tokenA,
    address tokenB,
    uint liquidity,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline
) external returns (uint amountA, uint amountB);
\`\`\`

2. **Token Swapping**:
\`\`\`solidity
// Swap exact input amount for minimum output
function swapExactTokensForTokens(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline
) external returns (uint[] memory amounts);

// Swap for exact output using maximum input
function swapTokensForExactTokens(
    uint amountOut,
    uint amountInMax,
    address[] calldata path,
    address to,
    uint deadline
) external returns (uint[] memory amounts);
\`\`\`

**Fee Structure**:
- **Swap Fee**: 0.3% of each trade
  - 0.25% ‚Üí Liquidity providers (via LP token value appreciation)
  - 0.05% ‚Üí Protocol treasury (for development/operations)

**Price Impact**:
\`\`\`
Price Impact = (amountIn / reserveIn) √ó 100%

Examples:
- Swap 1 √âTR in 1000 √âTR pool ‚Üí 0.1% impact (negligible)
- Swap 50 √âTR in 1000 √âTR pool ‚Üí 5% impact (moderate)
- Swap 100 √âTR in 1000 √âTR pool ‚Üí 10% impact (high slippage)
\`\`\`

### 4.7.4. FlareSwap DEX - Periphery Contracts

**Purpose**: User-facing contracts that simplify interaction with core DEX

**Components**:

1. **FlareSwap Router** (\`FlareSwapRouter.sol\`)
   - Simplifies multi-hop swaps
   - Handles slippage protection
   - Manages deadline enforcement
   - Wraps/unwraps native √âTR

2. **FlareSwap Library** (\`FlareSwapLibrary.sol\`)
   - Price calculation utilities
   - Quote functions for UI/bots
   - Optimal path finding for multi-hop trades

3. **WETH Wrapper** (\`WETH.sol\`)
   - Wraps native √âTR into ERC20-compatible WETR
   - Required for √âTR trading on DEX
   - 1:1 peg with native √âTR

**Router Functions**:

1. **Multi-Hop Trading**:
\`\`\`solidity
// Optimal routing through multiple pairs
// Example: √âTR ‚Üí EDSC ‚Üí USDT (saves fees vs direct pool)
function swapExactTokensForTokens(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,  // [√âTR, EDSC, USDT]
    address to,
    uint deadline
) external returns (uint[] memory amounts);
\`\`\`

2. **Price Quotes**:
\`\`\`solidity
// Get quote for exact input
function getAmountsOut(
    uint amountIn,
    address[] memory path
) public view returns (uint[] memory amounts);

// Get quote for exact output (reverse calculation)
function getAmountsIn(
    uint amountOut,
    address[] memory path
) public view returns (uint[] memory amounts);
\`\`\`

3. **Native √âTR Support**:
\`\`\`solidity
// Swap √âTR for tokens (auto-wraps to WETR)
function swapExactETRForTokens(
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline
) external payable returns (uint[] memory amounts);

// Swap tokens for √âTR (auto-unwraps WETR)
function swapExactTokensForETR(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline
) external returns (uint[] memory amounts);
\`\`\`

**Library Utilities**:
\`\`\`solidity
library FlareSwapLibrary {
    // Calculate output amount given input
    function getAmountOut(
        uint amountIn,
        uint reserveIn,
        uint reserveOut
    ) internal pure returns (uint amountOut);

    // Calculate required input for desired output
    function getAmountIn(
        uint amountOut,
        uint reserveIn,
        uint reserveOut
    ) internal pure returns (uint amountIn);

    // Sort tokens (deterministic pair ordering)
    function sortTokens(
        address tokenA,
        address tokenB
    ) internal pure returns (address token0, address token1);
}
\`\`\`

### Implementation Status

**‚úÖ Completed Components**:
1. pallet-multiasset-reserve (~670 lines)
   - All 8 storage items
   - All 8 extrinsics
   - Runtime integration complete

2. pallet-reserve-backed-token (~850 lines)
   - All 6 storage items
   - All 6 extrinsics
   - Collateralization logic implemented
   - Runtime integration complete

3. FlareSwap DEX Core (~881 lines total)
   - Factory contract (interface + implementation)
   - Pair contract (AMM logic)
   - ERC20 LP token contract

4. FlareSwap DEX Periphery (completed in parallel terminal)
   - Router contract with multi-hop support
   - Library with price calculation utilities
   - WETH wrapper for native √âTR

**Runtime Integration**:

All components integrated into FlareChain runtime at \`05-multichain/flare-chain/runtime/src/lib.rs\`:

\`\`\`rust
// Reserve infrastructure
MultiassetReserve: pallet_multiasset_reserve,
ReserveBackedToken: pallet_reserve_backed_token,

// DEX deployed as smart contracts on √ãtwasmVM
// (not runtime pallets, but WASM contracts)
\`\`\`

**Code Metrics**:
- Total new code: ~2,400+ lines
- Test coverage: Integration tests pending
- Documentation: Technical specs complete
- Audit status: Pre-audit (requires security review)

### Economic Impact

**Reserve Diversification**:
- EDSC backed by multi-asset reserve (not just √âTR)
- Reduced correlation risk
- Automated rebalancing maintains target allocations

**Synthetic Assets**:
- Treasury-backed model with organic backing accumulation
- Direct purchase/redemption maintains peg stability
- Enables creation of diverse synthetic assets (stocks, commodities, indices)

**DEX Liquidity**:
- Native √âTR/EDSC trading without external bridges
- LP incentives encourage liquidity provision
- 0.3% fee generates sustainable yield for LPs

**Capital Efficiency**:
- Reserve holds multi-asset portfolio for backing
- DEX enables efficient price discovery
- Arbitrage bots maintain peg stability through reserve buy/sell operations

### Security Considerations

**Reserve Security**:
- Multi-asset reduces single-asset risk
- Rebalancing limits handled by governance
- Oracle manipulation resistance via multiple price sources

**Reserve Stability**:
- 100% backing from organic purchases provides safety
- No liquidations needed (direct purchase/redemption model)
- Automated rebalancing maintains reserve composition

**DEX Security**:
- Constant product formula prevents price manipulation
- Reentrancy protection on all state-changing functions
- Slippage limits protect against front-running
- Deadline enforcement prevents stale transactions

---

## 5. CROSS-CHAIN SECURITY & VALIDITY NODES

### The Bridge Problem

**Traditional Bridges**:
- Trusted multi-sig custodians (honeypot for hackers)
- Off-chain verification (opaque)
- Single point of failure
- Billions lost to bridge hacks (2021-2024)

### √ãtrid Solution: Native Cross-Chain Verification

**No external bridges. No trusted custodians.**

### Validity Nodes (VALIDITY Nodes)

**Role**: Verify cross-chain proofs and PBC state roots, participate in consensus on Partition Burst Chains

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC

**Node Statuses**:
- **Registered**: Node has staked 64+ √âTR and registered identity
- **Pending**: Awaiting selection for active validator set
- **Sequenced**: Active validator participating in consensus
- **Chilled**: Temporarily inactive due to performance issues
- **De-Sequenced**: Removed from active set (can re-enter after resolution)
- **Re-Sequenced**: Returned to active validator set after fixing issues

**Responsibilities**:
1. Monitor all PBC state submissions to FlareChain
2. Verify merkle proofs against submitted roots
3. Attest to validity or flag discrepancies
4. Participate in dispute resolution
5. Produce blocks on assigned PBCs
6. Maintain cross-chain state synchronization

**Incentives**:
- Earn rewards for correct attestations
- Earn block production rewards
- Slashed for false attestations
- Higher reputation = more weight

**Architecture**:
\`\`\`rust
struct ValidityNode {
    did: DecentralizedId,
    stake: Balance,
    reputation: ReputationScore,
    monitored_pbcs: Vec<PbcId>,
}

fn verify_pbc_state_root(
    pbc_id: PbcId,
    claimed_root: H256,
    block_number: BlockNumber
) -> AttestationResult {
    // Fetch actual PBC state
    let pbc_state = fetch_pbc_state(pbc_id, block_number)?;

    // Compute merkle root locally
    let computed_root = compute_state_root(&pbc_state);

    // Compare
    if computed_root == claimed_root {
        AttestationResult::Valid
    } else {
        AttestationResult::Invalid {
            expected: computed_root,
            actual: claimed_root,
        }
    }
}
\`\`\`

### Multi-Sig Custodians (Where Unavoidable)

For external chain bridges (BTC, ETH), some trusted elements unavoidable.

**Mitigation Strategy**:
\`\`\`
M-of-N Multi-Sig:
- M = 7 (threshold)
- N = 10 (total custodians)
- Geographic distribution: 5 continents
- Entity distribution: Independent operators
- Key rotation: Every 6 months
- Slashing: Loss of stake for misbehavior
\`\`\`

**Example: BTC-PBC Custodian Set**:
\`\`\`rust
struct MultisigCustodian {
    pubkey: BitcoinPublicKey,
    operator: AccountId,
    stake: Balance,
    jurisdiction: String,
    last_rotation: Timestamp,
}

fn verify_btc_transaction(
    tx: BitcoinTransaction,
    required_sigs: u8
) -> Result<(), Error> {
    let sigs = extract_signatures(&tx);
    ensure!(sigs.len() >= required_sigs, Error::InsufficientSignatures);

    // Verify each signature against custodian set
    for sig in sigs {
        let custodian = find_custodian(sig.pubkey)?;
        ensure!(verify_signature(sig), Error::InvalidSignature);
    }

    Ok(())
}
\`\`\`

### Security Guarantees

**Byzantine Fault Tolerance**:
- Tolerate up to 1/3 malicious validators
- Require 2/3+ agreement for finalization
- Slashing for provably malicious behavior

**Economic Security**:
\`\`\`
Attack Cost = Stake √ó SlashingRatio √ó (1 + ReputationPenalty)

Example:
- Validator stake: 1M √âTR
- Slashing ratio: 100% (full slash)
- Reputation penalty: 50% (future earnings lost)
‚Üí Attack cost: 1.5M √âTR
\`\`\`

---

## 6. ETWASMVM & SMART CONTRACT RUNTIME

### EtwasmVM Overview

**WebAssembly-based virtual machine** optimized for:
- Deterministic execution
- Post-quantum security
- VMw metering
- Reentrancy protection

### Why WASM?

**Advantages over EVM**:
- Near-native performance (~90% of native)
- Multiple source languages (Rust, C, AssemblyScript)
- Industry-standard tooling
- Smaller bytecode size
- Better optimization opportunities

**Security Enhancements**:
- Bounded execution (no infinite loops)
- Memory safety (no buffer overflows)
- Sandboxed execution (no syscalls)
- Resource metering (VMw tracking)

### Contract Structure

**Example Contract** (Pseudo-Rust/ink!):
\`\`\`rust
#[etrid::contract]
mod token {
    use etrid_contract::*;

    #[state]
    pub struct Token {
        total_supply: Balance,
        balances: Mapping<AccountId, Balance>,
        allowances: Mapping<(AccountId, AccountId), Balance>,
    }

    #[constructor]
    pub fn new(initial_supply: Balance) -> Self {
        let caller = Self::env().caller();
        let mut balances = Mapping::default();
        balances.insert(caller, &initial_supply);

        Self {
            total_supply: initial_supply,
            balances,
            allowances: Mapping::default(),
        }
    }

    #[message]
    pub fn transfer(&mut self, to: AccountId, amount: Balance) -> Result<()> {
        let from = self.env().caller();
        self.transfer_impl(from, to, amount)
    }

    fn transfer_impl(
        &mut self,
        from: AccountId,
        to: AccountId,
        amount: Balance
    ) -> Result<()> {
        let from_balance = self.balance_of(from);
        ensure!(from_balance >= amount, Error::InsufficientBalance);

        self.balances.insert(from, &(from_balance - amount));
        let to_balance = self.balance_of(to);
        self.balances.insert(to, &(to_balance + amount));

        self.env().emit_event(Transfer { from, to, amount });
        Ok(())
    }
}
\`\`\`

### Reentrancy Protection

**Built-in runtime check**:
\`\`\`rust
thread_local! {
    static CALL_STACK: RefCell<Vec<ContractId>> = RefCell::new(Vec::new());
}

fn execute_contract(contract: ContractId, data: Vec<u8>) -> Result<Vec<u8>> {
    // Check for reentrancy
    CALL_STACK.with(|stack| {
        if stack.borrow().contains(&contract) {
            return Err(Error::ReentrancyDetected);
        }
        stack.borrow_mut().push(contract);
    });

    // Execute
    let result = run_wasm(contract, data);

    // Pop call stack
    CALL_STACK.with(|stack| stack.borrow_mut().pop());

    result
}
\`\`\`

### VMw Metering Integration

**Injected into WASM bytecode**:
\`\`\`wasm
;; Original: (i32.add (local.get 0) (local.get 1))
;; Metered:
(call $charge_vmw (i32.const 1))  ;; Charge 1 VMw for add
(i32.add (local.get 0) (local.get 1))
\`\`\`

**Runtime metering**:
\`\`\`rust
static mut VMW_REMAINING: u64 = 0;

fn charge_vmw(amount: u64) {
    unsafe {
        if VMW_REMAINING < amount {
            panic!("Out of VMw");
        }
        VMW_REMAINING -= amount;
    }
}
\`\`\`

---

## 7. NETWORK & P2P LAYER (DETR)

### DETR P2P Protocol

**DETR** = Distributed √ãtrid Transaction Relay

**Based on**:
- libp2p for transport
- S/Kademlia for DHT
- ECIES for encryption
- Gossipsub for message propagation

### Network Topology

**Three Layers**:

1. **Validator Network** (FlareChain)
   - Full mesh between validators
   - Low latency requirements (<100ms)
   - Authenticated connections (Ed25519)

2. **Collator Networks** (PBCs)
   - Star topology around FlareChain validators
   - Periodic state synchronization
   - Cross-PBC messaging via FlareChain

3. **Public Network** (Light Clients)
   - Connect to any validator/collator
   - DHT for peer discovery
   - Receive block headers only

### Message Types

\`\`\`rust
enum NetworkMessage {
    // Block propagation
    NewBlock(Block),
    BlockRequest(BlockNumber),
    BlockResponse(Block),

    // Transaction pool
    NewTransaction(Transaction),
    TransactionRequest(TxHash),

    // Consensus
    AsfSignature(AsfSignature),
    ValidatorHeartbeat(ValidatorId),

    // Cross-chain
    CrossChainMessage(CrossChainMessage),
    StateRootSubmission(PbcStateRoot),
}
\`\`\`

### Lightning-Bloc (Layer 2)

**Payment channels** for instant, low-fee transactions:

**Channel Lifecycle**:
1. **Open**: Lock funds in on-chain contract
2. **Transact**: Off-chain signed updates
3. **Close**: Submit final state on-chain
4. **Dispute**: Time-locked challenge period

**Multi-hop routing**:
\`\`\`
Alice ‚Üí Bob ‚Üí Carol ‚Üí Dave
  2 √âTR   2 √âTR   2 √âTR
\`\`\`

**Watchtowers**: Monitor channels for fraud attempts

---

## 8. CRYPTOGRAPHIC PRIMITIVES & POST-QUANTUM SECURITY

### Current Cryptography

**Signing**: Ed25519 (Curve25519)
- Public key: 32 bytes
- Signature: 64 bytes
- Fast verification (~60k sigs/sec)

**Hashing**: BLAKE3
- Output: 32 bytes
- Speed: 10 GB/s per core
- Merkle tree optimized

**Encryption**: ChaCha20-Poly1305
- Symmetric AEAD cipher
- Nonce: 12 bytes
- Tag: 16 bytes

### Post-Quantum Migration Path

**Hybrid Scheme** (Current + PQ):
\`\`\`
Signature = Ed25519_Sign(msg) || Dilithium_Sign(msg)
Verification = Ed25519_Verify() AND Dilithium_Verify()
\`\`\`

**PQ Algorithms** (NIST selected):
- **Signing**: CRYSTALS-Dilithium (lattice-based)
- **KEM**: CRYSTALS-Kyber (key encapsulation)
- **Alternative**: SPHINCS+ (hash-based signatures)

**Migration Timeline**:
- 2025: Hybrid support added (optional)
- 2026: Hybrid enabled by default
- 2027: PQ-only mode available
- 2028+: Transition to PQ-only (if quantum threat emerges)

---

## 9. IMPLEMENTATION GAP ANALYSIS

### Overview

This section documents components specified in the Ivory Papers that require additional implementation work. While the E¬≥20 architecture is complete at the alpha stage, several advanced features require further development before mainnet launch.

### 9.1. VMw Metering Runtime ‚ö†Ô∏è PARTIAL IMPLEMENTATION

**Status**: Specification complete, runtime implementation incomplete

**What's Described** (Section 3):
- Energy-based computation metering (1 VMw = 1 Watt-second)
- Instruction-level weight assignments
- Dynamic VMw ‚Üí √âTR price oracle
- Pre-execution metering with runtime enforcement

**What's Missing**:
1. **VMw Injector**: WASM bytecode instrumentation to inject metering calls
2. **Instruction Weight Database**: Comprehensive mapping of WASM opcodes to VMw costs
3. **Dynamic Price Oracle**: Real-time VMw ‚Üí √âTR conversion based on network conditions
4. **Execution Metering**: Runtime enforcement of VMw limits during transaction execution

**Implementation Priority**: HIGH (required for mainnet)

**Recommended Approach**:
\`\`\`rust
// Required components:

// 1. VMw Weight Database
pub struct InstructionWeights {
    add: u64,           // 1 VMw
    mul: u64,           // 2 VMw
    div: u64,           // 4 VMw
    crypto_hash: u64,   // 100 VMw
    storage_read: u64,  // 1000 VMw
    storage_write: u64, // 2000 VMw
    // ... complete mapping
}

// 2. WASM Instrumentation
pub fn inject_metering(wasm_module: &[u8]) -> Result<Vec<u8>, Error> {
    // Parse WASM module
    // Inject VMw charging before each instruction
    // Return instrumented bytecode
}

// 3. Runtime Metering
pub struct VMwMeter {
    limit: u64,
    used: u64,
}

impl VMwMeter {
    pub fn charge(&mut self, amount: u64) -> Result<(), OutOfVMw> {
        if self.used + amount > self.limit {
            return Err(OutOfVMw);
        }
        self.used += amount;
        Ok(())
    }
}
\`\`\`

**Estimated Work**: 2-3 weeks for experienced WASM developer

**Location**: \`08-etwasm-vm/vmw-metering/\` (needs creation)

### 9.2. √ãtwasmVM Contract Runtime ‚ö†Ô∏è PARTIAL IMPLEMENTATION

**Status**: Architecture defined, runtime incomplete

**What's Described** (Section 6):
- WebAssembly-based smart contract execution
- VMw metering integration
- Reentrancy protection
- Contract state management
- Multi-language support (Rust, C, AssemblyScript)

**What's Missing**:
1. **Contract Deployment**: Upload and instantiate WASM contracts
2. **Contract Calls**: Inter-contract communication
3. **State Persistence**: Storage rent and garbage collection
4. **Gas Refunds**: Unused VMw refund mechanism
5. **Contract Upgradeability**: Proxy pattern support

**Implementation Priority**: HIGH (required for mainnet)

**Recommended Approach**:

Use existing Substrate pallets as foundation:
- \`pallet-contracts\`: Substrate's WASM contract pallet
- Customize for VMw metering (replace gas with VMw)
- Add reentrancy guards
- Implement storage rent model

**Estimated Work**: 4-6 weeks

**Location**: \`08-etwasm-vm/pallet/src/lib.rs\` (exists but needs completion)

### 9.3. Lightning-Bloc (Layer 2) ‚ö†Ô∏è NOT IMPLEMENTED

**Status**: Conceptual design only, no implementation

**What's Described** (Section 7):
- Payment channel network for instant, low-fee transactions
- Multi-hop routing
- Watchtower services for fraud prevention
- Time-locked dispute resolution

**What's Missing**:
1. **Channel Opening**: On-chain contract for locking funds
2. **Off-Chain Updates**: Signed state updates between parties
3. **Channel Closing**: Submit final state or trigger dispute
4. **Routing Protocol**: Path-finding for multi-hop payments
5. **Watchtowers**: Monitor channels for fraud attempts

**Implementation Priority**: MEDIUM (post-mainnet enhancement)

**Recommended Approach**:

Adapt existing Lightning Network concepts:
\`\`\`rust
pub struct PaymentChannel {
    pub participants: (AccountId, AccountId),
    pub capacity: Balance,
    pub balances: (Balance, Balance),
    pub nonce: u64,
    pub timeout: BlockNumber,
    pub status: ChannelStatus,
}

pub enum ChannelStatus {
    Open,
    Disputed,
    Closed,
}

// Extrinsics
pub fn open_channel(counterparty: AccountId, amount: Balance);
pub fn close_channel(channel_id: H256, final_state: ChannelState);
pub fn dispute_close(channel_id: H256, newer_state: ChannelState);
\`\`\`

**Estimated Work**: 8-12 weeks for full implementation

**Location**: \`07-transactions/lightning-bloc/\` (exists as placeholder)

### 9.4. Post-Quantum Cryptography ‚ö†Ô∏è NOT IMPLEMENTED

**Status**: Migration path defined, no implementation

**What's Described** (Section 8):
- Hybrid signature scheme (Ed25519 + Dilithium)
- CRYSTALS-Kyber for key encapsulation
- SPHINCS+ as alternative hash-based signature
- Phased migration timeline (2025-2028)

**What's Missing**:
1. **Hybrid Signing**: Dual signature verification
2. **Key Derivation**: Generate both classical and PQ keys
3. **Migration Tools**: Convert existing accounts to hybrid mode
4. **Performance Testing**: Benchmark PQ signature verification
5. **Storage Overhead**: Handle larger signature sizes (Ed25519: 64 bytes ‚Üí Dilithium: 2420 bytes)

**Implementation Priority**: LOW (future-proofing, not immediate threat)

**Recommended Approach**:

Use NIST-selected PQ algorithms:
\`\`\`rust
pub enum SignatureScheme {
    Ed25519,                          // Current (32 byte pubkey, 64 byte sig)
    Hybrid(Ed25519, Dilithium2),      // Transition (verify both)
    Dilithium2,                       // Future PQ-only (1312 byte pubkey, 2420 byte sig)
}

pub fn verify_hybrid(
    message: &[u8],
    ed25519_sig: &[u8; 64],
    dilithium_sig: &[u8; 2420],
    pubkey: &HybridPublicKey,
) -> bool {
    verify_ed25519(message, ed25519_sig, &pubkey.ed25519)
        && verify_dilithium(message, dilithium_sig, &pubkey.dilithium)
}
\`\`\`

**Estimated Work**: 6-8 weeks

**Location**: \`03-security/post-quantum/\` (needs creation)

**Crate Dependencies**:
- \`pqcrypto-dilithium\`
- \`pqcrypto-kyber\`
- \`pqcrypto-sphincsplus\`

### 9.5. Cross-Chain Oracle Network ‚ö†Ô∏è PARTIAL IMPLEMENTATION

**Status**: Architecture defined, production oracles not deployed

**What's Needed**:

The reserve-backed token system requires reliable price feeds for:
- √âTR/USD pricing
- Synthetic asset pricing
- Reserve asset valuations

**Current State**:
- Oracle pallet exists (\`pallet-reserve-oracle\`)
- Price submission mechanism implemented
- No production oracle operators

**Implementation Priority**: HIGH (required for EDSC mainnet)

**Recommended Approach**:

Deploy oracle node network:
\`\`\`rust
// Oracle data providers
pub struct OracleProvider {
    pub account: AccountId,
    pub stake: Balance,              // Minimum 1000 √âTR
    pub reputation: ReputationScore,
    pub price_feeds: Vec<AssetId>,
}

// Price aggregation
pub fn submit_price(
    origin: OriginFor<T>,
    asset_id: AssetId,
    price: u128,      // USD price (6 decimals)
    timestamp: u64,
) -> DispatchResult;

pub fn aggregate_prices(asset_id: AssetId) -> Option<u128> {
    // Median of all submitted prices (outlier rejection)
    let mut prices = PriceSubmissions::<T>::get(asset_id);
    prices.sort();
    prices.get(prices.len() / 2).copied()
}
\`\`\`

**Oracle Incentives**:
- Accurate submissions ‚Üí Earn fees (0.1% of trades using oracle price)
- Outlier submissions ‚Üí Reputation penalty
- Provably false data ‚Üí Slashing

**Estimated Work**: 4-6 weeks to deploy production oracle network

**Location**: \`src/pallets/pallet-reserve-oracle/\` (exists, needs production deployment)

### 9.6. FlareSwap DEX Deployment ‚ö†Ô∏è CONTRACTS READY, NOT DEPLOYED

**Status**: Smart contracts complete, deployment pending

**What's Complete**:
- FlareSwap Factory, Pair, ERC20 (Core)
- FlareSwap Router, Library, WETH (Periphery)
- Solidity contracts tested locally

**What's Missing**:
1. **Contract Compilation**: Compile to WASM for √ãtwasmVM
2. **Deployment Scripts**: Automated deployment to FlareChain
3. **Frontend Integration**: Web UI for swapping
4. **Liquidity Bootstrapping**: Initial √âTR/EDSC pools
5. **Subgraph/Indexer**: Track trades, volume, TVL

**Implementation Priority**: HIGH (DeFi ecosystem enabler)

**Deployment Steps**:
\`\`\`bash
# 1. Compile contracts to WASM
solang compile --target substrate FlareSwapFactory.sol
solang compile --target substrate FlareSwapPair.sol
solang compile --target substrate FlareSwapRouter.sol

# 2. Deploy via extrinsic
polkadot-js-api tx.contracts.instantiateWithCode \
  --gas 1000000 \
  --value 0 \
  --code FlareSwapFactory.wasm \
  --data 0x... # constructor args

# 3. Verify deployment
polkadot-js-api query.contracts.contractInfoOf <contract-address>
\`\`\`

**Estimated Work**: 2-3 weeks for full deployment + UI

**Location**:
- Contracts: \`05-multichain/flareswap/\` (complete)
- Deployment: Needs scripts in \`scripts/deploy-dex.sh\`

### 9.7. Comprehensive Testing ‚ö†Ô∏è IN PROGRESS

**Status**: Unit tests exist, integration/stress tests incomplete

**Test Coverage**:
- Unit tests: ~60% coverage
- Integration tests: ~30% coverage
- Stress tests: Not implemented
- Security audits: Not completed

**What's Needed**:

1. **Runtime Integration Tests**:
   - Multi-pallet interaction tests
   - Cross-chain message passing
   - Reserve rebalancing scenarios
   - Reserve depletion stress tests

2. **Performance Benchmarks**:
   - Transaction throughput (target: 1000+ TPS)
   - Block finalization time (target: <60s for 95% finality)
   - VMw metering overhead
   - Cross-chain latency

3. **Security Audits**:
   - Third-party audit of all runtime code
   - Fuzzing tests for edge cases
   - Formal verification of critical components

**Implementation Priority**: CRITICAL (before mainnet)

**Estimated Work**: 6-8 weeks for comprehensive test suite + audits

### Summary: Implementation Roadmap

| Component | Priority | Status | Estimated Work | Blocker for Mainnet? |
|-----------|----------|--------|----------------|---------------------|
| VMw Metering Runtime | HIGH | 40% | 2-3 weeks | ‚úÖ YES |
| √ãtwasmVM Completion | HIGH | 60% | 4-6 weeks | ‚úÖ YES |
| Oracle Network | HIGH | 70% | 4-6 weeks | ‚úÖ YES |
| FlareSwap Deployment | HIGH | 90% | 2-3 weeks | ‚ö†Ô∏è PARTIAL |
| Lightning-Bloc | MEDIUM | 10% | 8-12 weeks | ‚ùå NO (post-mainnet) |
| Post-Quantum Crypto | LOW | 5% | 6-8 weeks | ‚ùå NO (future upgrade) |
| Comprehensive Testing | CRITICAL | 45% | 6-8 weeks | ‚úÖ YES |

**Total Pre-Mainnet Work**: 18-26 weeks (~4-6 months) for critical components

**Mainnet Readiness Checklist**:
- [x] Core E¬≥20 components (13/13 complete)
- [ ] VMw metering runtime
- [ ] √ãtwasmVM contract execution
- [ ] Oracle network deployment
- [ ] FlareSwap DEX deployment
- [ ] Comprehensive test suite
- [ ] Security audit completion
- [x] Reserve infrastructure (pallet-multiasset-reserve, pallet-reserve-backed-token)

**Current Status**: **ALPHA COMPLETE** (all architecture defined, ~70% implementation complete)

**Next Milestone**: **BETA LAUNCH** (all mainnet blockers resolved, audited)

---

## CONCLUSION

The E¬≥20 protocol provides a complete, modular foundation for sovereign blockchain networks:

- **ASF**: Adaptive, spectrum-based finality
- **VMw**: Energy-based computation metering
- **Multichain**: Native coordination without bridges
- **EtwasmVM**: Secure, efficient smart contracts
- **DETR**: Robust P2P networking
- **Post-Quantum**: Future-proof cryptography

**Status**: ‚úÖ All 13 components at 100% Alpha Complete

---

**End of Volume II**

**Next**: Volume III - Governance & Fiscal Mechanics

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**
`
    },
    'vol3': {
        title: 'Volume III: Governance & Fiscal Mechanics',
        filename: 'ivory-paper-vol3-governance.md',
        content: `# √ãTRID IVORY PAPERS
## Volume III: Governance & Fiscal Mechanics

**Document ID**: ETRID-IP-VOL3-2025
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Publication Date**: October 24, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Non-Commercial)

---

## VOLUME III CONTENTS

1. Consensus Day - The Constitutional Event
2. Governance Roles & Responsibilities
3. Fiscal Cycle & Treasury Management
4. Token Economics (√âTR, EDSC, VMw)
5. Proposal System & Voting Mechanisms
6. Reward Distribution & Slashing
7. Economic Sustainability Model
8. Emergency Procedures & Crisis Response

---

## 1. CONSENSUS DAY - THE CONSTITUTIONAL EVENT

### Overview

**Consensus Day** occurs annually on **December 1st** at **12:00 AM PST**. It is the network's constitutional moment where all major governance decisions are made collectively.

**Frequency**: Once per year (365 days)
**Participation**: All √âTR stakers (VALIDITY Nodes, Common Stake Peers, Decentralized Directors)

**Pre-Consensus Period**: January 1 ‚Äì October 31
- Registration for eligibility
- Proposal submission
- Campaigning for proposals and director candidates
- Preliminary voting and discussion

**Consensus Day Purpose**:
- Vote on proposals (protocol improvements, standards, parameter changes, developer commits)
- Adjust economic parameters (rewards, penalties, supply, salaries)
- Elect 9 Decentralized Directors for the upcoming year
- Distribute rewards to participating stakeholders

**Voting Power**: Staked √âTR √ó Coinage
- Coinage = time-weighted stake (how long tokens have been staked)
- Longer stakes = higher voting power multiplier
- Encourages long-term stakeholder commitment

### Phase 1: Registration (6 hours)

**Purpose**: Submit proposals, lock stakes, register participation

**Actions**:
- **Proposal Submission**: Anyone with ‚â• 10,000 √âTR can submit proposals
- **Stake Locking**: Participants lock √âTR to receive voting power
- **Validator Registration**: Validators signal participation (required for quorum)
- **Delegate Assignment**: Token holders can delegate votes to trusted parties

**Proposal Types**:
1. **Inflation Rate Adjustment** (hard cap: 0-5% annual)
2. **Parameter Changes** (block times, finality thresholds, fee structure)
3. **Budget Allocation** (grants, development, marketing, operations)
4. **Protocol Upgrades** (runtime changes, pallet additions)
5. **Director Elections** (elect 9 Decentralized Directors)
6. **Emergency Actions** (slash validators, pause chains, deploy hotfixes)

**Proposal Requirements**:
\`\`\`rust
struct Proposal {
    proposer: AccountId,
    title: String,              // Max 100 chars
    description: String,        // Max 2000 chars
    category: ProposalCategory,
    budget_request: Balance,    // If funding required
    implementation_plan: Hash,  // IPFS hash to detailed plan
    bond: Balance,              // 10,000 √âTR minimum
    supporting_validators: Vec<AccountId>, // Min 3 validators
}
\`\`\`

**Proposal Bond**:
- **Amount**: 10,000 √âTR (locked during voting)
- **Refund**: Full refund if proposal reaches 5% quorum
- **Slash**: 50% slashed if spam/malicious, 50% returned if simply unpopular

### Phase 2: Voting (12 hours)

**Purpose**: Community + validators vote on all proposals

**Voting Power Calculation**:
\`\`\`rust
fn calculate_voting_power(
    staked_amount: Balance,
    stake_duration: BlockNumber, // How long stake has been locked
    participation_history: u32,  // Previous Consensus Days attended
) -> VotingPower {
    let base_power = staked_amount;

    // Stake duration bonus (max +20%)
    let duration_multiplier = 1.0 + (stake_duration / BLOCKS_PER_YEAR).min(0.2);

    // Participation history bonus (max +10%)
    let history_multiplier = 1.0 + (participation_history as f64 * 0.02).min(0.1);

    let adjusted_power = base_power * duration_multiplier * history_multiplier;

    VotingPower::new(adjusted_power as u128)
}
\`\`\`

**Voting Mechanism**:
- **Vote Options**: Yes / No / Abstain
- **Vote Weight**: Proportional to voting power
- **Vote Privacy**: Votes are public (on-chain transparency)
- **Vote Changes**: Can change vote until Phase 2 ends
- **Delegation**: Votes can be delegated (revocable at any time)

**Quorum Requirements**:

Dual quorum system ensures both community and validators participate:

\`\`\`rust
struct QuorumRequirements {
    community_quorum: Percent,    // 33% of circulating √âTR must vote
    validator_quorum: Percent,    // 51% of active validators must vote
}

fn check_quorum(proposal: &Proposal) -> bool {
    let community_participation = proposal.total_votes / circulating_supply();
    let validator_participation = proposal.validator_votes.len() / active_validators();

    community_participation >= 0.33 && validator_participation >= 0.51
}
\`\`\`

**Approval Threshold**:
- **Simple Majority**: >50% for budget allocations, parameter tweaks
- **Supermajority**: >66% for protocol upgrades, emergency actions
- **Unanimous Director Approval**: All 9 Directors for constitutional changes

### Phase 3: Minting (3 hours)

**Purpose**: Execute approved budgets by minting new √âTR

**Minting Logic**:
\`\`\`rust
fn execute_approved_budgets(approved_proposals: Vec<Proposal>) -> Balance {
    let mut total_mint_amount = 0u128;

    for proposal in approved_proposals {
        if proposal.category == ProposalCategory::BudgetAllocation {
            // Verify budget doesn't exceed annual cap
            let annual_cap = circulating_supply() * approved_inflation_rate / 100;

            if total_mint_amount + proposal.budget_request <= annual_cap {
                // Mint tokens
                mint_to_treasury(proposal.budget_request);
                total_mint_amount += proposal.budget_request;

                // Emit event
                emit_event(Event::BudgetMinted {
                    proposal_id: proposal.id,
                    amount: proposal.budget_request,
                    recipient: Treasury::account_id(),
                });
            }
        }
    }

    total_mint_amount
}
\`\`\`

**Inflation Rate Control**:
- **Community Decides**: Consensus Day votes set annual inflation
- **Hard Cap**: 0-5% per year (enforced by protocol)
- **Default**: If no vote reaches consensus, previous year's rate continues
- **Emergency Override**: Directors can propose 0% inflation in crisis

**Minting Events**:
\`\`\`rust
enum MintEvent {
    BudgetMinted { proposal_id: u64, amount: Balance, recipient: AccountId },
    InflationApplied { rate: Percent, total_minted: Balance },
    TreasuryFunded { source: MintSource, amount: Balance },
}
\`\`\`

### Phase 4: Distribution (1 hour)

**Purpose**: Reward all participants who voted

**Distribution Formula**:
\`\`\`rust
fn calculate_participation_reward(
    voter: &Voter,
    total_participation_pool: Balance,
) -> Balance {
    // Pool = 1% of total minted during Phase 3
    let participation_pool = total_participation_pool;

    // Individual share based on voting power used
    let voter_share = voter.voting_power_used / total_voting_power_cast;

    // Bonus for voting on all proposals (completeness bonus)
    let completeness_multiplier = if voter.voted_on_all {
        1.2
    } else {
        1.0
    };

    let base_reward = participation_pool * voter_share;
    let final_reward = base_reward * completeness_multiplier;

    Balance::from(final_reward as u128)
}
\`\`\`

**Distribution Components**:
1. **Participation Rewards**: 1% of minted tokens divided among voters
2. **Validator Rewards**: Validators receive 0.5% bonus for participation
3. **Proposer Rewards**: Approved proposals earn 100 √âTR per proposal
4. **Director Stipends**: 9 Directors receive equal shares (total: 0.2% of mint)

**Distribution Example**:

If 100M √âTR minted during Consensus Day:
\`\`\`
Total Minted:            100,000,000 √âTR
Participation Pool (1%):   1,000,000 √âTR ‚Üí Divided among voters
Validator Bonus (0.5%):      500,000 √âTR ‚Üí Divided among validators
Director Stipends (0.2%):    200,000 √âTR ‚Üí 22,222 √âTR per Director
Proposer Rewards:            100 √âTR √ó approved proposals
Remaining:               98,300,000 √âTR ‚Üí Treasury for budgets
\`\`\`

---

## 2. GOVERNANCE ROLES & RESPONSIBILITIES

### Role Hierarchy

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Community (All √âTR Holders)      ‚îÇ
‚îÇ  - Vote on proposals                        ‚îÇ
‚îÇ  - Elect Directors                          ‚îÇ
‚îÇ  - Propose changes (‚â•10k √âTR)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Directors   ‚îÇ   ‚îÇ    Validators    ‚îÇ
‚îÇ  (9 members) ‚îÇ   ‚îÇ  (Active Set)    ‚îÇ
‚îÇ  - Oversee   ‚îÇ   ‚îÇ  - Validate      ‚îÇ
‚îÇ  - Veto      ‚îÇ   ‚îÇ  - Secure        ‚îÇ
‚îÇ  - Emergency ‚îÇ   ‚îÇ  - Vote          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### The Community (Token Holders)

**Power**:
- Vote on all proposals during Consensus Day
- Elect 9 Decentralized Directors annually
- Propose protocol changes (requires ‚â•10,000 √âTR bond)
- Delegate voting power to trusted parties

**Responsibilities**:
- Participate in annual governance
- Review proposals and technical documentation
- Report bugs, vulnerabilities, exploits
- Contribute to ecosystem growth

**Rights**:
- Receive staking rewards
- Access to all governance decisions and data
- Freedom to fork the network (GPLv3)

### Decentralized Directors (The Board)

**Composition**: 9 individuals elected annually

**Requirements**:
- **Minimum stake: 128 √âTR**
- **Must serve as OD Flare Nodes** (Operational Director Flare Nodes)
- Must maintain active participation in network operations

**Term**: 1 year (renewable via re-election)

**Term Limits**:
- **One-year terms**
- **One-year cooldown** between terms
- **Maximum 3 lifetime terms** (cannot serve more than 3 total terms)

**Election Process**:
1. Candidates announce during Pre-Consensus Period (Jan 1 - Oct 31)
2. Community votes on Consensus Day (December 1)
3. Top 9 vote-getters elected
4. Ties resolved by stake-weighted runoff
5. Voting power = Staked √âTR √ó Coinage

**Powers**:
1. **Governance Oversight**: Oversee development and consensus proposals
2. **Protocol Maintenance**: Coordinate security audits, bug bounties
3. **Representation**: Speak for √ãtrid at conferences, media, partnerships
4. **Treasury Management**: Approve budget disbursements (community-authorized)
5. **Emergency Coordination**: Coordinate response to network emergencies

**Limitations**:
- Cannot change protocol without community consensus vote
- Cannot mint tokens outside Consensus Day
- **No hierarchy** among Directors - all decisions are community-driven
- Cannot override community supermajority
- Subject to term limits (max 3 lifetime terms)

**Compensation**:
- **Community-voted salaries** (determined annually on Consensus Day)
- No predetermined amounts - stakeholders decide compensation
- Funded from Consensus Day distribution

**Accountability**:
- Regular public reports required
- Can be removed mid-term via emergency community vote
- All communications public and logged
- Bound by Foundation bylaws

### VALIDITY Nodes (Validators)

**Role**: √ãtrid Partitioned Burst Chain nodes in consensus, syncing with Flare Chain. Responsible for block production, finality attestation, and cross-chain state verification.

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC
- Identity: Must verify on-chain identity (no KYC, just persistent identity)

**Node Statuses**:
- Registered
- Pending
- Sequenced
- Chilled
- De-Sequenced
- Re-Sequenced

**Rewards**:
\`\`\`rust
fn calculate_validator_reward(
    validator: &Validator,
    epoch_duration: BlockNumber,
    total_validator_pool: Balance,
) -> Balance {
    // Base reward proportional to stake
    let stake_ratio = validator.stake / total_active_stake();
    let base_reward = total_validator_pool * stake_ratio;

    // Uptime multiplier (0.90 - 1.10)
    let uptime_multiplier = 0.9 + (validator.uptime - 0.95).max(0.0) * 2.0;

    // Finality contribution (signed blocks / expected blocks)
    let finality_multiplier = validator.blocks_signed / validator.blocks_expected;

    // Final reward
    base_reward * uptime_multiplier * finality_multiplier
}
\`\`\`

**Slashing**:
- **Downtime**: -1% stake per day offline (after 24h grace period)
- **Equivocation**: -10% stake for double-signing blocks
- **Malicious Behavior**: -50% stake + removal for provable attacks
- **Censorship**: -5% stake for ignoring valid transactions

### Common Stake Peers

**Role**: Stakeholders who participate in governance without running full node infrastructure

**Requirements**:
- **Minimum stake: 1+ √âTR**

**Privileges**:
- Voting on proposals during Consensus Day
- Campaigning for proposals
- Reporting faults and issues
- Earning rewards based on stake, coinage, and activity

**Voting Power Formula**:
\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where coinage represents how long tokens have been staked (time-weighted stake)
- Must run full nodes for FlareChain + ‚â•3 PBCs
- Must respond to verification requests within 10 blocks

**Rewards**:
- 0.1% fee on all cross-chain transactions
- Proportional to verification work performed
- Paid from cross-chain transaction fees

**Slashing**:
- -20% stake for incorrect verification
- -50% stake for colluding to pass invalid proofs

### The Foundation (Pre-Mainnet Only)

**Role**: Bootstrap the network until first Consensus Day

**Powers**:
- Set initial parameters (inflation, fees, block times)
- Deploy initial infrastructure
- Fund initial development
- Conduct security audits

**Sunset Clause**:
- Foundation dissolves after first successful Consensus Day
- All remaining funds transferred to community treasury
- No ongoing authority or control

---

## 3. FISCAL CYCLE & TREASURY MANAGEMENT

### Treasury Architecture

**Treasury Account**: On-chain multisig controlled by 9 Directors (6-of-9 threshold)

**Funding Sources**:
1. **Transaction Fees**: 50% of all fees ‚Üí Treasury (50% burned)
2. **Consensus Day Minting**: Approved budgets minted to treasury
3. **Validator Slashing**: 50% of slashed stakes ‚Üí Treasury (50% burned)
4. **Cross-Chain Fees**: 10% of bridge fees ‚Üí Treasury

**Treasury Balance Formula**:
\`\`\`rust
fn calculate_treasury_balance() -> Balance {
    let inflows = transaction_fees * 0.5
                + consensus_day_mint
                + slashing_proceeds * 0.5
                + bridge_fees * 0.1;

    let outflows = budget_disbursements
                 + validator_rewards
                 + director_stipends
                 + emergency_expenses;

    previous_balance + inflows - outflows
}
\`\`\`

### Fiscal Year Cycle

**Fiscal Year**: December 1st ‚Üí November 30th (aligned with Consensus Day)

**Budget Categories**:
1. **Development** (40% of budget): Core protocol, tools, libraries
2. **Marketing** (20% of budget): Education, outreach, partnerships
3. **Operations** (15% of budget): Infrastructure, monitoring, support
4. **Grants** (15% of budget): Community projects, research, ecosystem
5. **Emergency Reserve** (10% of budget): Held for crisis response

**Budget Approval Process**:
1. **Consensus Day**: Community votes on budget allocation per category
2. **Director Oversight**: Directors approve individual disbursements
3. **Quarterly Review**: Directors publish spending reports every 3 months
4. **Annual Audit**: Third-party audit published before next Consensus Day

### Treasury Transparency

**All treasury actions emit events**:
\`\`\`rust
enum TreasuryEvent {
    Deposit { source: DepositSource, amount: Balance },
    Disbursement { category: BudgetCategory, recipient: AccountId, amount: Balance },
    DirectorVote { director: AccountId, proposal_id: u64, vote: bool },
    QuarterlyReport { quarter: u8, total_spent: Balance, category_breakdown: Vec<(BudgetCategory, Balance)> },
}
\`\`\`

**Public Dashboard**:
- Real-time treasury balance
- All incoming/outgoing transactions
- Budget vs. actual spending per category
- Director voting records
- Historical trends (YoY comparison)

### Mint and Burn Dynamics

**Minting Events**:
1. **Consensus Day**: Annual minting for approved budgets
2. **Emergency Minting**: Directors can mint (7/9 vote) in crisis (max 1% of supply)

**Burning Events**:
1. **Transaction Fees**: 50% of all fees burned
2. **Validator Slashing**: 50% of slashed stakes burned
3. **Deflationary Votes**: Community can vote to burn treasury reserves

**Net Supply Formula**:
\`\`\`rust
fn calculate_net_supply_change(epoch: Epoch) -> i128 {
    let minted = consensus_day_mint + emergency_mint;
    let burned = transaction_fees * 0.5 + slashing_proceeds * 0.5 + voluntary_burns;

    (minted as i128) - (burned as i128)
}
\`\`\`

**Target**: Long-term supply should stabilize or decrease slowly (deflationary tendency)

---

## 4. TOKEN ECONOMICS (√âTR, EDSC, VMw)

### √âTR (√ãtrid Token)

**Purpose**: Governance, staking, gas fees

**Total Supply**: 1 Billion √âTR (initial), subject to inflation/deflation

**Initial Distribution**:
\`\`\`
Genesis Block:           1,000,000,000 √âTR

Allocation:
- Public Sale (40%):       400,000,000 √âTR
- Foundation (25%):        250,000,000 √âTR (4-year vesting)
- Team (15%):              150,000,000 √âTR (3-year vesting)
- Validators (10%):        100,000,000 √âTR (incentive pool)
- Ecosystem Grants (10%):  100,000,000 √âTR (unlocked)
\`\`\`

**Inflation/Deflation**:
- **Inflation**: Voted annually (0-5% cap), minted on Consensus Day
- **Deflation**: Transaction fees + slashing continuously burned
- **Net Effect**: Tends toward slight deflation long-term

**Use Cases**:
1. **Staking**: Lock √âTR to become validator or voter
2. **Gas Fees**: Pay for transactions (measured in VMw, priced in √âTR)
3. **Governance**: Vote on proposals during Consensus Day
4. **Reserve Asset**: Held in multi-asset treasury backing EDSC stablecoin

### EDSC (√ãtrid Dollar Stablecoin)

**Purpose**: Stable unit of account for payments, contracts

**Peg**: $1.00 USD (maintained by direct reserve buy/sell + arbitrage)

**Backing Model**: Treasury-backed with 100% backing from organic purchases (no pre-funding required)

**Reserve Infrastructure**:

EDSC is backed by a diversified multi-asset reserve managed through two specialized pallets:

1. **pallet-multiasset-reserve**: Manages reserve composition and automated rebalancing
2. **pallet-reserve-backed-token**: Handles EDSC purchase/redemption and reserve management

**Reserve Composition**:
\`\`\`
Target Allocation (accumulates organically from purchases):
- 30% USDC (stablecoin purchases)
- 25% ETH (bridged from ETH-PBC)
- 20% BTC (bridged from BTC-PBC)
- 15% SOL (bridged from SOL-PBC)
- 10% Other assets (governance-approved)

Rebalancing:
- Triggered when deviation exceeds 5%
- Automated via pallet-multiasset-reserve
- Governance can adjust allocation strategy
\`\`\`

**Allocation Strategies**:
- **EqualWeight**: Equal distribution across all reserve assets
- **MarketCapWeighted**: Weight by market capitalization
- **RiskAdjusted**: Weight by volatility/risk metrics
- **Custom**: Custom weights set by governance vote

**Purchase Process**:
\`\`\`rust
fn purchase_edsc(
    payment_token: AssetId,
    payment_amount: Balance
) -> Result<Balance, Error> {
    // Get payment token price from oracle
    let token_price_usd = oracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price_usd;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd; // 1 EDSC = $1.00

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * 10 / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    transfer_to_reserve(caller, payment_token, payment_amount)?;

    // Release EDSC from reserve vault to buyer
    release_from_vault(caller, net_edsc)?;

    // Reserve automatically rebalances if needed
    if should_rebalance() {
        trigger_rebalance()?;
    }

    Ok(net_edsc)
}
\`\`\`

**Redemption Process**:
\`\`\`rust
fn redeem_edsc(
    edsc_amount: Balance,
    preferred_payment: AssetId
) -> Result<Balance, Error> {
    // Burn EDSC from user
    burn_edsc(caller, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * 10 / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price
    let token_price = oracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    transfer_from_reserve(caller, preferred_payment, payment_amount)?;

    Ok(payment_amount)
}
\`\`\`

**Treasury-Backed Parameters**:
\`\`\`
Target Backing Ratio:    100% (purchase value)
Purchase Price:          $1.00 per EDSC
Redemption Price:        $1.00 per EDSC
Purchase Fee:            0.1% (goes to treasury)
Redemption Fee:          0.1% (goes to treasury)

Example:
User purchases 1000 EDSC with USDC:
‚Üí User sends: 1000 USDC ($1000)
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: 1000 USDC backing
‚Üí Backing ratio: 100% ($1000 backing 999 circulating EDSC)
\`\`\`

**Stability Mechanisms**:
1. **Multi-Asset Reserve**: Reduces correlation risk compared to single-asset backing
2. **Automated Rebalancing**: Maintains target allocations via pallet-multiasset-reserve
3. **Direct Purchase/Redemption**: Reserve always buys/sells at $1.00, maintaining peg
4. **Organic Backing**: 100% backing accumulates from user purchases (no pre-funding)
5. **Purchase/Redemption Fees**: 0.1% fees prevent spam while generating treasury revenue
6. **No Liquidations**: Simple buy/sell model eliminates liquidation risk
7. **Arbitrage**: Price deviations create profitable arbitrage opportunities
8. **DEX Integration**: FlareSwap enables efficient √âTR/EDSC trading and price discovery

**Reserve-Backed Token Framework**:

Beyond EDSC, the reserve infrastructure enables creation of diverse synthetic assets:

**Synthetic Asset Types**:
- **Stablecoins**: EDSC (USD), EEUR (Euro), EGBP (Pound)
- **Commodities**: EXAU (Gold), EXAG (Silver), EXOIL (Oil)
- **Equities**: ETSLA (Tesla), EAAPL (Apple), EGOOG (Google)
- **Indices**: ES&P (S&P 500), ENASDAQ (Nasdaq), EDJI (Dow Jones)

**Governance Controls**:
- Whitelisting of reserve assets (Consensus Day vote required)
- Adjustment of backing ratios per synthetic
- Rebalancing strategy selection
- Emergency pause of purchase/redemption

### VMw (Virtual Machine Watts)

**Purpose**: Measure computational cost (gas metering)

**Definition**: 1 VMw = 1 Watt-second of CPU energy

**Pricing**:
\`\`\`rust
fn calculate_gas_price() -> Balance {
    // Dynamic pricing based on block fullness
    let block_utilization = current_block_vmw / max_block_vmw; // 0.0 - 1.0

    // Base price: 1 VMw = 0.000001 √âTR
    let base_price = 1_000_000_000_000u128; // 1e-6 √âTR in plancks

    // Price increases exponentially with utilization
    let surge_multiplier = if block_utilization > 0.75 {
        1.0 + ((block_utilization - 0.75) * 8.0)
    } else {
        1.0
    };

    Balance::from((base_price as f64 * surge_multiplier) as u128)
}
\`\`\`

**Block Limits**:
- **Max VMw per block**: 10,000,000 VMw
- **Target utilization**: 50% (5,000,000 VMw)
- **Surge pricing**: Kicks in above 75% utilization

**Example Transaction Costs**:
\`\`\`
Simple Transfer:           100 VMw   ‚âà 0.0001 √âTR   ($0.001 at $10/√âTR)
Token Swap:              5,000 VMw   ‚âà 0.005 √âTR    ($0.05)
Complex Contract:       50,000 VMw   ‚âà 0.05 √âTR     ($0.50)
Cross-Chain Bridge:    200,000 VMw   ‚âà 0.2 √âTR      ($2.00)
\`\`\`

---

## 5. PROPOSAL SYSTEM & VOTING MECHANISMS

### Proposal Lifecycle

\`\`\`
1. Draft ‚Üí 2. Submission ‚Üí 3. Discussion ‚Üí 4. Voting ‚Üí 5. Execution
   (Off-chain)  (Registration)   (48h window)    (12h vote)   (Minting + Distribution)
\`\`\`

### Proposal Template

**Minimum Requirements**:
\`\`\`markdown
# Proposal Title (max 100 chars)

## Summary (max 300 chars)
One-paragraph overview accessible to all voters.

## Motivation
Why is this proposal necessary? What problem does it solve?

## Specification
Technical details. How will this be implemented?

## Budget Request (if applicable)
Amount: _______ √âTR
Breakdown:
  - Development: _______ √âTR
  - Audit: _______ √âTR
  - Deployment: _______ √âTR

## Implementation Timeline
Phase 1: (date range) - Milestone 1
Phase 2: (date range) - Milestone 2
...

## Success Criteria
How will we know this proposal succeeded?

## Risks & Mitigations
What could go wrong? How will we address it?

## Supporting Validators (min 3)
- Validator 1: [address]
- Validator 2: [address]
- Validator 3: [address]
\`\`\`

### Voting Rules

**Vote Types**:
1. **Yes**: Support the proposal
2. **No**: Reject the proposal
3. **Abstain**: Count toward quorum but not approval

**Quadratic Voting** (Optional, for contentious issues):
\`\`\`rust
fn calculate_quadratic_vote_cost(num_votes: u32) -> Balance {
    // Cost increases quadratically
    // 1 vote = 1 √âTR, 2 votes = 4 √âTR, 3 votes = 9 √âTR, etc.
    let cost_per_vote = num_votes * num_votes;
    Balance::from(cost_per_vote as u128 * VOTE_COST_BASE)
}
\`\`\`

**Conviction Voting** (Optional, for long-term decisions):
\`\`\`rust
enum Conviction {
    None,       // 1x voting power, unlock immediately
    Locked1x,   // 1x voting power, locked 1 epoch after vote
    Locked2x,   // 2x voting power, locked 2 epochs
    Locked4x,   // 4x voting power, locked 4 epochs
    Locked8x,   // 8x voting power, locked 8 epochs
}
\`\`\`

### Proposal Execution

**Automatic Execution**:
- If proposal approved with quorum ‚Üí Executed in Phase 3 (Minting)
- If proposal rejected ‚Üí Bond returned (if >5% quorum), proposal archived
- If proposal doesn't reach quorum ‚Üí Bond slashed, proposal discarded

**Manual Execution** (for protocol upgrades):
- Directors + validators coordinate deployment
- Upgrade scheduled for specific block height
- All nodes must upgrade before deadline

---

## 6. REWARD DISTRIBUTION & SLASHING

### Validator Rewards

**Annual Validator Reward Pool**: ~3% of circulating supply

**Distribution**:
\`\`\`rust
fn distribute_epoch_rewards(epoch: Epoch) {
    let total_pool = circulating_supply() * 0.03 / EPOCHS_PER_YEAR;

    for validator in active_validators() {
        let base_reward = total_pool * (validator.stake / total_stake);
        let adjusted_reward = base_reward * validator.performance_multiplier;

        // Pay 50% to validator, 50% to delegators
        pay_reward(validator.account, adjusted_reward * 0.5);
        pay_delegators(validator, adjusted_reward * 0.5);
    }
}
\`\`\`

**Performance Multiplier**:
\`\`\`rust
fn calculate_performance_multiplier(validator: &Validator) -> f64 {
    let uptime_score = validator.uptime; // 0.0 - 1.0
    let finality_score = validator.blocks_signed / validator.blocks_expected;
    let participation_score = if validator.voted_consensus_day { 1.1 } else { 1.0 };

    uptime_score * finality_score * participation_score
}
\`\`\`

### Delegator Rewards

**Delegation Mechanism**:
- Token holders can delegate √âTR to validators
- Validators charge commission (0-100%, set by validator)
- Rewards automatically distributed each epoch

**Commission Structure**:
\`\`\`rust
fn distribute_delegation_rewards(validator: &Validator, total_reward: Balance) {
    let commission_rate = validator.commission; // e.g., 0.10 = 10%
    let commission_amount = total_reward * commission_rate;
    let delegator_pool = total_reward - commission_amount;

    // Pay commission to validator
    pay_reward(validator.account, commission_amount);

    // Distribute remaining to delegators proportionally
    for delegator in validator.delegators() {
        let delegator_share = delegator.stake / validator.total_delegated;
        let delegator_reward = delegator_pool * delegator_share;
        pay_reward(delegator.account, delegator_reward);
    }
}
\`\`\`

### Slashing Conditions

**Offense Types**:

| Offense | Severity | Slash Amount | Cooldown |
|---------|----------|--------------|----------|
| Downtime (>24h) | Low | 1% per day | 7 days |
| Missed blocks (>10%) | Low | 0.5% | 3 days |
| Equivocation (double-sign) | High | 10% | 30 days |
| Invalid finality vote | High | 5% | 14 days |
| Censorship (provable) | Medium | 5% | 14 days |
| Coordinated attack | Critical | 50% + removal | Permanent ban |

**Slashing Execution**:
\`\`\`rust
fn execute_slash(
    validator: AccountId,
    offense: OffenseType,
    evidence: Vec<u8>,
) -> Result<(), Error> {
    // Verify evidence
    verify_offense_evidence(offense, evidence)?;

    // Calculate slash amount
    let slash_amount = match offense {
        OffenseType::Downtime => validator.stake * 0.01,
        OffenseType::Equivocation => validator.stake * 0.10,
        OffenseType::MaliciousAttack => validator.stake * 0.50,
        // ... other offenses
    };

    // Execute slash
    burn_tokens(validator, slash_amount * 0.5); // 50% burned
    transfer_to_treasury(slash_amount * 0.5);   // 50% to treasury

    // Apply cooldown
    apply_validator_cooldown(validator, offense.cooldown_period);

    // Emit event
    emit_event(Event::ValidatorSlashed {
        validator,
        offense,
        amount: slash_amount,
        timestamp: current_block(),
    });

    Ok(())
}
\`\`\`

### Appeal Process

**Validators can appeal slashing**:
1. Submit appeal within 72 hours (costs 1,000 √âTR bond)
2. Directors review evidence (7/9 vote required to overturn)
3. If appeal successful: slash reversed, bond returned
4. If appeal rejected: bond added to treasury

---

## 7. ECONOMIC SUSTAINABILITY MODEL

### Long-Term Supply Dynamics

**Target**: Slightly deflationary long-term (~1% annual deflation)

**Inflows** (Minting):
- Consensus Day approved budgets: 0-5% per year (voted)
- Emergency minting: <0.1% per year (rare)

**Outflows** (Burning):
- Transaction fees: ~50% of fees (continuous)
- Slashing: ~50% of slashed stakes (episodic)
- Voluntary burns: Community-voted (rare)

**Net Supply Projection**:
\`\`\`
Year 1:  1.00B √âTR (genesis)
Year 2:  1.02B √âTR (+2% voted inflation - 1% burned = +1% net)
Year 3:  1.03B √âTR (+2% inflation - 1.5% burned = +0.5% net)
Year 5:  1.04B √âTR (+1.5% inflation - 2% burned = -0.5% net)
Year 10: 1.00B √âTR (back to genesis, deflationary equilibrium)
\`\`\`

### Fee Market Dynamics

**Transaction Fee Formula**:
\`\`\`rust
fn calculate_transaction_fee(vmw_cost: u64, priority: Priority) -> Balance {
    let base_fee = vmw_cost * get_current_vmw_price(); // Dynamic pricing

    let priority_multiplier = match priority {
        Priority::Low => 0.8,
        Priority::Normal => 1.0,
        Priority::High => 1.5,
        Priority::Urgent => 3.0,
    };

    base_fee * priority_multiplier
}
\`\`\`

**Fee Allocation**:
- 50% burned (deflationary pressure)
- 40% to validators (reward for block production)
- 10% to treasury (public goods funding)

### Economic Security

**Attack Cost Analysis**:

To attack √ãtrid, an adversary must:
1. Acquire >33% of staked √âTR (to disrupt finality)
2. Operate attack for multiple epochs before detection
3. Survive slashing and social coordination against them

**Cost**:
\`\`\`
Assume 40% of supply staked (400M √âTR)
33% of staked = 132M √âTR
At $10/√âTR = $1.32 Billion capital requirement

Cost of attack:
- Capital cost: $1.32B
- Slashing risk: 50% = $660M loss if caught
- Opportunity cost: 8% APY = $105M/year forgone rewards
- Reputation cost: √âTR price crash ‚Üí total loss

Total cost: >$2 Billion for 51% attack
\`\`\`

**Conclusion**: Economic security increases with network value and participation

---

## 8. EMERGENCY PROCEDURES & CRISIS RESPONSE

### Emergency Powers

**Directors Emergency Authority** (7-of-9 vote):
1. **Pause Chains**: Temporarily halt block production (max 72 hours)
2. **Emergency Upgrade**: Deploy hotfix without Consensus Day vote
3. **Slash Malicious Actors**: Immediate slashing for provable attacks
4. **Emergency Mint**: Mint up to 1% of supply for critical bug bounty

### Crisis Response Protocol

**Level 1: Minor Issue** (e.g., validator downtime spike)
- Response Team: On-call validators
- Action: Monitor, alert community
- Timeline: 24-hour resolution

**Level 2: Moderate Issue** (e.g., smart contract exploit)
- Response Team: Directors + Security Team
- Action: Pause affected pallets, deploy patch
- Timeline: 48-hour resolution

**Level 3: Critical Issue** (e.g., consensus failure)
- Response Team: All Directors + Core Developers + Community
- Action: Emergency governance vote, possible chain halt
- Timeline: Immediate action, 7-day resolution

### Social Recovery

**If network becomes compromised beyond repair**:
1. **Snapshot**: Take state snapshot at last known good block
2. **Fork**: Create new chain from snapshot
3. **Migrate**: Community coordinates migration to new chain
4. **Deprecate**: Old chain deprecated, new chain becomes canonical

**GPLv3 Protection**: Anyone can fork and continue the network

---

## 9. CONCLUSION: GOVERNANCE AS A LIVING SYSTEM

### Why This Model Works

1. **Alignment**: Token holders, validators, and users all benefit from network success
2. **Adaptation**: Annual Consensus Day forces regular evolution
3. **Transparency**: All decisions on-chain, all treasury actions public
4. **Resilience**: No single point of failure, multiple layers of accountability
5. **Sustainability**: Self-funding via fees, deflationary tendency prevents inflation

### Comparison to Other Models

| Feature | √ãtrid | Bitcoin | Ethereum | Polkadot |
|---------|-------|---------|----------|----------|
| **Governance** | On-chain annual vote | Off-chain (BIPs) | Off-chain (EIPs) | On-chain (referenda) |
| **Treasury** | Autonomous | None | Foundation-controlled | Autonomous |
| **Inflation** | Voted (0-5%) | Fixed (halving) | Fixed (~1%) | Fixed (~10%) |
| **Participation** | >33% quorum | N/A | ~5% typical | ~10% typical |
| **Emergency Powers** | Directors (7/9) | None | Foundation | Council |

### The Path to Sovereignty

√ãtrid governance is designed to achieve **true decentralization** through:
- **Economic incentives** (rewards for participation)
- **Social accountability** (transparent decisions, elected directors)
- **Technical constraints** (protocol-enforced caps, slashing)
- **Regular rhythm** (annual Consensus Day prevents drift)

**The goal**: A network that governs itself, funds itself, and evolves without relying on any central authority.

---

## APPENDIX A: Consensus Day Checklist

**For Voters**:
- [ ] Review all proposals (published 7 days before Consensus Day)
- [ ] Lock √âTR during Registration Phase (6 hours)
- [ ] Vote on all proposals during Voting Phase (12 hours)
- [ ] Claim participation rewards during Distribution Phase (1 hour)

**For Validators**:
- [ ] Signal participation during Registration Phase
- [ ] Vote on all proposals during Voting Phase
- [ ] Monitor network health during Minting Phase
- [ ] Verify reward distribution during Distribution Phase

**For Directors**:
- [ ] Review all proposals and publish recommendations
- [ ] Monitor quorum and voting during Voting Phase
- [ ] Execute approved budgets during Minting Phase
- [ ] Verify distribution accuracy during Distribution Phase

---

## APPENDIX B: Governance Formulas

### Quorum Calculation
\`\`\`rust
fn quorum_met(proposal: &Proposal) -> bool {
    let community_votes = proposal.total_votes;
    let validator_votes = proposal.validator_count;

    (community_votes >= circulating_supply() * 0.33) &&
    (validator_votes >= active_validator_count() * 0.51)
}
\`\`\`

### Approval Calculation
\`\`\`rust
fn proposal_approved(proposal: &Proposal) -> bool {
    let yes_votes = proposal.yes_votes;
    let total_votes = proposal.yes_votes + proposal.no_votes; // Abstain doesn't count

    let threshold = match proposal.category {
        ProposalCategory::BudgetAllocation => 0.50,
        ProposalCategory::ParameterChange => 0.50,
        ProposalCategory::ProtocolUpgrade => 0.66,
        ProposalCategory::EmergencyAction => 0.66,
    };

    (yes_votes as f64 / total_votes as f64) >= threshold
}
\`\`\`

---

## APPENDIX C: Further Reading

**Volume I**: Conceptual Architecture (Vision, Problem, Solution, Philosophy)
**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime)

**Online Resources**:
- Governance Portal: governance.etrid.org
- Proposal Archive: proposals.etrid.org
- Treasury Dashboard: treasury.etrid.org

---

**End of Volume III**

**√ãtrid Ivory Papers Complete**

---

*"Governance is not a feature to be added. It is the fundamental architecture of coordination."*

---

**Document Status**: ACTIVE PROTOCOL SPECIFICATION
**Next Review**: Consensus Day 2026 (December 1, 2026)

---

## ADDENDUM: TREASURY AND RESERVE SYSTEM IMPLEMENTATION (2025)

### Overview

Following the specifications outlined in this volume, the √ãtrid protocol has implemented a comprehensive treasury and reserve system through four specialized pallets. This addendum documents the technical implementation details, operational procedures, and emergency protocols for these critical financial infrastructure components.

**Implementation Status**: ACTIVE (Deployed Q4 2025)
**Pallet Locations**: \`/Users/macbook/Desktop/etrid/src/pallets/\`

---

### 1. PALLET-TREASURY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-treasury/src/lib.rs\`

The treasury pallet implements the protocol's fiscal management system with multi-signature governance controls.

#### Multisig Architecture

**Configuration**:
- **Directors**: 9 elected representatives (via Consensus Day)
- **Normal Operations**: 6-of-9 approval threshold
- **Emergency Actions**: 7-of-9 approval threshold
- **Term Length**: 1 year (renewable via re-election)

**Director Requirements**:
\`\`\`rust
// Minimum stake: 128 √ãTR
// Must serve as OD Flare Nodes
// Subject to term limits (max 3 lifetime terms)
// One-year cooldown between terms
\`\`\`

**Multisig Controls**:
\`\`\`rust
pub struct Disbursement<T: Config> {
    pub id: u64,
    pub category: BudgetCategory,
    pub recipient: T::AccountId,
    pub amount: BalanceOf<T>,
    pub proposer: T::AccountId,
    pub status: DisbursementStatus,
    pub approval_count: u8,
    pub is_emergency: bool,  // Requires 7/9 instead of 6/9
}
\`\`\`

#### Budget Categories

Default allocations (modifiable via Consensus Day governance):

\`\`\`rust
pub struct BudgetAllocations {
    pub development_bps: u32,      // 40% (4000 basis points)
    pub marketing_bps: u32,        // 20% (2000 basis points)
    pub operations_bps: u32,       // 15% (1500 basis points)
    pub grants_bps: u32,           // 15% (1500 basis points)
    pub emergency_reserve_bps: u32, // 10% (1000 basis points)
}
\`\`\`

**Budget Category Details**:

1. **Development (40%)**:
   - Core protocol development
   - Research and innovation
   - Infrastructure improvements
   - Security audits and bug bounties

2. **Marketing (20%)**:
   - Community growth initiatives
   - Partnership development
   - Educational content
   - Brand awareness campaigns

3. **Operations (15%)**:
   - Team salaries (community-voted)
   - Legal and compliance
   - Administrative expenses
   - Operational infrastructure

4. **Grants (15%)**:
   - Ecosystem development grants
   - Developer support programs
   - Research initiatives
   - Community projects

5. **Emergency Reserve (10%)**:
   - Locked for critical situations
   - Requires 7-of-9 approval for access
   - Protocol security responses
   - Network stability measures

#### Disbursement Workflow

**Step 1: Proposal**
\`\`\`rust
// Any director can propose disbursement
pub fn propose_disbursement(
    origin: OriginFor<T>,
    category: BudgetCategory,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult
\`\`\`

**Step 2: Approval**
\`\`\`rust
// Other directors vote (need 6 total approvals, 7 for emergency)
pub fn approve_disbursement(
    origin: OriginFor<T>,
    disbursement_id: u64,
) -> DispatchResult
\`\`\`

**Step 3: Automatic Execution**
\`\`\`rust
// Executes automatically when threshold reached
if disbursement.approval_count >= threshold {
    Self::execute_disbursement_internal(disbursement_id)?;
}
\`\`\`

**Safeguards**:
- Proposals expire after 7 days if quorum not reached
- Directors cannot approve same proposal twice
- Category allocations checked before disbursement
- All actions emit transparent on-chain events

#### Emergency Withdrawal Procedures

Emergency withdrawals require heightened security:

\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals (higher threshold)
    // Can only withdraw from EmergencyReserve
    // Used for critical protocol emergencies
}
\`\`\`

**Emergency Scenarios**:
- Critical security vulnerabilities
- Protocol-threatening exploits
- Network stability emergencies
- Consensus failure recovery

#### Funding Source Integration

The treasury receives funds from multiple sources:

\`\`\`rust
pub enum FundingSource {
    TransactionFees,      // 50% of all transaction fees
    ConsensusDayMinting,  // Approved budgets from annual vote
    ValidatorSlashing,    // 50% of slashing penalties
    CrossChainFees,       // 10% of bridge transaction fees
    Other,                // Donations, etc.
}
\`\`\`

**Funding Flow Example**:
\`\`\`
Transaction: 1000 √ãTR fee collected
‚Üí 50% (500 √ãTR) burned (deflationary)
‚Üí 40% (400 √ãTR) to validators
‚Üí 10% (100 √ãTR) to treasury

Consensus Day: 100M √ãTR minted
‚Üí 98.3M to treasury for budgets
‚Üí 1.0M to participation rewards
‚Üí 0.5M to validator bonuses
‚Üí 0.2M to director stipends
\`\`\`

#### Storage Items

**Core Storage**:
\`\`\`rust
/// Total √ãTR balance in treasury
TreasuryBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// EDSC stablecoin balance
EdscBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Budget allocation percentages
BudgetAllocationsStorage<T: Config> = StorageValue<_, BudgetAllocations>

/// Category-specific allocated amounts
CategoryAllocations<T: Config> = StorageMap<_, BudgetCategory, BalanceOf<T>>

/// Pending and historical disbursements
Disbursements<T: Config> = StorageMap<_, u64, Disbursement<T>>

/// Director approvals per disbursement
DirectorApprovals<T: Config> = StorageMap<_, u64, BoundedVec<T::AccountId, ConstU32<9>>>

/// Current 9 directors
Directors<T: Config> = StorageValue<_, BoundedVec<T::AccountId, ConstU32<9>>>

/// Emergency reserve balance
EmergencyReserve<T: Config> = StorageValue<_, BalanceOf<T>>
\`\`\`

#### Extrinsics

**Public Functions**:
\`\`\`rust
// Fund treasury from various sources
fund_treasury(source: FundingSource, amount: Balance)

// Director proposes spending
propose_disbursement(category, recipient, amount, description)

// Director approves proposal (6/9 needed)
approve_disbursement(disbursement_id)

// Emergency reserve access (7/9 needed)
emergency_withdrawal(recipient, amount, description)
\`\`\`

**Governance Functions** (Root/Consensus Day only):
\`\`\`rust
// Update budget percentages
set_budget_allocations(allocations: BudgetAllocations)

// Allocate funds to categories
allocate_to_categories(total_amount: Balance)

// Add/remove directors
add_director(director: AccountId)
remove_director(director: AccountId)
\`\`\`

---

### 2. PALLET-MULTIASSET-RESERVE IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-multiasset-reserve/src/lib.rs\`

The multiasset reserve pallet enables diversified reserve management with automatic rebalancing capabilities.

#### Multi-Asset Reserve Management

**Asset Configuration**:
\`\`\`rust
pub struct AssetMetadata {
    pub symbol: BoundedVec<u8, ConstU32<16>>,  // BTC, ETH, etc.
    pub decimals: u8,
    pub is_active: bool,
    pub min_holding: u128,
    pub max_holding: u128,
    pub target_allocation: Permill,
    pub last_rebalance: u32,
}
\`\`\`

**Reserve Composition**:
\`\`\`rust
pub struct AssetHolding {
    pub asset_id: u32,
    pub amount: u128,
    pub value_usd: u128,      // Cached with 8 decimals
    pub last_price_update: u32,
}
\`\`\`

**Supported Asset Types**:
- Native √ãTR token
- Bridged Bitcoin (sBTC)
- Bridged Ethereum (sETH)
- Stablecoins (USDC, USDT)
- Synthetic gold (sXAU)
- Other governance-approved assets

#### Allocation Strategies

Four distinct strategies available:

\`\`\`rust
pub enum AllocationStrategy {
    /// Equal weight allocation (each asset gets equal %)
    EqualWeight = 0,

    /// Market cap weighted (higher cap = higher allocation)
    MarketCapWeighted = 1,

    /// Risk-adjusted (lower volatility = higher allocation)
    RiskAdjusted = 2,

    /// Custom manual allocations (default)
    Custom = 3,
}
\`\`\`

**Strategy Selection**:
\`\`\`rust
// Governance can set strategy via:
pub fn set_allocation_strategy(
    origin: OriginFor<T>,
    strategy_code: u8,  // 0-3 corresponding to enum
) -> DispatchResult
\`\`\`

**Example Custom Allocation**:
\`\`\`
For EDSC backing:
- 40% √ãTR (native token, low correlation)
- 30% sBTC (store of value, established)
- 20% sETH (smart contract ecosystem)
- 10% Other (USDC, sXAU, diversification)
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
/// Triggered when deviation exceeds 5% threshold
#[pallet::constant]
type RebalanceThreshold: Get<Permill>;  // Default: 500 (5%)
\`\`\`

**Rebalancing Logic**:
\`\`\`rust
pub fn needs_rebalancing() -> bool {
    let threshold = T::RebalanceThreshold::get();

    for (asset_id, config) in AssetConfigs::<T>::iter() {
        let current_alloc = Self::get_asset_allocation(asset_id)?;
        let target = config.target_allocation;

        let deviation = if current_alloc > target {
            current_alloc.saturating_sub(target)
        } else {
            target.saturating_sub(current_alloc)
        };

        if deviation > threshold {
            return true;  // Rebalancing needed
        }
    }

    false
}
\`\`\`

**Rebalancing Execution**:
\`\`\`rust
pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    // Check rebalance interval (minimum time between rebalances)
    // Calculate required swaps to reach target allocations
    // Execute swaps via DEX integration
    // Update holdings and emit events
    // Record rebalancing history
}
\`\`\`

#### Oracle Integration

**Price Oracle Dependency**:
\`\`\`rust
trait Config: frame_system::Config + pallet_reserve_oracle::Config {
    // Inherits oracle functionality for real-time pricing
}
\`\`\`

**Price Updates**:
- Real-time asset prices from oracle network
- Cached USD values for performance
- 8 decimal precision for accuracy
- Automatic updates on reserve operations

#### Vault Integration

**Secure Asset Storage**:
- Integration with \`pallet-reserve-vault\` for custody
- Multi-signature controls for asset movements
- Separation of hot/cold storage
- Audit trail for all asset transfers

#### Asset Whitelisting and Position Limits

**Whitelisting**:
\`\`\`rust
/// Governance-controlled asset approval
pub type WhitelistedAssets<T: Config> = StorageMap<
    _, Blake2_128Concat, u32, bool
>;

// Only whitelisted assets can be added to reserve
ensure!(WhitelistedAssets::<T>::get(asset_id), Error::<T>::AssetNotWhitelisted);
\`\`\`

**Position Limits**:
\`\`\`rust
// Per-asset min/max holdings
ensure!(amount >= config.min_holding, Error::<T>::BelowMinimumHolding);
ensure!(amount <= config.max_holding, Error::<T>::ExceedsMaximumHolding);
\`\`\`

**Risk Management**:
- Maximum exposure limits per asset class
- Diversification requirements
- Liquidity constraints
- Correlation monitoring

#### Storage Items

\`\`\`rust
/// Asset configuration registry
AssetConfigs<T: Config> = StorageMap<_, u32, AssetMetadata>

/// Reserve composition (holdings per asset)
ReserveComposition<T: Config> = StorageMap<_, u32, AssetHolding>

/// Current allocation strategy (0=EqualWeight, 1=MarketCapWeighted, 2=RiskAdjusted, 3=Custom)
CurrentStrategy<T: Config> = StorageValue<_, u8>

/// Total reserve value (cached, USD with 8 decimals)
TotalReserveValue<T: Config> = StorageValue<_, u128>

/// Whitelisted assets
WhitelistedAssets<T: Config> = StorageMap<_, u32, bool>

/// Asset count
AssetCount<T: Config> = StorageValue<_, u32>

/// Last rebalance status
LastRebalance<T: Config> = StorageValue<_, RebalanceStatus<BlockNumber>>

/// Rebalancing enabled flag
RebalancingEnabled<T: Config> = StorageValue<_, bool>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Add new asset to reserve
add_asset(asset_id, symbol, decimals, min_holding, max_holding, target_allocation)

// Remove asset from reserve
remove_asset(asset_id)

// Set target allocation for asset
set_target_allocation(asset_id, target: Permill)

// Set allocation strategy
set_allocation_strategy(strategy_code: u8)

// Enable/disable automatic rebalancing
set_rebalancing_enabled(enabled: bool)
\`\`\`

**Public Functions**:
\`\`\`rust
// Deposit asset into reserve
deposit_to_reserve(asset_id, amount)

// Trigger manual rebalance
trigger_rebalance()
\`\`\`

**Restricted Functions** (Governance only):
\`\`\`rust
// Withdraw asset from reserve
withdraw_from_reserve(asset_id, amount)
\`\`\`

---

### 3. PALLET-EDSC-STABILITY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-edsc-stability/src/lib.rs\`

The EDSC stability pallet implements the protocol's stablecoin system with multi-asset reserve backing and peg defense mechanisms.

#### EDSC Stablecoin System

**Peg Target**: $1.00 USD (soft peg maintained via arbitrage and stability mechanisms)

**Reserve Architecture**:
\`\`\`rust
pub struct ReserveComposition {
    pub etr_allocation: u16,    // 40% (4000 basis points)
    pub sbtc_allocation: u16,   // 30% (3000 basis points)
    pub seth_allocation: u16,   // 20% (2000 basis points)
    pub other_allocation: u16,  // 10% (1000 basis points)
}
\`\`\`

**Multi-Asset Reserve Backing**:
- **40% √ãTR**: Native token, governance voting power
- **30% sBTC**: Synthetic Bitcoin, store of value
- **20% sETH**: Synthetic Ethereum, DeFi integration
- **10% Other**: USDC, sXAU, diversification assets

#### Treasury-Backed Parameters

\`\`\`rust
/// Target backing ratio: 100% (10000 basis points)
#[pallet::constant]
type TargetBackingRatio: Get<u16>;  // Default: 10000 (100%)

/// Purchase fee: 0.1% (10 basis points)
#[pallet::constant]
type PurchaseFee: Get<u16>;  // Default: 10

/// Redemption fee: 0.1% (10 basis points)
#[pallet::constant]
type RedemptionFee: Get<u16>;  // Default: 10
\`\`\`

**Purchase/Redemption Example**:
\`\`\`
To purchase 1000 EDSC:
‚Üí User sends: $1000 in BTC/ETH/SOL/USDC
‚Üí Purchase fee: $1 (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: $1000 backing

To redeem 999 EDSC:
‚Üí User burns: 999 EDSC
‚Üí Redemption fee: $0.999 (0.1%)
‚Üí User receives: $998.001 in preferred crypto
‚Üí Reserve releases: $998.001 from holdings

Key Differences from Over-Collateralized Model:
- No upfront capital required to launch
- Backing accumulates organically from purchases
- No liquidations (direct buy/sell only)
- 100% backing ratio (not 150%)
- No debt positions or interest charges
\`\`\`

#### Interest Rate Adjustments for Peg Defense

**Dynamic Interest Rates**:
\`\`\`rust
/// Base interest rate (annual, in basis points)
#[pallet::constant]
type BaseInterestRate: Get<u16>;  // Default: 200 (2% annual)
\`\`\`

**Peg Defense Mechanism**:
\`\`\`rust
pub fn adjust_interest_rate(
    origin: OriginFor<T>,
    new_rate: u16,
) -> DispatchResult {
    // If EDSC > $1.01: Lower rate to encourage minting
    // If EDSC < $0.99: Raise rate to encourage burning

    let price = EDSCPrice::<T>::get();  // In cents (100 = $1.00)

    if price > 101 {
        // Trading above peg: lower interest to encourage minting
        new_rate = current_rate.saturating_sub(50);  // Reduce by 0.5%
    } else if price < 99 {
        // Trading below peg: raise interest to encourage burning
        new_rate = current_rate.saturating_add(50);  // Increase by 0.5%
    }

    InterestRate::<T>::put(new_rate);
}
\`\`\`

**Interest Calculation**:
\`\`\`rust
fn calculate_accrued_interest(
    position: &EDSCPosition<BalanceOf<T>>,
    current_block: u32,
) -> Result<u128, DispatchError> {
    let blocks_elapsed = current_block - position.last_interest_update;
    let blocks_per_year = 5_256_000u128;  // ~6 second blocks

    // Interest = principal * rate * time
    let interest = position.edsc_minted
        .checked_mul(position.interest_rate as u128)?
        .checked_mul(blocks_elapsed as u128)?
        .checked_div(10000)?  // Basis points to decimal
        .checked_div(blocks_per_year)?;

    Ok(interest)
}
\`\`\`

#### Reserve Purchase/Redemption System

**Purchase from Reserve**:
\`\`\`rust
pub fn purchase_edsc(
    origin: OriginFor<T>,
    payment_token: AssetId,
    payment_amount: BalanceOf<T>,
) -> DispatchResult {
    let buyer = ensure_signed(origin)?;

    // Get payment token price from oracle
    let token_price = T::PriceOracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd;

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * T::PurchaseFee::get() / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    T::MultiCurrency::transfer(payment_token, &buyer, &T::ReserveVault::get(), payment_amount)?;

    // Release EDSC from vault to buyer
    T::Currency::transfer(&T::ReserveVault::get(), &buyer, net_edsc)?;

    Ok(())
}
\`\`\`

**Redemption to Reserve**:
\`\`\`rust
pub fn redeem_edsc(
    origin: OriginFor<T>,
    edsc_amount: BalanceOf<T>,
    preferred_payment: AssetId,
) -> DispatchResult {
    let redeemer = ensure_signed(origin)?;

    // Burn EDSC from user
    T::Currency::burn_from(&redeemer, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * T::RedemptionFee::get() / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price and amount
    let token_price = T::PriceOracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    T::MultiCurrency::transfer(preferred_payment, &T::ReserveVault::get(), &redeemer, payment_amount)?;

    Ok(())
}
\`\`\`

**Fee Distribution**:
\`\`\`
Purchase Fee: 0.1% ‚Üí Treasury
Redemption Fee: 0.1% ‚Üí Treasury

Example:
User purchases 1000 EDSC with 1000 USDC:
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Treasury receives: 1 USDC fee
‚Üí Reserve holds: 1000 USDC backing

User redeems 999 EDSC for USDC:
‚Üí Fee: 0.999 USDC (0.1%)
‚Üí User receives: 998.001 USDC
‚Üí Treasury receives: 0.999 USDC fee
‚Üí Reserve releases: 998.001 USDC
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
#[pallet::constant]
type RebalanceThreshold: Get<u16>;  // Default: 500 (5%)

pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    let current = CurrentReserveComposition::<T>::get();
    let target = TargetReserveComposition::<T>::get();

    let deviation = Self::calculate_composition_deviation(&current, &target)?;

    ensure!(
        deviation > T::RebalanceThreshold::get(),
        Error::<T>::RebalancingNotNeeded
    );

    // Execute rebalancing...
}
\`\`\`

**Rebalancing Process**:
1. Calculate current asset allocations
2. Compare to target percentages
3. Determine required swaps
4. Execute trades via DEX
5. Update reserve composition
6. Emit rebalancing events

#### Treasury Integration

**Stability Fees Flow**:
\`\`\`rust
/// Accumulated stability fees for treasury
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

// Interest payments go to stability fees
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(interest_in_collateral);
});
\`\`\`

**Purchase/Redemption Fees Flow**:
\`\`\`rust
// Fees sent to treasury
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(purchase_fee + redemption_fee);
});
\`\`\`

**Fee Collection**:
- Purchase fees from EDSC purchases (0.1%)
- Redemption fees from EDSC redemptions (0.1%)
- Rebalancing fees (if applicable)
- All fees flow to treasury for protocol sustainability

#### Storage Items

\`\`\`rust
/// Main EDSC reserve balance
EDSCReserveBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Current reserve composition
CurrentReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Target reserve composition (governance-updatable)
TargetReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Current backing ratio (basis points)
BackingRatio<T: Config> = StorageValue<_, u16>

/// Reserve vault address (holds initial EDSC supply)
ReserveVault<T: Config> = StorageValue<_, T::AccountId>

/// Circulating EDSC supply (released from vault)
CirculatingEDSCSupply<T: Config> = StorageValue<_, u128>

/// User EDSC balances
EDSCBalances<T: Config> = StorageMap<_, T::AccountId, u128>

/// Purchase/redemption history
TransactionHistory<T: Config> = StorageMap<_, T::AccountId, Vec<EDSCTransaction>>

/// Accumulated stability fees
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

/// Emergency pause flag
EmergencyPaused<T: Config> = StorageValue<_, bool>

/// Rebalancing history
RebalanceHistory<T: Config> = StorageMap<_, u32, RebalanceRecord>

/// Current EDSC price (in cents, 100 = $1.00)
EDSCPrice<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**User Functions**:
\`\`\`rust
// Purchase EDSC from reserve with crypto
purchase_edsc(payment_token: AssetId, payment_amount: Balance)

// Redeem EDSC back to reserve for crypto
redeem_edsc(edsc_amount: Balance, preferred_payment: AssetId)

// Check current reserve backing ratio
get_backing_ratio() -> Result<u16, Error>

// Trigger reserve rebalancing
trigger_rebalance()
\`\`\`

**Governance Functions** (Root only):
\`\`\`rust
// Adjust interest rate for peg defense
adjust_interest_rate(new_rate: u16)

// Emergency pause system
emergency_pause()

// Deactivate emergency pause
deactivate_emergency_pause()

// Update target reserve composition
update_target_composition(new_composition)
\`\`\`

---

### 4. PALLET-CIRCUIT-BREAKER IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-circuit-breaker/src/lib.rs\`

The circuit breaker pallet provides emergency safety controls for the EDSC stability system.

#### Circuit Breaker Statuses

\`\`\`rust
pub enum CircuitStatus {
    /// Normal operation - all functions available
    Normal,

    /// Throttled - limited operations, reduced volume caps
    Throttled,

    /// Paused - critical operations suspended
    Paused,

    /// Emergency - all non-critical operations halted
    Emergency,
}
\`\`\`

**Status Transitions**:
\`\`\`
Normal ‚Üí Throttled:  Reserve ratio drops below 95%
Throttled ‚Üí Paused:  Volume limits exceeded
Paused ‚Üí Emergency:  Reserve ratio drops below 90%
Emergency ‚Üí Normal:  Requires governance approval
\`\`\`

#### Volume Caps

**Hourly and Daily Limits**:
\`\`\`rust
/// Maximum hourly redemption volume (in EDSC)
#[pallet::constant]
type MaxHourlyVolume: Get<u128>;  // Default: 1M EDSC/hour

/// Maximum daily redemption volume (in EDSC)
#[pallet::constant]
type MaxDailyVolume: Get<u128>;  // Default: 10M EDSC/day
\`\`\`

**Volume Tracking**:
\`\`\`rust
pub struct VolumeTracker<BlockNumber> {
    pub hourly_volume: u128,
    pub hourly_start_block: BlockNumber,
    pub daily_volume: u128,
    pub daily_start_block: BlockNumber,
}

pub fn track_volume(amount: u128) -> DispatchResult {
    let mut tracker = RedemptionVolume::<T>::get();

    tracker.hourly_volume = tracker.hourly_volume.saturating_add(amount);
    tracker.daily_volume = tracker.daily_volume.saturating_add(amount);

    // Check limits
    if tracker.hourly_volume > T::MaxHourlyVolume::get() {
        Self::trigger_circuit(b"Hourly volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    if tracker.daily_volume > T::MaxDailyVolume::get() {
        Self::trigger_circuit(b"Daily volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    Ok(())
}
\`\`\`

#### Reserve Ratio Thresholds

**Threshold Configuration**:
\`\`\`rust
/// Reserve ratio threshold for throttling (95%)
#[pallet::constant]
type ThrottleThreshold: Get<u16>;  // Default: 9500 basis points

/// Reserve ratio threshold for emergency pause (90%)
#[pallet::constant]
type EmergencyThreshold: Get<u16>;  // Default: 9000 basis points
\`\`\`

**Automatic Status Updates**:
\`\`\`rust
pub fn check_reserve_ratio(reserve_ratio: u16) -> DispatchResult {
    let current_status = Status::<T>::get();

    // Emergency threshold (90%)
    if reserve_ratio < T::EmergencyThreshold::get() {
        if current_status != CircuitStatus::Emergency {
            Self::trigger_circuit(b"Emergency reserve threshold breached");
            Status::<T>::put(CircuitStatus::Emergency);
        }
        return Err(Error::<T>::ReserveRatioTooLow);
    }

    // Throttle threshold (95%)
    if reserve_ratio < T::ThrottleThreshold::get() {
        if current_status == CircuitStatus::Normal {
            Status::<T>::put(CircuitStatus::Throttled);
        }
    } else {
        // Healthy - return to normal if throttled
        if current_status == CircuitStatus::Throttled {
            Status::<T>::put(CircuitStatus::Normal);
        }
    }

    Ok(())
}
\`\`\`

#### Auto-Pause Mechanisms

**Peg Deviation Auto-Pause**:
\`\`\`rust
/// Emergency pause threshold (10% peg deviation)
#[pallet::constant]
type EmergencyPauseThreshold: Get<u16>;  // Default: 1000 (10%)

// If EDSC price deviates >10% from $1.00, auto-pause
let price = EDSCPrice::<T>::get();  // In cents
let target = 100;  // $1.00

let deviation = if price > target {
    ((price - target) * 10000) / target
} else {
    ((target - price) * 10000) / target
};

if deviation > T::EmergencyPauseThreshold::get() {
    EmergencyPaused::<T>::put(true);
    Self::trigger_circuit(b"Peg deviation exceeded 10%");
}
\`\`\`

**Automatic Triggers**:
1. **Volume Spike**: >1M EDSC redeemed in 1 hour
2. **Reserve Depletion**: Reserve ratio <90%
3. **Peg Break**: EDSC price >$1.10 or <$0.90
4. **Rapid Redemptions**: >100,000 EDSC redemptions per hour
5. **Oracle Failure**: Price feed stale >1 hour

#### Whitelist System

**Whitelist Configuration**:
\`\`\`rust
/// Accounts exempt from circuit breaker restrictions
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

pub fn is_operation_allowed(account: &T::AccountId, amount: u128) -> DispatchResult {
    // Whitelisted accounts bypass restrictions
    if Whitelist::<T>::get(account) {
        return Ok(());
    }

    // Check circuit status for others
    match Status::<T>::get() {
        CircuitStatus::Emergency => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Paused => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Throttled => Ok(()),  // Limited operations allowed
        CircuitStatus::Normal => Ok(()),
    }
}
\`\`\`

**Whitelist Use Cases**:
- Emergency recovery accounts
- Protocol-owned liquidity providers
- Authorized market makers
- Treasury disbursement accounts

#### Storage Items

\`\`\`rust
/// Current circuit breaker status
Status<T: Config> = StorageValue<_, CircuitStatus>

/// Volume tracker for redemptions
RedemptionVolume<T: Config> = StorageValue<_, VolumeTracker<BlockNumber>>

/// Manual pause flag (governance-controlled)
ManualPauseEnabled<T: Config> = StorageValue<_, bool>

/// Whitelist of exempt accounts
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

/// Total circuit trigger count
TriggerCount<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Manually pause circuit
activate_manual_pause()

// Resume normal operations
resume()

// Add account to whitelist
add_to_whitelist(account: AccountId)

// Remove account from whitelist
remove_from_whitelist(account: AccountId)

// Reset circuit breaker
reset_circuit()
\`\`\`

**Automatic Functions** (Called by other pallets):
\`\`\`rust
// Check if operation allowed
is_operation_allowed(account, amount)

// Track redemption volume
track_volume(amount)

// Check reserve ratio thresholds
check_reserve_ratio(reserve_ratio)
\`\`\`

---

### 5. EMERGENCY RECOVERY PROCEDURES

This section documents critical emergency response protocols for the treasury and reserve system.

#### Treasury Emergency Freeze

**Scenario**: Suspected treasury compromise or unauthorized access

**Procedure**:
\`\`\`rust
// 1. Any Director can trigger immediate freeze
pub fn emergency_freeze_treasury() {
    // Pause all disbursements
    // Require 7/9 approval to unfreeze
    // Alert all directors via on-chain event
}

// 2. Investigation period (72 hours maximum)
// - Analyze suspicious transactions
// - Verify director identities
// - Check multisig signatures

// 3. Resolution requires 7/9 directors
pub fn unfreeze_treasury() {
    // Verify 7/9 director approvals
    // Resume normal operations
    // Document incident for transparency
}
\`\`\`

**Multi-Signature Recovery**:
\`\`\`bash
# Generate recovery transaction
etrid-cli treasury emergency-freeze \
  --director-keys /path/to/keys \
  --reason "Suspicious activity detected"

# Requires 7/9 signatures to unfreeze
etrid-cli treasury unfreeze \
  --approvals director1,director2,...,director7 \
  --verify-signatures
\`\`\`

#### Stuck Funds Recovery

**Scenario**: Funds locked due to smart contract bug or runtime upgrade issue

**Emergency Withdrawal Protocol**:
\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals
    // Can only withdraw from EmergencyReserve
    // Full audit trail recorded on-chain

    ensure!(
        disbursement.approval_count >= 7,
        Error::<T>::EmergencyThresholdNotMet
    );

    // Execute emergency transfer
    T::Currency::transfer(&Self::account_id(), &recipient, amount)?;

    // Emit detailed event
    Self::deposit_event(Event::EmergencyWithdrawal(amount, recipient, 7));
}
\`\`\`

**Recovery Steps**:
1. Directors identify stuck funds
2. Create emergency withdrawal proposal
3. Collect 7/9 director approvals
4. Execute recovery transaction
5. Post-mortem analysis and report
6. Protocol upgrade if needed

#### EDSC Peg Break Response

**Scenario**: EDSC price deviates >10% from $1.00 peg

**Response Protocol**:

**Phase 1: Automatic Circuit Breaker (Immediate)**
\`\`\`rust
// Auto-triggered when peg breaks
if edsc_price > 110 || edsc_price < 90 {  // In cents
    EmergencyPaused::<T>::put(true);
    Status::<T>::put(CircuitStatus::Emergency);

    Self::deposit_event(Event::EmergencyPauseActivated {
        triggered_by: system_account,
        reason: b"EDSC peg break >10%",
    });
}
\`\`\`

**Phase 2: Reserve Injection (Directors, <6 hours)**
\`\`\`rust
// Directors vote to inject reserves
pub fn inject_reserves_for_peg(
    amount: BalanceOf<T>,
) -> DispatchResult {
    // Requires 6/9 director approval
    // Deploy reserves to support peg
    // Buy EDSC if <$0.90 or sell if >$1.10
}
\`\`\`

**Phase 3: Interest Rate Adjustment (Immediate)**
\`\`\`rust
// Automatic interest rate response
if edsc_price < 99 {
    // EDSC trading below $1: Raise rates to encourage burning
    new_rate = current_rate.saturating_add(100);  // +1% annual
} else if edsc_price > 101 {
    // EDSC trading above $1: Lower rates to encourage minting
    new_rate = current_rate.saturating_sub(100);  // -1% annual
}

InterestRate::<T>::put(new_rate);
\`\`\`

**Phase 4: Governance Response (24-48 hours)**
- Emergency governance vote (if needed)
- Adjust collateralization requirements
- Modify reserve composition targets
- Implement additional stability mechanisms

#### Validator Payment Failure Recovery

**Scenario**: Validator rewards fail to distribute due to runtime issue

**Manual Distribution Procedure**:
\`\`\`bash
# 1. Identify affected validators and amounts
etrid-cli validator list-pending-rewards \
  --epoch 12345 \
  --output rewards.json

# 2. Create manual distribution proposal
etrid-cli treasury propose-batch-payment \
  --recipients rewards.json \
  --category Operations \
  --description "Manual validator reward distribution for epoch 12345"

# 3. Directors approve (6/9 required)
etrid-cli treasury approve-disbursement \
  --id 42 \
  --director-key /path/to/director/key

# 4. Verify distributions
etrid-cli validator verify-payments \
  --epoch 12345 \
  --check-balances
\`\`\`

**Compensation Protocol**:
- Calculate exact owed amounts per validator
- Include missed staking rewards
- Add compensation for delayed payment (0.1% per day)
- Execute via treasury Operations budget
- Document incident for protocol improvement

#### Consensus Day Failure Recovery

**Scenario**: Consensus Day process fails mid-execution

**Recovery Options**:

**Option 1: Rollback and Retry**
\`\`\`bash
# If failure detected early (within 1 hour)
# Rollback to pre-Consensus Day state
etrid-cli governance rollback-consensus-day \
  --snapshot-block 1234567 \
  --requires-7-of-9-approval

# Schedule retry
etrid-cli governance schedule-consensus-day-retry \
  --date "2025-12-02" \
  --preserve-votes
\`\`\`

**Option 2: Manual Execution**
\`\`\`bash
# If Minting phase fails
etrid-cli governance manual-mint \
  --approved-proposals approved.json \
  --director-approvals 7-of-9

# If Distribution phase fails
etrid-cli governance manual-distribute \
  --rewards rewards.json \
  --verify-totals
\`\`\`

**Option 3: Emergency Governance**
\`\`\`bash
# If complete failure
# Activate emergency governance mode
etrid-cli governance activate-emergency-mode \
  --requires-7-of-9-directors

# Execute critical operations manually
# Schedule special Consensus Day retry
\`\`\`

#### Multi-Signature Transaction System

**Emergency Multi-Sig Setup**:
\`\`\`rust
// 9 Directors with 6-of-9 threshold (normal)
// 7-of-9 threshold for emergency actions

pub struct MultiSigConfig {
    pub signatories: Vec<AccountId>,  // 9 directors
    pub normal_threshold: u8,         // 6
    pub emergency_threshold: u8,      // 7
}

// Create multi-sig transaction
pub fn create_multisig_call(
    call: Box<RuntimeCall>,
    is_emergency: bool,
) -> MultiSigTransaction {
    let threshold = if is_emergency { 7 } else { 6 };

    MultiSigTransaction {
        call,
        threshold,
        approvals: Vec::new(),
        created_at: current_block,
        expires_at: current_block + EXPIRATION_BLOCKS,
    }
}
\`\`\`

**Multi-Sig Emergency Workflow**:
\`\`\`bash
# 1. Create emergency transaction
etrid-cli multisig create \
  --call "treasury.emergency_withdrawal" \
  --threshold 7 \
  --signatories director1,director2,...,director9

# 2. Directors sign (collect 7 signatures)
etrid-cli multisig sign \
  --tx-hash 0x1234... \
  --director-key /path/to/key1

# 3. Execute when threshold reached
etrid-cli multisig execute \
  --tx-hash 0x1234... \
  --verify-signatures 7

# 4. Broadcast to network
etrid-cli multisig broadcast \
  --tx-hash 0x1234... \
  --wait-for-finality
\`\`\`

**Security Considerations**:
- Directors use hardware wallets for signing
- Multi-geographic distribution of signers
- Time-locked execution for certain actions
- Transparent on-chain audit trail
- Social recovery mechanisms
- Regular key rotation procedures

---

### 6. MONITORING AND TRANSPARENCY

#### Real-Time Dashboards

**Treasury Dashboard** (\`treasury.etrid.org\`):
- Total treasury balance (√ãTR + EDSC)
- Budget allocations vs. spending
- Pending disbursement proposals
- Director voting records
- Historical funding sources
- Monthly/yearly spending reports

**Reserve Dashboard** (\`reserve.etrid.org\`):
- Current reserve composition
- Asset allocations vs. targets
- Rebalancing history
- Total reserve value (USD)
- Whitelisted assets
- Oracle price feeds

**EDSC Dashboard** (\`edsc.etrid.org\`):
- Current EDSC price
- Total supply and circulation
- Backing ratio (system-wide)
- Purchase/redemption volume history
- Active transaction count
- Recent large transactions
- Fee revenue (purchase + redemption)

**Circuit Breaker Dashboard** (\`safety.etrid.org\`):
- Current circuit status
- Hourly/daily volume metrics
- Reserve ratio trends
- Trigger count history
- Whitelisted accounts
- Recent status changes

#### On-Chain Transparency

All treasury and reserve operations emit detailed events:

\`\`\`rust
// Treasury Events
Event::FundsDeposited(source, amount)
Event::DisbursementProposed(id, proposer, category, amount, recipient)
Event::DisbursementApproved(id, director, approval_count)
Event::DisbursementExecuted(id, recipient, amount)
Event::EmergencyWithdrawal(amount, recipient, approvals)

// Reserve Events
Event::AssetAdded { asset_id, symbol }
Event::RebalanceTriggered { total_value, assets_count }
Event::ReserveValueUpdated { total_value_usd }

// EDSC Events
Event::EDSCMinted { who, collateral, edsc_amount, interest_rate }
Event::PositionLiquidated { owner, liquidator, edsc_amount, collateral_seized, penalty }
Event::InterestRateAdjusted { old_rate, new_rate, reason }

// Circuit Breaker Events
Event::StatusChanged { old_status, new_status }
Event::CircuitTriggered { reason }
Event::VolumeLimitExceeded { period, current_volume, max_volume }
\`\`\`

#### Audit Reports

**Quarterly Treasury Reports**:
- Total funds received (by source)
- Total funds disbursed (by category)
- Budget utilization rates
- Director approval statistics
- Emergency actions (if any)

**Annual Reserve Audit**:
- Asset holdings verification
- Rebalancing performance
- Oracle price accuracy
- Risk metrics analysis
- Recommendations for improvements

---

### 7. INTEGRATION WITH CONSENSUS DAY

The treasury and reserve systems integrate tightly with the annual Consensus Day governance process:

#### Budget Allocation Updates

During Consensus Day, the community votes on budget allocations:

\`\`\`rust
// After Consensus Day voting concludes:
pub fn update_allocations_from_consensus(
    approved_allocations: BudgetAllocations,
) -> DispatchResult {
    // Validate allocations sum to 100%
    ensure!(approved_allocations.is_valid(), Error::<T>::InvalidBudgetAllocations);

    // Update treasury allocations
    BudgetAllocationsStorage::<T>::put(approved_allocations.clone());

    Self::deposit_event(Event::BudgetAllocationsUpdated(approved_allocations));

    Ok(())
}
\`\`\`

#### Minting Phase Integration

Approved budgets are minted and allocated:

\`\`\`rust
// Called by pallet-consensus-day during Phase 3: Minting
pub fn receive_consensus_day_minting(amount: BalanceOf<T>) -> DispatchResult {
    // Mint to treasury
    let treasury_account = Self::account_id();
    T::Currency::deposit_creating(&treasury_account, amount);

    // Update balance
    TreasuryBalance::<T>::mutate(|balance| {
        *balance = balance.saturating_add(amount);
    });

    // Allocate to categories based on approved percentages
    Self::allocate_to_categories(amount)?;

    Ok(())
}
\`\`\`

#### Reserve Composition Updates

Community can vote to adjust EDSC reserve targets:

\`\`\`rust
// Consensus Day proposal to update reserve composition
pub fn update_target_composition(
    origin: OriginFor<T>,
    new_composition: ReserveComposition,
) -> DispatchResult {
    ensure_root(origin)?;  // Only via governance vote

    // Validate composition sums to 100%
    let total = new_composition.etr_allocation as u32
        + new_composition.sbtc_allocation as u32
        + new_composition.seth_allocation as u32
        + new_composition.other_allocation as u32;

    ensure!(total == 10000, Error::<T>::InvalidReserveComposition);

    TargetReserveComposition::<T>::put(new_composition.clone());

    // Trigger rebalancing to new targets
    Self::trigger_automatic_rebalance()?;

    Ok(())
}
\`\`\`

---

### 8. CONCLUSION

The treasury and reserve system implementation represents a comprehensive financial infrastructure for the √ãtrid protocol. Through four specialized pallets, the system provides:

- **Transparent Governance**: Multi-signature controls with 9 elected Directors
- **Fiscal Sustainability**: Multiple funding sources and disciplined budget management
- **Stablecoin Stability**: Multi-asset reserve backing with automatic rebalancing
- **Risk Management**: Circuit breaker protections and emergency response protocols

This infrastructure enables √ãtrid to operate as a truly self-governing, self-funding decentralized network without relying on centralized entities.

**System Status**: Production-ready (Q4 2025)
**Audit Status**: Pending external security audit
**Documentation**: Complete technical specifications available in pallet source code

---

*"Financial sovereignty begins with transparent, community-controlled treasury management."*

**‚Äì Treasury & Reserve System Implementation Team**
**√ãtrid Foundation**

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    },
    'charter': {
        title: '√ãTRID Protocol Charter',
        filename: 'protocol-charter.md',
        content: `# √ãTRID PROTOCOL CHARTER
## Free and Open Decentralized Democracy of Stakeholders (FODDoS)

**Version**: 1.0.0
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Last Updated**: October 30, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Immutable)

---

## I. PROTOCOL PREAMBLE

The **√ãTRID Multichain Protocol** is a decentralized, non-hierarchical blockchain system designed to resist centralization, censorship, and unilateral control. This charter establishes the immutable rules, governance structures, and technical specifications that define √ãTRID.

### Core Principles
1. **Decentralization**: No single entity controls the network
2. **Democracy**: All major decisions made via Consensus Day voting
3. **Transparency**: All code is GPLv3 open-source
4. **Immutability**: Once enshrined in this charter, rules cannot be broken without hard fork consensus
5. **Interoperability**: DETRP2P ensures coherent cross-chain communication

---

## II. PROTOCOL DEFINITION

### A. √ãTRID Multichain Architecture

**Hierarchical Parallel Chain Structure**:

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        FLARECHAIN (Root/Main Chain)                      ‚îÇ
‚îÇ  - World State Storage                                   ‚îÇ
‚îÇ  - Consensus Finality (ASF)                             ‚îÇ
‚îÇ  - Governance (Consensus Day)                           ‚îÇ
‚îÇ  - Foundation & DAO Operations                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚Üí PBC-EDSC (√ãtrid Dollar Stablecoin Chain)
         ‚îÇ   - EDSC token operations
         ‚îÇ   - Redemption engine (3-path)
         ‚îÇ   - Oracle system
         ‚îÇ   - State checkpoints to FlareChain
         ‚îÇ
         ‚îú‚îÄ‚Üí PBC-[Future] (Custom Partition Burst Chains)
         ‚îÇ   - Domain-specific sidechains
         ‚îÇ   - Isolated state, fast finality
         ‚îÇ   - Checkpoint-synced to FlareChain
         ‚îÇ
         ‚îî‚îÄ‚Üí Lightning Bloc Network (Micropayment Layer)
             - Off-chain state channels
             - Rapid settlement
             - Batch settlement to FlareChain
\`\`\`

### B. Essential Elements to Operate (E¬≥20)

The √ãTRID Protocol consists of 13 core subsystems:

| # | System | Purpose | Status |
|---|--------|---------|--------|
| 1 | DETR p2p | Multi-protocol P2P networking (S/Kademlia DHT, ECIES encryption) | ‚úÖ ACTIVE |
| 2 | OpenDID | Self-sovereign identity system (decentralized identifiers) | ‚úÖ ACTIVE |
| 3 | Blockchain Security | Post-quantum cryptography, hashing, signatures | ‚úÖ ACTIVE |
| 4 | Accounts | EBCA, RCA, RCWA, SCA, SSCA account types | ‚úÖ ACTIVE |
| 5 | Multichain | FlareChain + PBCs + State channels | ‚úÖ ACTIVE |
| 6 | Native Currency | √âTR (main), √ãDSC (stablecoin), VMw (computation gas) | ‚úÖ ACTIVE |
| 7 | Transactions | Regular, smart contract, cross-chain, stake-deposit | ‚úÖ ACTIVE |
| 8 | √ãtwasmVM | WASM-based smart contract runtime (Turing-complete) | ‚úÖ ACTIVE |
| 9 | Consensus | ASF (Ascending Scale of Finality) consensus algorithm | ‚úÖ ACTIVE |
| 10 | Foundation | DAO charter, governance, legal framework | üîÑ FINALIZING |
| 11 | Peer Roles | Flare Nodes, Validity Nodes, Common Peers, DDs | ‚úÖ ACTIVE |
| 12 | Governance | Consensus Day (annual vote), 9-person DD board | ‚úÖ ACTIVE |
| 13 | Clients | CLI, Web, Mobile wallet implementations | ‚úÖ ACTIVE |

---

## III. TOKEN ECONOMICS & NATIVE CURRENCY

### A. √âTR (√ãtrid Coin) - Primary Token

**Token Specifications**:
- **Symbol**: √âTR
- **Decimals**: 18
- **Initial Mint**: 1,000,000,000 √âTR (1 Billion)
- **Max Supply**: Determined by Consensus Day vote (no hard cap in code)
- **Distribution Method**: Annual Consensus Day fiscal mint vote

**Token Uses**:
- Payment for transactions and services
- Staking for validator participation (Flare/Validity Nodes)
- Voting in Consensus Day governance
- Distribution Pay rewards for network participation
- Collateral for √ãDSC stablecoin

### B. √ãDSC (√ãtrid Dollar Stablecoin)

**Stablecoin Specifications**:
- **Peg**: 1 √ãDSC = 1.00 USD (or IMF highest-ranked currency)
- **Total Supply**: 50 Billion √ãDSC
- **Initial Circulation**: 5 Billion √ãDSC
- **Locked Reserve**: 45 Billion √ãDSC (governed release)
- **Collateralization**: 110-130% overcollateralization
- **Reserve Backing**: Mix of on-chain (FlareChain vault) and custodian-held reserves

**√ãDSC Redemption Paths**:
1. **Path 1 - Treasury Reserve** (60% of redemptions): Direct withdrawal from FlareChain vault
2. **Path 2 - Custodian Redemption** (30%): BitGo/Anchorage Digital off-chain USD delivery
3. **Path 3 - DEX/AMM** (10%): Secondary market redemption via integrated DEX

**Dynamic Fee Schedule**:
- Base redemption fee: 0.25-10% (varies with reserve ratio)
- Higher fees when reserves < 100% collateral
- Lower fees when reserves > 120% collateral
- Emergency pause if reserves fall below 90% threshold

### C. VMw (Virtual Machine Watts) - Computation Gas

**Gas Token Specifications**:
- **Symbol**: VMw
- **Purpose**: Smart contract execution cost
- **1 VMw**: Computation cost equivalent to 1 watt-hour of compute
- **Conversion**: Market-based: ~0.001 √âTR = 1 VMw (adjustable via governance)
- **Burn**: All VMw consumed is permanently burned (deflationary)

**Gas Model**:
- Smart contract execution: Pay-per-opcode
- State storage writes: 64 VMw per 32-byte word
- Cross-chain messages: 256 VMw base + payload size
- No minimum gas price (set by validators, market-driven)

---

## IV. GOVERNANCE & CONSENSUS DAY PROTOCOL

### A. Consensus Day Schedule

**Annual Voting Event**:
- **Date**: December 1st (hardcoded, changes require hard fork)
- **Duration**: 24-hour voting window (Dec 1, 00:00-23:59 UTC)
- **Participation**: All Common Stake Peers (‚â•1 √âTR staked)
- **Voting Power**: Vote Weight = Stake / Vote Dilution
  - Vote Dilution = Total Network Stake / Coinage (average age of coins)

### B. Consensus Day Ballot & Voting

**Three Categories on Annual Ballot**:

1. **Fiscal Mint & Supply**
   - Vote on annual √âTR issuance amount
   - Top 3 proposals make final ballot
   - 3 economic limit options (min, mid, max supply)
   - Result becomes binding mint for next 12 months

2. **Decentralized Director Elections**
   - Vote for 9-person governance board (non-hierarchical)
   - Candidates must stake ‚â•128 √âTR
   - Candidates must meet "Honest Image" criteria
   - Elected DDs serve 1-year terms
   - Term limits: Maximum 3 consecutive terms

3. **Protocol Amendments**
   - Top 3 proposed changes make ballot
   - Requires ‚â•66% supermajority to pass
   - Changes take effect Jan 1st following vote
   - Major protocol changes: Additional 90-day audit period

### C. Decentralized Director (DD) Responsibilities

**9-Person Board Duties** (Non-Hierarchical):
- Oversee FlareChain operations and security
- Review and approve major protocol proposals
- Manage Foundation fund allocations
- Coordinate with custodians and validators
- Respond to security incidents
- Represent √ãTRID in legal/regulatory contexts

**DD Compensation**:
- Annual salary: X% of annual fiscal mint
- FLARE node operation rewards: Y% of block rewards
- Clawback provisions: Misconduct results in stake forfeiture

**DD Sanctions & Penalties**:
- Absentee voting (>2 missed Consensus Days): -25% compensation
- Misconduct: Full stake clawback + removal
- Security breach: Temporary suspension pending investigation

---

## V. PEER ARCHITECTURE & NODE TYPES

### A. Peer Categories

**1. Common Peers**
- Network users without staked √âTR
- Can create wallets, receive transfers
- Cannot vote or receive Distribution Pay
- Run light clients via DETRP2P

**2. Common Stake Peers**
- Hold ‚â•1 √âTR in active stake
- Full voting rights in Consensus Day
- Eligible for Distribution Pay rewards
- Can run full or light nodes

**3. Flare Nodes** (Finality Layer)
- Maintain FlareChain consensus
- Propagate blocks across network
- Optional stake participation (‚â•1 √âTR)
- Rewards: Z% of block production
- No minimum stake requirement to operate

**4. Validity Nodes** (Partition Burst Chains)
- Operate PBC sidechain consensus
- Propose and validate blocks
- **Minimum stake**: 64 √âTR per node
- Rotated in groups of 8 every 256 blocks (PPFA - Partition Proof of Authority)
- Rewards: W% of sidechain transaction fees

**5. Community Developers**
- Registered open-source contributors
- Eligible for bug bounties (0.1-10 √âTR per bug)
- Auditor payments: 50-500 √âTR per audit
- Track record pay scale: Veteran developers get priority allocation

---

## VI. DISTRIBUTION PAY SYSTEM

**Daily Distribution Schedule** (All times PST):

| Recipient | Time | Distribution Formula |
|-----------|------|----------------------|
| Registered Voting Peers | 12:01 AM | P% √ó √âTR / Diluted Vote % |
| FLARE Nodes | 4:01 AM | Z% √ó √âTR / Blocks / Year - Penalties |
| VALIDITY Nodes | 6:01 AM | W% √ó √âTR / PPFA Epoch - Penalties |
| Common Stake Peers | 8:01 AM | Q% √ó √âTR √ó Coinage / Stake |
| Decentralized Directors | 12:01 PM | (Z% FLARE Reward) + (V% DD Compensation) |

**Key Parameters** (Set by Consensus Day):
- P%, Z%, W%, Q%, V% = Annual percentages of fiscal mint
- All percentages total ‚â§100% of annual mint
- Penalties apply for non-compliance and security failures
- Penalty redistribution goes to compliant participants

---

## VII. EDSC (STABLECOIN) PROTOCOL SPECIFICATION

### A. EDSC on PBC-EDSC Chain

**Primary EDSC Operations**:
- **pallet-edsc-token**: Mint/burn authority for √ãDSC
- **pallet-edsc-receipts**: Issuance of Proof-of-Deposit SBTs (Soulbound Tokens)
- **pallet-edsc-redemption**: 3-path redemption engine
- **pallet-edsc-oracle**: TWAP price oracle (24h + 7d fallback)
- **pallet-edsc-checkpoint**: Sync state to FlareChain every N blocks
- **pallet-circuit-breaker**: Emergency pause system

### B. EDSC on FlareChain (Main Chain)

**Reserve & Custody Operations**:
- **pallet-reserve-vault**: On-chain collateral storage (already ‚úÖ)
- **pallet-custodian-registry**: Off-chain reserve tracking (already ‚úÖ)
- **pallet-reserve-oracle**: Reserve data aggregator (to build)

**Cross-Chain Synchronization**:
- PBC-EDSC checkpoints to FlareChain every 100 blocks
- Checkpoint contains: Total supply, reserve ratio, pending redemptions
- FlareChain validates checkpoint via 66% validator quorum
- Failure to validate triggers circuit breaker

### C. Oracle Price Feeds

**Primary Oracle Sources** (Minimum 5):
1. Binance API
2. Coinbase API
3. Kraken API
4. Bitstamp API
5. Gemini API

**Secondary Oracle Sources** (Future):
- Uniswap/PancakeSwap/Curve TWAP
- Hyperliquid (post-HyperEVM launch)
- Chainlink oracle (if available)

**Outlier Rejection**:
- If any price deviates >2% from median, mark as outlier
- Ignore top/bottom outliers before computing TWAP
- Staleness timeout: 100 blocks (marks oracle stale)

---

## VIII. LEGAL FRAMEWORK & FOUNDATION

### A. √ãTRID Foundation Structure

**Entity Type**: Delaware Non-Profit Corporation (or equivalent jurisdiction)

**Mission**: Facilitate √ãTRID peer network, enforce GPLv3 open-source license, execute governance decisions

**Governance**:
- Board of 9 Decentralized Directors (elected annually)
- Committees: Technical, Legal, Community, Security
- Annual budget: Funded by Consensus Day allocation

### B. Intellectual Property

**License**: GNU General Public License v3 (GPLv3)
- All code remains open-source in perpetuity
- Derivatives must also be open-source
- Commercial use allowed with proper attribution
- No patents filed; software remains patent-free

**Trademarks**:
- √ãTRID‚Ñ¢ is trademarked
- √ãDSC‚Ñ¢ is trademarked
- FODDoS‚Ñ¢ is trademarked
- All trademarks managed by Foundation

### C. Community Developer Agreements

**Contributor License Agreement (CLA)**:
- All contributors must sign CLA
- Contributions licensed under GPLv3
- Foundation gets perpetual license
- Contributor retains copyright

**Bug Bounty Program**:
- Low severity: 0.1-1 √âTR
- Medium severity: 1-5 √âTR
- High severity: 5-50 √âTR
- Critical severity: 50-500 √âTR
- Foundation Treasury funds bounties

---

## IX. SECURITY & NETWORK SAFETY

### A. Post-Quantum Cryptography

**Hash Functions**:
- SHA-3 (Keccak) for general hashing
- Blake2b for performance-critical paths

**Signatures**:
- EdDSA (Ed25519) for most signatures
- SPHINCS+ (lattice-based) for post-quantum resistance
- Hybrid approach during transition period

**Key Derivation**:
- HKDF-Blake2b for key derivation
- BIP39 mnemonic seed phrases (128-bit minimum)
- BIP44 hierarchical deterministic wallets

### B. Circuit Breaker System

**Automated Safety Mechanisms**:
- Reserve ratio drops below 100%: 50% redemption cap
- Reserve ratio drops below 90%: Full pause (emergency mode)
- Pending redemptions exceed 10,000: Throttle new redemptions
- Oracle staleness >100 blocks: Fallback to 7-day TWAP

**Manual Interventions** (DD-authorized only):
- Emergency pause requires 5/9 DD signatures
- Pause can last maximum 7 days
- Must notify community within 1 hour
- Post-pause audit required

### C. Penalty & Slashing System

**Validator Penalties**:
- Missing block proposal: 0.1% of annual stake
- Double-sign attempt: 1% of annual stake
- 3 consecutive slashes: Node removal for 1 year

**Voter Penalties**:
- Absentee voting (no vote cast): 0.05% annual stake
- Invalid vote submission: 0.1% annual stake
- Penalties redistributed to compliant voters

---

## X. TECHNICAL SPECIFICATIONS

### A. Network Parameters

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Block Time | 12 seconds | Balance between finality and throughput |
| Finality Time | ~5 minutes | ASF consensus with ~25 validators |
| Max Block Size | 4 MB | Substrate standard, flexible via governance |
| State Version | Substrate v27+ | Post-quantum ready |
| Network Port | 30333 (default) | Standard Substrate P2P |
| RPC Port | 9933 (default) | JSON-RPC endpoint |
| WS Port | 9944 (default) | WebSocket gateway |

### B. Account Specifications

**Account Types**:

1. **EBCA** (External Blockchain Account)
   - Any non-√ãTRID keypair
   - Generated outside √ãTRID Key Generation Protocol
   - Can receive but not validate
   - Example: MetaMask wallet, Ethereum address

2. **RCA** (Root Chain Account)
   - Generated by √ãTRID Key Generation Protocol
   - Valid on FlareChain only
   - Can vote, stake, validate

3. **SCA** (Side Chain Account)
   - Account on specific PBC
   - Different keypair per PBC allowed
   - Faster local transactions

4. **SSCA** (Smart Side Chain Account)
   - Automated smart contract accounts
   - Controlled by √ãtwasmVM logic
   - No private key (code-governed)

**Account Format**:
- SS58 address format (Substrate standard)
- Checksum included for typo detection
- Examples:
  - FlareChain: \`1XY...\` prefix
  - PBC-EDSC: \`3AB...\` prefix

### C. Transaction Fees

**Base Fee Structure**:
- Extrinsic encoding: 0.01 √âTR per kilobyte
- Byte multiplier: 0.001 √âTR per byte
- Weight multiplier: 0.00001 √âTR per weight unit
- Priority tip: Optional (for faster inclusion)

**Example Costs**:
- Simple transfer: ~0.1 √âTR
- Smart contract call: 1-100 √âTR (depends on complexity)
- Cross-chain message: 0.25-1 √âTR

**Fee Destination**:
- 80% to active validators
- 20% to Foundation treasury

---

## XI. DEPLOYMENT ROADMAP

### Phase 1: Core Infrastructure (Weeks 1-4) ‚úÖ COMPLETE
- ‚úÖ DETR p2p networking stack
- ‚úÖ OpenDID identity system
- ‚úÖ Core cryptography & security
- ‚úÖ FlareChain reference implementation

### Phase 2: Economics & Governance (Weeks 5-8) ‚úÖ COMPLETE
- ‚úÖ √âTR token implementation
- ‚úÖ Consensus Day voting system
- ‚úÖ Distribution Pay engine
- ‚úÖ DD election mechanism

### Phase 3: Stablecoins & EDSC (Weeks 9-16) ‚úÖ COMPLETE
- ‚úÖ pallet-edsc-token (core minting)
- ‚úÖ pallet-edsc-receipts (SBT system)
- ‚úÖ pallet-edsc-redemption (3-path engine)
- ‚úÖ pallet-edsc-oracle (TWAP pricing)
- ‚úÖ pallet-edsc-checkpoint (state sync)
- ‚úÖ pallet-circuit-breaker (safety controls)

### Phase 4: Partition Burst Chains (Weeks 17-20) ‚úÖ COMPLETE
- ‚úÖ Build custom PBC infrastructure
- ‚úÖ Implement PBC-specific governance
- ‚úÖ Deploy first community PBC

### Phase 5: Legal & DAO Registration (Weeks 21-24) ‚úÖ COMPLETE
- ‚úÖ Register √ãTRID Foundation (Delaware)
- ‚úÖ Finalize legal agreements
- ‚úÖ SEC/regulatory review (if applicable)

### Phase 6: Smart Contracts & √ãtwasmVM (Weeks 25-28) ‚úÖ COMPLETE
- ‚úÖ Deploy √ãtwasmVM runtime
- ‚úÖ Release smart contract toolkit
- ‚úÖ Community contract deployments

### Phase 7: AI Governance Integration (Weeks 29-32) ‚úÖ COMPLETE
- ‚úÖ pallet-ai-authority (AI node attestation)
- ‚úÖ pallet-attestation-verifier (AI proof verification)
- ‚úÖ pallet-poc-oracle (Proof-of-Computation oracle)

### Phase 8: Mainnet Launch (Week 32+) ‚úÖ COMPLETE
- ‚úÖ Full mainnet deployment
- ‚úÖ Token exchange listings
- ‚úÖ Foundation handoff to community DDs

---

## XII. PROTOCOL AMENDMENTS & HARD FORKS

### A. Amendment Process

**Soft Forks** (Governance-only, no code changes):
- Requires 50% + 1 consensus on Consensus Day ballot
- Takes effect Jan 1st following vote
- Examples: Adjust validator count, change oracle sources

**Hard Forks** (Code changes, consensus required):
- Requires 66% supermajority on Consensus Day ballot
- 90-day security audit period
- Community notice at least 30 days before deployment
- Validators must upgrade or fork off

**Emergency Hard Forks** (Security only):
- DD board (5/9 majority) can authorize emergency hard fork
- Requires 24-hour community vote confirmation
- Only for critical security vulnerabilities
- Post-fork audit mandatory

### B. Fork Management

**Version Numbers**:
- Major.Minor.Patch (e.g., 1.2.3)
- Major version: Hard fork or major protocol change
- Minor version: New features, soft fork
- Patch version: Bug fixes

**Rollback Procedures**:
- Validators can vote to rollback within 1 hour of fork
- Requires 66% consensus on rollback ballot
- State rolled back to pre-fork checkpoint

---

## XIII. CLOSING STATEMENT

The √ãTRID Protocol represents a fundamental reimagining of blockchain governance. By combining decentralized democracy (Consensus Day), non-hierarchical leadership (9-person DD board), and technical innovation (DETR p2p, ASF consensus, √´twasmVM), √ãTRID offers a genuine alternative to centralized or semi-centralized blockchain projects.

This charter establishes the immutable rules. Deviation requires consensus. Evolution is democratic. The network remains free and open, in perpetuity.

**"We are in a unique period in which power can be reclaimed by the powerless."**  
‚Äî Eoj Edred, √ãTRID Founder

---

## XIV. APPENDIX: ABBREVIATIONS & DEFINITIONS

| Abbreviation | Definition |
|--------------|-----------|
| **ASF** | Ascending Scale of Finality (consensus algorithm) |
| **DD** | Decentralized Director (board member) |
| **DETR p2p** | Decentralized, Encrypted, Trustless, Resilient Peer-to-Peer |
| **EBCA** | External Blockchain Account |
| **√ãDSC** | √ãtrid Dollar Stablecoin |
| **√âTR** | √ãtrid Coin (native token) |
| **E¬≥20** | Essential Elements to Operate (Reference Implementation) |
| **FODDoS** | Free and Open Decentralized Democracy of Stakeholders |
| **PPFA** | Partition Proof of Authority (8-validator rotation) |
| **PBC** | Partition Burst Chain (sidechain) |
| **RCA** | Root Chain Account |
| **SBT** | Soulbound Token (non-transferable) |
| **SCA** | Side Chain Account |
| **SSCA** | Smart Side Chain Account |
| **TWAP** | Time-Weighted Average Price |
| **√ãtwasmVM** | √ãtrid WebAssembly Virtual Machine |
| **VMw** | Virtual Machine Watts (computation gas) |

---

**END OF √ãTRID PROTOCOL CHARTER**

*This document is the source of truth for all √ãTRID development, governance, and deployment decisions. Changes require Consensus Day supermajority vote. Distributed under GPLv3 open-source license.*

`
    }
        };

    let base_reward = participation_pool * voter_share;
    let final_reward = base_reward * completeness_multiplier;

    Balance::from(final_reward as u128)
}
\`\`\`

**Distribution Components**:
1. **Participation Rewards**: 1% of minted tokens divided among voters
2. **Validator Rewards**: Validators receive 0.5% bonus for participation
3. **Proposer Rewards**: Approved proposals earn 100 √âTR per proposal
4. **Director Stipends**: 9 Directors receive equal shares (total: 0.2% of mint)

**Distribution Example**:

If 100M √âTR minted during Consensus Day:
\`\`\`
Total Minted:            100,000,000 √âTR
Participation Pool (1%):   1,000,000 √âTR ‚Üí Divided among voters
Validator Bonus (0.5%):      500,000 √âTR ‚Üí Divided among validators
Director Stipends (0.2%):    200,000 √âTR ‚Üí 22,222 √âTR per Director
Proposer Rewards:            100 √âTR √ó approved proposals
Remaining:               98,300,000 √âTR ‚Üí Treasury for budgets
\`\`\`

---

## 2. GOVERNANCE ROLES & RESPONSIBILITIES

### Role Hierarchy

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Community (All √âTR Holders)      ‚îÇ
‚îÇ  - Vote on proposals                        ‚îÇ
‚îÇ  - Elect Directors                          ‚îÇ
‚îÇ  - Propose changes (‚â•10k √âTR)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Directors   ‚îÇ   ‚îÇ    Validators    ‚îÇ
‚îÇ  (9 members) ‚îÇ   ‚îÇ  (Active Set)    ‚îÇ
‚îÇ  - Oversee   ‚îÇ   ‚îÇ  - Validate      ‚îÇ
‚îÇ  - Veto      ‚îÇ   ‚îÇ  - Secure        ‚îÇ
‚îÇ  - Emergency ‚îÇ   ‚îÇ  - Vote          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### The Community (Token Holders)

**Power**:
- Vote on all proposals during Consensus Day
- Elect 9 Decentralized Directors annually
- Propose protocol changes (requires ‚â•10,000 √âTR bond)
- Delegate voting power to trusted parties

**Responsibilities**:
- Participate in annual governance
- Review proposals and technical documentation
- Report bugs, vulnerabilities, exploits
- Contribute to ecosystem growth

**Rights**:
- Receive staking rewards
- Access to all governance decisions and data
- Freedom to fork the network (GPLv3)

### Decentralized Directors (The Board)

**Composition**: 9 individuals elected annually

**Requirements**:
- **Minimum stake: 128 √âTR**
- **Must serve as OD Flare Nodes** (Operational Director Flare Nodes)
- Must maintain active participation in network operations

**Term**: 1 year (renewable via re-election)

**Term Limits**:
- **One-year terms**
- **One-year cooldown** between terms
- **Maximum 3 lifetime terms** (cannot serve more than 3 total terms)

**Election Process**:
1. Candidates announce during Pre-Consensus Period (Jan 1 - Oct 31)
2. Community votes on Consensus Day (December 1)
3. Top 9 vote-getters elected
4. Ties resolved by stake-weighted runoff
5. Voting power = Staked √âTR √ó Coinage

**Powers**:
1. **Governance Oversight**: Oversee development and consensus proposals
2. **Protocol Maintenance**: Coordinate security audits, bug bounties
3. **Representation**: Speak for √ãtrid at conferences, media, partnerships
4. **Treasury Management**: Approve budget disbursements (community-authorized)
5. **Emergency Coordination**: Coordinate response to network emergencies

**Limitations**:
- Cannot change protocol without community consensus vote
- Cannot mint tokens outside Consensus Day
- **No hierarchy** among Directors - all decisions are community-driven
- Cannot override community supermajority
- Subject to term limits (max 3 lifetime terms)

**Compensation**:
- **Community-voted salaries** (determined annually on Consensus Day)
- No predetermined amounts - stakeholders decide compensation
- Funded from Consensus Day distribution

**Accountability**:
- Regular public reports required
- Can be removed mid-term via emergency community vote
- All communications public and logged
- Bound by Foundation bylaws

### VALIDITY Nodes (Validators)

**Role**: √ãtrid Partitioned Burst Chain nodes in consensus, syncing with Flare Chain. Responsible for block production, finality attestation, and cross-chain state verification.

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC
- Identity: Must verify on-chain identity (no KYC, just persistent identity)

**Node Statuses**:
- Registered
- Pending
- Sequenced
- Chilled
- De-Sequenced
- Re-Sequenced

**Rewards**:
\`\`\`rust
fn calculate_validator_reward(
    validator: &Validator,
    epoch_duration: BlockNumber,
    total_validator_pool: Balance,
) -> Balance {
    // Base reward proportional to stake
    let stake_ratio = validator.stake / total_active_stake();
    let base_reward = total_validator_pool * stake_ratio;

    // Uptime multiplier (0.90 - 1.10)
    let uptime_multiplier = 0.9 + (validator.uptime - 0.95).max(0.0) * 2.0;

    // Finality contribution (signed blocks / expected blocks)
    let finality_multiplier = validator.blocks_signed / validator.blocks_expected;

    // Final reward
    base_reward * uptime_multiplier * finality_multiplier
}
\`\`\`

**Slashing**:
- **Downtime**: -1% stake per day offline (after 24h grace period)
- **Equivocation**: -10% stake for double-signing blocks
- **Malicious Behavior**: -50% stake + removal for provable attacks
- **Censorship**: -5% stake for ignoring valid transactions

### Common Stake Peers

**Role**: Stakeholders who participate in governance without running full node infrastructure

**Requirements**:
- **Minimum stake: 1+ √âTR**

**Privileges**:
- Voting on proposals during Consensus Day
- Campaigning for proposals
- Reporting faults and issues
- Earning rewards based on stake, coinage, and activity

**Voting Power Formula**:
\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where coinage represents how long tokens have been staked (time-weighted stake)
- Must run full nodes for FlareChain + ‚â•3 PBCs
- Must respond to verification requests within 10 blocks

**Rewards**:
- 0.1% fee on all cross-chain transactions
- Proportional to verification work performed
- Paid from cross-chain transaction fees

**Slashing**:
- -20% stake for incorrect verification
- -50% stake for colluding to pass invalid proofs

### The Foundation (Pre-Mainnet Only)

**Role**: Bootstrap the network until first Consensus Day

**Powers**:
- Set initial parameters (inflation, fees, block times)
- Deploy initial infrastructure
- Fund initial development
- Conduct security audits

**Sunset Clause**:
- Foundation dissolves after first successful Consensus Day
- All remaining funds transferred to community treasury
- No ongoing authority or control

---

## 3. FISCAL CYCLE & TREASURY MANAGEMENT

### Treasury Architecture

**Treasury Account**: On-chain multisig controlled by 9 Directors (6-of-9 threshold)

**Funding Sources**:
1. **Transaction Fees**: 50% of all fees ‚Üí Treasury (50% burned)
2. **Consensus Day Minting**: Approved budgets minted to treasury
3. **Validator Slashing**: 50% of slashed stakes ‚Üí Treasury (50% burned)
4. **Cross-Chain Fees**: 10% of bridge fees ‚Üí Treasury

**Treasury Balance Formula**:
\`\`\`rust
fn calculate_treasury_balance() -> Balance {
    let inflows = transaction_fees * 0.5
                + consensus_day_mint
                + slashing_proceeds * 0.5
                + bridge_fees * 0.1;

    let outflows = budget_disbursements
                 + validator_rewards
                 + director_stipends
                 + emergency_expenses;

    previous_balance + inflows - outflows
}
\`\`\`

### Fiscal Year Cycle

**Fiscal Year**: December 1st ‚Üí November 30th (aligned with Consensus Day)

**Budget Categories**:
1. **Development** (40% of budget): Core protocol, tools, libraries
2. **Marketing** (20% of budget): Education, outreach, partnerships
3. **Operations** (15% of budget): Infrastructure, monitoring, support
4. **Grants** (15% of budget): Community projects, research, ecosystem
5. **Emergency Reserve** (10% of budget): Held for crisis response

**Budget Approval Process**:
1. **Consensus Day**: Community votes on budget allocation per category
2. **Director Oversight**: Directors approve individual disbursements
3. **Quarterly Review**: Directors publish spending reports every 3 months
4. **Annual Audit**: Third-party audit published before next Consensus Day

### Treasury Transparency

**All treasury actions emit events**:
\`\`\`rust
enum TreasuryEvent {
    Deposit { source: DepositSource, amount: Balance },
    Disbursement { category: BudgetCategory, recipient: AccountId, amount: Balance },
    DirectorVote { director: AccountId, proposal_id: u64, vote: bool },
    QuarterlyReport { quarter: u8, total_spent: Balance, category_breakdown: Vec<(BudgetCategory, Balance)> },
}
\`\`\`

**Public Dashboard**:
- Real-time treasury balance
- All incoming/outgoing transactions
- Budget vs. actual spending per category
- Director voting records
- Historical trends (YoY comparison)

### Mint and Burn Dynamics

**Minting Events**:
1. **Consensus Day**: Annual minting for approved budgets
2. **Emergency Minting**: Directors can mint (7/9 vote) in crisis (max 1% of supply)

**Burning Events**:
1. **Transaction Fees**: 50% of all fees burned
2. **Validator Slashing**: 50% of slashed stakes burned
3. **Deflationary Votes**: Community can vote to burn treasury reserves

**Net Supply Formula**:
\`\`\`rust
fn calculate_net_supply_change(epoch: Epoch) -> i128 {
    let minted = consensus_day_mint + emergency_mint;
    let burned = transaction_fees * 0.5 + slashing_proceeds * 0.5 + voluntary_burns;

    (minted as i128) - (burned as i128)
}
\`\`\`

**Target**: Long-term supply should stabilize or decrease slowly (deflationary tendency)

---

## 4. TOKEN ECONOMICS (√âTR, EDSC, VMw)

### √âTR (√ãtrid Token)

**Purpose**: Governance, staking, gas fees

**Total Supply**: 1 Billion √âTR (initial), subject to inflation/deflation

**Initial Distribution**:
\`\`\`
Genesis Block:           1,000,000,000 √âTR

Allocation:
- Public Sale (40%):       400,000,000 √âTR
- Foundation (25%):        250,000,000 √âTR (4-year vesting)
- Team (15%):              150,000,000 √âTR (3-year vesting)
- Validators (10%):        100,000,000 √âTR (incentive pool)
- Ecosystem Grants (10%):  100,000,000 √âTR (unlocked)
\`\`\`

**Inflation/Deflation**:
- **Inflation**: Voted annually (0-5% cap), minted on Consensus Day
- **Deflation**: Transaction fees + slashing continuously burned
- **Net Effect**: Tends toward slight deflation long-term

**Use Cases**:
1. **Staking**: Lock √âTR to become validator or voter
2. **Gas Fees**: Pay for transactions (measured in VMw, priced in √âTR)
3. **Governance**: Vote on proposals during Consensus Day
4. **Reserve Asset**: Held in multi-asset treasury backing EDSC stablecoin

### EDSC (√ãtrid Dollar Stablecoin)

**Purpose**: Stable unit of account for payments, contracts

**Peg**: $1.00 USD (maintained by direct reserve buy/sell + arbitrage)

**Backing Model**: Treasury-backed with 100% backing from organic purchases (no pre-funding required)

**Reserve Infrastructure**:

EDSC is backed by a diversified multi-asset reserve managed through two specialized pallets:

1. **pallet-multiasset-reserve**: Manages reserve composition and automated rebalancing
2. **pallet-reserve-backed-token**: Handles EDSC purchase/redemption and reserve management

**Reserve Composition**:
\`\`\`
Target Allocation (accumulates organically from purchases):
- 30% USDC (stablecoin purchases)
- 25% ETH (bridged from ETH-PBC)
- 20% BTC (bridged from BTC-PBC)
- 15% SOL (bridged from SOL-PBC)
- 10% Other assets (governance-approved)

Rebalancing:
- Triggered when deviation exceeds 5%
- Automated via pallet-multiasset-reserve
- Governance can adjust allocation strategy
\`\`\`

**Allocation Strategies**:
- **EqualWeight**: Equal distribution across all reserve assets
- **MarketCapWeighted**: Weight by market capitalization
- **RiskAdjusted**: Weight by volatility/risk metrics
- **Custom**: Custom weights set by governance vote

**Purchase Process**:
\`\`\`rust
fn purchase_edsc(
    payment_token: AssetId,
    payment_amount: Balance
) -> Result<Balance, Error> {
    // Get payment token price from oracle
    let token_price_usd = oracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price_usd;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd; // 1 EDSC = $1.00

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * 10 / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    transfer_to_reserve(caller, payment_token, payment_amount)?;

    // Release EDSC from reserve vault to buyer
    release_from_vault(caller, net_edsc)?;

    // Reserve automatically rebalances if needed
    if should_rebalance() {
        trigger_rebalance()?;
    }

    Ok(net_edsc)
}
\`\`\`

**Redemption Process**:
\`\`\`rust
fn redeem_edsc(
    edsc_amount: Balance,
    preferred_payment: AssetId
) -> Result<Balance, Error> {
    // Burn EDSC from user
    burn_edsc(caller, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * 10 / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price
    let token_price = oracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    transfer_from_reserve(caller, preferred_payment, payment_amount)?;

    Ok(payment_amount)
}
\`\`\`

**Treasury-Backed Parameters**:
\`\`\`
Target Backing Ratio:    100% (purchase value)
Purchase Price:          $1.00 per EDSC
Redemption Price:        $1.00 per EDSC
Purchase Fee:            0.1% (goes to treasury)
Redemption Fee:          0.1% (goes to treasury)

Example:
User purchases 1000 EDSC with USDC:
‚Üí User sends: 1000 USDC ($1000)
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: 1000 USDC backing
‚Üí Backing ratio: 100% ($1000 backing 999 circulating EDSC)
\`\`\`

**Stability Mechanisms**:
1. **Multi-Asset Reserve**: Reduces correlation risk compared to single-asset backing
2. **Automated Rebalancing**: Maintains target allocations via pallet-multiasset-reserve
3. **Direct Purchase/Redemption**: Reserve always buys/sells at $1.00, maintaining peg
4. **Organic Backing**: 100% backing accumulates from user purchases (no pre-funding)
5. **Purchase/Redemption Fees**: 0.1% fees prevent spam while generating treasury revenue
6. **No Liquidations**: Simple buy/sell model eliminates liquidation risk
7. **Arbitrage**: Price deviations create profitable arbitrage opportunities
8. **DEX Integration**: FlareSwap enables efficient √âTR/EDSC trading and price discovery

**Reserve-Backed Token Framework**:

Beyond EDSC, the reserve infrastructure enables creation of diverse synthetic assets:

**Synthetic Asset Types**:
- **Stablecoins**: EDSC (USD), EEUR (Euro), EGBP (Pound)
- **Commodities**: EXAU (Gold), EXAG (Silver), EXOIL (Oil)
- **Equities**: ETSLA (Tesla), EAAPL (Apple), EGOOG (Google)
- **Indices**: ES&P (S&P 500), ENASDAQ (Nasdaq), EDJI (Dow Jones)

**Governance Controls**:
- Whitelisting of reserve assets (Consensus Day vote required)
- Adjustment of backing ratios per synthetic
- Rebalancing strategy selection
- Emergency pause of purchase/redemption

### VMw (Virtual Machine Watts)

**Purpose**: Measure computational cost (gas metering)

**Definition**: 1 VMw = 1 Watt-second of CPU energy

**Pricing**:
\`\`\`rust
fn calculate_gas_price() -> Balance {
    // Dynamic pricing based on block fullness
    let block_utilization = current_block_vmw / max_block_vmw; // 0.0 - 1.0

    // Base price: 1 VMw = 0.000001 √âTR
    let base_price = 1_000_000_000_000u128; // 1e-6 √âTR in plancks

    // Price increases exponentially with utilization
    let surge_multiplier = if block_utilization > 0.75 {
        1.0 + ((block_utilization - 0.75) * 8.0)
    } else {
        1.0
    };

    Balance::from((base_price as f64 * surge_multiplier) as u128)
}
\`\`\`

**Block Limits**:
- **Max VMw per block**: 10,000,000 VMw
- **Target utilization**: 50% (5,000,000 VMw)
- **Surge pricing**: Kicks in above 75% utilization

**Example Transaction Costs**:
\`\`\`
Simple Transfer:           100 VMw   ‚âà 0.0001 √âTR   ($0.001 at $10/√âTR)
Token Swap:              5,000 VMw   ‚âà 0.005 √âTR    ($0.05)
Complex Contract:       50,000 VMw   ‚âà 0.05 √âTR     ($0.50)
Cross-Chain Bridge:    200,000 VMw   ‚âà 0.2 √âTR      ($2.00)
\`\`\`

---

## 5. PROPOSAL SYSTEM & VOTING MECHANISMS

### Proposal Lifecycle

\`\`\`
1. Draft ‚Üí 2. Submission ‚Üí 3. Discussion ‚Üí 4. Voting ‚Üí 5. Execution
   (Off-chain)  (Registration)   (48h window)    (12h vote)   (Minting + Distribution)
\`\`\`

### Proposal Template

**Minimum Requirements**:
\`\`\`markdown
# Proposal Title (max 100 chars)

## Summary (max 300 chars)
One-paragraph overview accessible to all voters.

## Motivation
Why is this proposal necessary? What problem does it solve?

## Specification
Technical details. How will this be implemented?

## Budget Request (if applicable)
Amount: _______ √âTR
Breakdown:
  - Development: _______ √âTR
  - Audit: _______ √âTR
  - Deployment: _______ √âTR

## Implementation Timeline
Phase 1: (date range) - Milestone 1
Phase 2: (date range) - Milestone 2
...

## Success Criteria
How will we know this proposal succeeded?

## Risks & Mitigations
What could go wrong? How will we address it?

## Supporting Validators (min 3)
- Validator 1: [address]
- Validator 2: [address]
- Validator 3: [address]
\`\`\`

### Voting Rules

**Vote Types**:
1. **Yes**: Support the proposal
2. **No**: Reject the proposal
3. **Abstain**: Count toward quorum but not approval

**Quadratic Voting** (Optional, for contentious issues):
\`\`\`rust
fn calculate_quadratic_vote_cost(num_votes: u32) -> Balance {
    // Cost increases quadratically
    // 1 vote = 1 √âTR, 2 votes = 4 √âTR, 3 votes = 9 √âTR, etc.
    let cost_per_vote = num_votes * num_votes;
    Balance::from(cost_per_vote as u128 * VOTE_COST_BASE)
}
\`\`\`

**Conviction Voting** (Optional, for long-term decisions):
\`\`\`rust
enum Conviction {
    None,       // 1x voting power, unlock immediately
    Locked1x,   // 1x voting power, locked 1 epoch after vote
    Locked2x,   // 2x voting power, locked 2 epochs
    Locked4x,   // 4x voting power, locked 4 epochs
    Locked8x,   // 8x voting power, locked 8 epochs
}
\`\`\`

### Proposal Execution

**Automatic Execution**:
- If proposal approved with quorum ‚Üí Executed in Phase 3 (Minting)
- If proposal rejected ‚Üí Bond returned (if >5% quorum), proposal archived
- If proposal doesn't reach quorum ‚Üí Bond slashed, proposal discarded

**Manual Execution** (for protocol upgrades):
- Directors + validators coordinate deployment
- Upgrade scheduled for specific block height
- All nodes must upgrade before deadline

---

## 6. REWARD DISTRIBUTION & SLASHING

### Validator Rewards

**Annual Validator Reward Pool**: ~3% of circulating supply

**Distribution**:
\`\`\`rust
fn distribute_epoch_rewards(epoch: Epoch) {
    let total_pool = circulating_supply() * 0.03 / EPOCHS_PER_YEAR;

    for validator in active_validators() {
        let base_reward = total_pool * (validator.stake / total_stake);
        let adjusted_reward = base_reward * validator.performance_multiplier;

        // Pay 50% to validator, 50% to delegators
        pay_reward(validator.account, adjusted_reward * 0.5);
        pay_delegators(validator, adjusted_reward * 0.5);
    }
}
\`\`\`

**Performance Multiplier**:
\`\`\`rust
fn calculate_performance_multiplier(validator: &Validator) -> f64 {
    let uptime_score = validator.uptime; // 0.0 - 1.0
    let finality_score = validator.blocks_signed / validator.blocks_expected;
    let participation_score = if validator.voted_consensus_day { 1.1 } else { 1.0 };

    uptime_score * finality_score * participation_score
}
\`\`\`

### Delegator Rewards

**Delegation Mechanism**:
- Token holders can delegate √âTR to validators
- Validators charge commission (0-100%, set by validator)
- Rewards automatically distributed each epoch

**Commission Structure**:
\`\`\`rust
fn distribute_delegation_rewards(validator: &Validator, total_reward: Balance) {
    let commission_rate = validator.commission; // e.g., 0.10 = 10%
    let commission_amount = total_reward * commission_rate;
    let delegator_pool = total_reward - commission_amount;

    // Pay commission to validator
    pay_reward(validator.account, commission_amount);

    // Distribute remaining to delegators proportionally
    for delegator in validator.delegators() {
        let delegator_share = delegator.stake / validator.total_delegated;
        let delegator_reward = delegator_pool * delegator_share;
        pay_reward(delegator.account, delegator_reward);
    }
}
\`\`\`

### Slashing Conditions

**Offense Types**:

| Offense | Severity | Slash Amount | Cooldown |
|---------|----------|--------------|----------|
| Downtime (>24h) | Low | 1% per day | 7 days |
| Missed blocks (>10%) | Low | 0.5% | 3 days |
| Equivocation (double-sign) | High | 10% | 30 days |
| Invalid finality vote | High | 5% | 14 days |
| Censorship (provable) | Medium | 5% | 14 days |
| Coordinated attack | Critical | 50% + removal | Permanent ban |

**Slashing Execution**:
\`\`\`rust
fn execute_slash(
    validator: AccountId,
    offense: OffenseType,
    evidence: Vec<u8>,
) -> Result<(), Error> {
    // Verify evidence
    verify_offense_evidence(offense, evidence)?;

    // Calculate slash amount
    let slash_amount = match offense {
        OffenseType::Downtime => validator.stake * 0.01,
        OffenseType::Equivocation => validator.stake * 0.10,
        OffenseType::MaliciousAttack => validator.stake * 0.50,
        // ... other offenses
    };

    // Execute slash
    burn_tokens(validator, slash_amount * 0.5); // 50% burned
    transfer_to_treasury(slash_amount * 0.5);   // 50% to treasury

    // Apply cooldown
    apply_validator_cooldown(validator, offense.cooldown_period);

    // Emit event
    emit_event(Event::ValidatorSlashed {
        validator,
        offense,
        amount: slash_amount,
        timestamp: current_block(),
    });

    Ok(())
}
\`\`\`

### Appeal Process

**Validators can appeal slashing**:
1. Submit appeal within 72 hours (costs 1,000 √âTR bond)
2. Directors review evidence (7/9 vote required to overturn)
3. If appeal successful: slash reversed, bond returned
4. If appeal rejected: bond added to treasury

---

## 7. ECONOMIC SUSTAINABILITY MODEL

### Long-Term Supply Dynamics

**Target**: Slightly deflationary long-term (~1% annual deflation)

**Inflows** (Minting):
- Consensus Day approved budgets: 0-5% per year (voted)
- Emergency minting: <0.1% per year (rare)

**Outflows** (Burning):
- Transaction fees: ~50% of fees (continuous)
- Slashing: ~50% of slashed stakes (episodic)
- Voluntary burns: Community-voted (rare)

**Net Supply Projection**:
\`\`\`
Year 1:  1.00B √âTR (genesis)
Year 2:  1.02B √âTR (+2% voted inflation - 1% burned = +1% net)
Year 3:  1.03B √âTR (+2% inflation - 1.5% burned = +0.5% net)
Year 5:  1.04B √âTR (+1.5% inflation - 2% burned = -0.5% net)
Year 10: 1.00B √âTR (back to genesis, deflationary equilibrium)
\`\`\`

### Fee Market Dynamics

**Transaction Fee Formula**:
\`\`\`rust
fn calculate_transaction_fee(vmw_cost: u64, priority: Priority) -> Balance {
    let base_fee = vmw_cost * get_current_vmw_price(); // Dynamic pricing

    let priority_multiplier = match priority {
        Priority::Low => 0.8,
        Priority::Normal => 1.0,
        Priority::High => 1.5,
        Priority::Urgent => 3.0,
    };

    base_fee * priority_multiplier
}
\`\`\`

**Fee Allocation**:
- 50% burned (deflationary pressure)
- 40% to validators (reward for block production)
- 10% to treasury (public goods funding)

### Economic Security

**Attack Cost Analysis**:

To attack √ãtrid, an adversary must:
1. Acquire >33% of staked √âTR (to disrupt finality)
2. Operate attack for multiple epochs before detection
3. Survive slashing and social coordination against them

**Cost**:
\`\`\`
Assume 40% of supply staked (400M √âTR)
33% of staked = 132M √âTR
At $10/√âTR = $1.32 Billion capital requirement

Cost of attack:
- Capital cost: $1.32B
- Slashing risk: 50% = $660M loss if caught
- Opportunity cost: 8% APY = $105M/year forgone rewards
- Reputation cost: √âTR price crash ‚Üí total loss

Total cost: >$2 Billion for 51% attack
\`\`\`

**Conclusion**: Economic security increases with network value and participation

---

## 8. EMERGENCY PROCEDURES & CRISIS RESPONSE

### Emergency Powers

**Directors Emergency Authority** (7-of-9 vote):
1. **Pause Chains**: Temporarily halt block production (max 72 hours)
2. **Emergency Upgrade**: Deploy hotfix without Consensus Day vote
3. **Slash Malicious Actors**: Immediate slashing for provable attacks
4. **Emergency Mint**: Mint up to 1% of supply for critical bug bounty

### Crisis Response Protocol

**Level 1: Minor Issue** (e.g., validator downtime spike)
- Response Team: On-call validators
- Action: Monitor, alert community
- Timeline: 24-hour resolution

**Level 2: Moderate Issue** (e.g., smart contract exploit)
- Response Team: Directors + Security Team
- Action: Pause affected pallets, deploy patch
- Timeline: 48-hour resolution

**Level 3: Critical Issue** (e.g., consensus failure)
- Response Team: All Directors + Core Developers + Community
- Action: Emergency governance vote, possible chain halt
- Timeline: Immediate action, 7-day resolution

### Social Recovery

**If network becomes compromised beyond repair**:
1. **Snapshot**: Take state snapshot at last known good block
2. **Fork**: Create new chain from snapshot
3. **Migrate**: Community coordinates migration to new chain
4. **Deprecate**: Old chain deprecated, new chain becomes canonical

**GPLv3 Protection**: Anyone can fork and continue the network

---

## 9. CONCLUSION: GOVERNANCE AS A LIVING SYSTEM

### Why This Model Works

1. **Alignment**: Token holders, validators, and users all benefit from network success
2. **Adaptation**: Annual Consensus Day forces regular evolution
3. **Transparency**: All decisions on-chain, all treasury actions public
4. **Resilience**: No single point of failure, multiple layers of accountability
5. **Sustainability**: Self-funding via fees, deflationary tendency prevents inflation

### Comparison to Other Models

| Feature | √ãtrid | Bitcoin | Ethereum | Polkadot |
|---------|-------|---------|----------|----------|
| **Governance** | On-chain annual vote | Off-chain (BIPs) | Off-chain (EIPs) | On-chain (referenda) |
| **Treasury** | Autonomous | None | Foundation-controlled | Autonomous |
| **Inflation** | Voted (0-5%) | Fixed (halving) | Fixed (~1%) | Fixed (~10%) |
| **Participation** | >33% quorum | N/A | ~5% typical | ~10% typical |
| **Emergency Powers** | Directors (7/9) | None | Foundation | Council |

### The Path to Sovereignty

√ãtrid governance is designed to achieve **true decentralization** through:
- **Economic incentives** (rewards for participation)
- **Social accountability** (transparent decisions, elected directors)
- **Technical constraints** (protocol-enforced caps, slashing)
- **Regular rhythm** (annual Consensus Day prevents drift)

**The goal**: A network that governs itself, funds itself, and evolves without relying on any central authority.

---

## APPENDIX A: Consensus Day Checklist

**For Voters**:
- [ ] Review all proposals (published 7 days before Consensus Day)
- [ ] Lock √âTR during Registration Phase (6 hours)
- [ ] Vote on all proposals during Voting Phase (12 hours)
- [ ] Claim participation rewards during Distribution Phase (1 hour)

**For Validators**:
- [ ] Signal participation during Registration Phase
- [ ] Vote on all proposals during Voting Phase
- [ ] Monitor network health during Minting Phase
- [ ] Verify reward distribution during Distribution Phase

**For Directors**:
- [ ] Review all proposals and publish recommendations
- [ ] Monitor quorum and voting during Voting Phase
- [ ] Execute approved budgets during Minting Phase
- [ ] Verify distribution accuracy during Distribution Phase

---

## APPENDIX B: Governance Formulas

### Quorum Calculation
\`\`\`rust
fn quorum_met(proposal: &Proposal) -> bool {
    let community_votes = proposal.total_votes;
    let validator_votes = proposal.validator_count;

    (community_votes >= circulating_supply() * 0.33) &&
    (validator_votes >= active_validator_count() * 0.51)
}
\`\`\`

### Approval Calculation
\`\`\`rust
fn proposal_approved(proposal: &Proposal) -> bool {
    let yes_votes = proposal.yes_votes;
    let total_votes = proposal.yes_votes + proposal.no_votes; // Abstain doesn't count

    let threshold = match proposal.category {
        ProposalCategory::BudgetAllocation => 0.50,
        ProposalCategory::ParameterChange => 0.50,
        ProposalCategory::ProtocolUpgrade => 0.66,
        ProposalCategory::EmergencyAction => 0.66,
    };

    (yes_votes as f64 / total_votes as f64) >= threshold
}
\`\`\`

---

## APPENDIX C: Further Reading

**Volume I**: Conceptual Architecture (Vision, Problem, Solution, Philosophy)
**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime)

**Online Resources**:
- Governance Portal: governance.etrid.org
- Proposal Archive: proposals.etrid.org
- Treasury Dashboard: treasury.etrid.org

---

**End of Volume III**

**√ãtrid Ivory Papers Complete**

---

*"Governance is not a feature to be added. It is the fundamental architecture of coordination."*

---

**Document Status**: ACTIVE PROTOCOL SPECIFICATION
**Next Review**: Consensus Day 2026 (December 1, 2026)

---

## ADDENDUM: TREASURY AND RESERVE SYSTEM IMPLEMENTATION (2025)

### Overview

Following the specifications outlined in this volume, the √ãtrid protocol has implemented a comprehensive treasury and reserve system through four specialized pallets. This addendum documents the technical implementation details, operational procedures, and emergency protocols for these critical financial infrastructure components.

**Implementation Status**: ACTIVE (Deployed Q4 2025)
**Pallet Locations**: \`/Users/macbook/Desktop/etrid/src/pallets/\`

---

### 1. PALLET-TREASURY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-treasury/src/lib.rs\`

The treasury pallet implements the protocol's fiscal management system with multi-signature governance controls.

#### Multisig Architecture

**Configuration**:
- **Directors**: 9 elected representatives (via Consensus Day)
- **Normal Operations**: 6-of-9 approval threshold
- **Emergency Actions**: 7-of-9 approval threshold
- **Term Length**: 1 year (renewable via re-election)

**Director Requirements**:
\`\`\`rust
// Minimum stake: 128 √ãTR
// Must serve as OD Flare Nodes
// Subject to term limits (max 3 lifetime terms)
// One-year cooldown between terms
\`\`\`

**Multisig Controls**:
\`\`\`rust
pub struct Disbursement<T: Config> {
    pub id: u64,
    pub category: BudgetCategory,
    pub recipient: T::AccountId,
    pub amount: BalanceOf<T>,
    pub proposer: T::AccountId,
    pub status: DisbursementStatus,
    pub approval_count: u8,
    pub is_emergency: bool,  // Requires 7/9 instead of 6/9
}
\`\`\`

#### Budget Categories

Default allocations (modifiable via Consensus Day governance):

\`\`\`rust
pub struct BudgetAllocations {
    pub development_bps: u32,      // 40% (4000 basis points)
    pub marketing_bps: u32,        // 20% (2000 basis points)
    pub operations_bps: u32,       // 15% (1500 basis points)
    pub grants_bps: u32,           // 15% (1500 basis points)
    pub emergency_reserve_bps: u32, // 10% (1000 basis points)
}
\`\`\`

**Budget Category Details**:

1. **Development (40%)**:
   - Core protocol development
   - Research and innovation
   - Infrastructure improvements
   - Security audits and bug bounties

2. **Marketing (20%)**:
   - Community growth initiatives
   - Partnership development
   - Educational content
   - Brand awareness campaigns

3. **Operations (15%)**:
   - Team salaries (community-voted)
   - Legal and compliance
   - Administrative expenses
   - Operational infrastructure

4. **Grants (15%)**:
   - Ecosystem development grants
   - Developer support programs
   - Research initiatives
   - Community projects

5. **Emergency Reserve (10%)**:
   - Locked for critical situations
   - Requires 7-of-9 approval for access
   - Protocol security responses
   - Network stability measures

#### Disbursement Workflow

**Step 1: Proposal**
\`\`\`rust
// Any director can propose disbursement
pub fn propose_disbursement(
    origin: OriginFor<T>,
    category: BudgetCategory,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult
\`\`\`

**Step 2: Approval**
\`\`\`rust
// Other directors vote (need 6 total approvals, 7 for emergency)
pub fn approve_disbursement(
    origin: OriginFor<T>,
    disbursement_id: u64,
) -> DispatchResult
\`\`\`

**Step 3: Automatic Execution**
\`\`\`rust
// Executes automatically when threshold reached
if disbursement.approval_count >= threshold {
    Self::execute_disbursement_internal(disbursement_id)?;
}
\`\`\`

**Safeguards**:
- Proposals expire after 7 days if quorum not reached
- Directors cannot approve same proposal twice
- Category allocations checked before disbursement
- All actions emit transparent on-chain events

#### Emergency Withdrawal Procedures

Emergency withdrawals require heightened security:

\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals (higher threshold)
    // Can only withdraw from EmergencyReserve
    // Used for critical protocol emergencies
}
\`\`\`

**Emergency Scenarios**:
- Critical security vulnerabilities
- Protocol-threatening exploits
- Network stability emergencies
- Consensus failure recovery

#### Funding Source Integration

The treasury receives funds from multiple sources:

\`\`\`rust
pub enum FundingSource {
    TransactionFees,      // 50% of all transaction fees
    ConsensusDayMinting,  // Approved budgets from annual vote
    ValidatorSlashing,    // 50% of slashing penalties
    CrossChainFees,       // 10% of bridge transaction fees
    Other,                // Donations, etc.
}
\`\`\`

**Funding Flow Example**:
\`\`\`
Transaction: 1000 √ãTR fee collected
‚Üí 50% (500 √ãTR) burned (deflationary)
‚Üí 40% (400 √ãTR) to validators
‚Üí 10% (100 √ãTR) to treasury

Consensus Day: 100M √ãTR minted
‚Üí 98.3M to treasury for budgets
‚Üí 1.0M to participation rewards
‚Üí 0.5M to validator bonuses
‚Üí 0.2M to director stipends
\`\`\`

#### Storage Items

**Core Storage**:
\`\`\`rust
/// Total √ãTR balance in treasury
TreasuryBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// EDSC stablecoin balance
EdscBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Budget allocation percentages
BudgetAllocationsStorage<T: Config> = StorageValue<_, BudgetAllocations>

/// Category-specific allocated amounts
CategoryAllocations<T: Config> = StorageMap<_, BudgetCategory, BalanceOf<T>>

/// Pending and historical disbursements
Disbursements<T: Config> = StorageMap<_, u64, Disbursement<T>>

/// Director approvals per disbursement
DirectorApprovals<T: Config> = StorageMap<_, u64, BoundedVec<T::AccountId, ConstU32<9>>>

/// Current 9 directors
Directors<T: Config> = StorageValue<_, BoundedVec<T::AccountId, ConstU32<9>>>

/// Emergency reserve balance
EmergencyReserve<T: Config> = StorageValue<_, BalanceOf<T>>
\`\`\`

#### Extrinsics

**Public Functions**:
\`\`\`rust
// Fund treasury from various sources
fund_treasury(source: FundingSource, amount: Balance)

// Director proposes spending
propose_disbursement(category, recipient, amount, description)

// Director approves proposal (6/9 needed)
approve_disbursement(disbursement_id)

// Emergency reserve access (7/9 needed)
emergency_withdrawal(recipient, amount, description)
\`\`\`

**Governance Functions** (Root/Consensus Day only):
\`\`\`rust
// Update budget percentages
set_budget_allocations(allocations: BudgetAllocations)

// Allocate funds to categories
allocate_to_categories(total_amount: Balance)

// Add/remove directors
add_director(director: AccountId)
remove_director(director: AccountId)
\`\`\`

---

### 2. PALLET-MULTIASSET-RESERVE IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-multiasset-reserve/src/lib.rs\`

The multiasset reserve pallet enables diversified reserve management with automatic rebalancing capabilities.

#### Multi-Asset Reserve Management

**Asset Configuration**:
\`\`\`rust
pub struct AssetMetadata {
    pub symbol: BoundedVec<u8, ConstU32<16>>,  // BTC, ETH, etc.
    pub decimals: u8,
    pub is_active: bool,
    pub min_holding: u128,
    pub max_holding: u128,
    pub target_allocation: Permill,
    pub last_rebalance: u32,
}
\`\`\`

**Reserve Composition**:
\`\`\`rust
pub struct AssetHolding {
    pub asset_id: u32,
    pub amount: u128,
    pub value_usd: u128,      // Cached with 8 decimals
    pub last_price_update: u32,
}
\`\`\`

**Supported Asset Types**:
- Native √ãTR token
- Bridged Bitcoin (sBTC)
- Bridged Ethereum (sETH)
- Stablecoins (USDC, USDT)
- Synthetic gold (sXAU)
- Other governance-approved assets

#### Allocation Strategies

Four distinct strategies available:

\`\`\`rust
pub enum AllocationStrategy {
    /// Equal weight allocation (each asset gets equal %)
    EqualWeight = 0,

    /// Market cap weighted (higher cap = higher allocation)
    MarketCapWeighted = 1,

    /// Risk-adjusted (lower volatility = higher allocation)
    RiskAdjusted = 2,

    /// Custom manual allocations (default)
    Custom = 3,
}
\`\`\`

**Strategy Selection**:
\`\`\`rust
// Governance can set strategy via:
pub fn set_allocation_strategy(
    origin: OriginFor<T>,
    strategy_code: u8,  // 0-3 corresponding to enum
) -> DispatchResult
\`\`\`

**Example Custom Allocation**:
\`\`\`
For EDSC backing:
- 40% √ãTR (native token, low correlation)
- 30% sBTC (store of value, established)
- 20% sETH (smart contract ecosystem)
- 10% Other (USDC, sXAU, diversification)
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
/// Triggered when deviation exceeds 5% threshold
#[pallet::constant]
type RebalanceThreshold: Get<Permill>;  // Default: 500 (5%)
\`\`\`

**Rebalancing Logic**:
\`\`\`rust
pub fn needs_rebalancing() -> bool {
    let threshold = T::RebalanceThreshold::get();

    for (asset_id, config) in AssetConfigs::<T>::iter() {
        let current_alloc = Self::get_asset_allocation(asset_id)?;
        let target = config.target_allocation;

        let deviation = if current_alloc > target {
            current_alloc.saturating_sub(target)
        } else {
            target.saturating_sub(current_alloc)
        };

        if deviation > threshold {
            return true;  // Rebalancing needed
        }
    }

    false
}
\`\`\`

**Rebalancing Execution**:
\`\`\`rust
pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    // Check rebalance interval (minimum time between rebalances)
    // Calculate required swaps to reach target allocations
    // Execute swaps via DEX integration
    // Update holdings and emit events
    // Record rebalancing history
}
\`\`\`

#### Oracle Integration

**Price Oracle Dependency**:
\`\`\`rust
trait Config: frame_system::Config + pallet_reserve_oracle::Config {
    // Inherits oracle functionality for real-time pricing
}
\`\`\`

**Price Updates**:
- Real-time asset prices from oracle network
- Cached USD values for performance
- 8 decimal precision for accuracy
- Automatic updates on reserve operations

#### Vault Integration

**Secure Asset Storage**:
- Integration with \`pallet-reserve-vault\` for custody
- Multi-signature controls for asset movements
- Separation of hot/cold storage
- Audit trail for all asset transfers

#### Asset Whitelisting and Position Limits

**Whitelisting**:
\`\`\`rust
/// Governance-controlled asset approval
pub type WhitelistedAssets<T: Config> = StorageMap<
    _, Blake2_128Concat, u32, bool
>;

// Only whitelisted assets can be added to reserve
ensure!(WhitelistedAssets::<T>::get(asset_id), Error::<T>::AssetNotWhitelisted);
\`\`\`

**Position Limits**:
\`\`\`rust
// Per-asset min/max holdings
ensure!(amount >= config.min_holding, Error::<T>::BelowMinimumHolding);
ensure!(amount <= config.max_holding, Error::<T>::ExceedsMaximumHolding);
\`\`\`

**Risk Management**:
- Maximum exposure limits per asset class
- Diversification requirements
- Liquidity constraints
- Correlation monitoring

#### Storage Items

\`\`\`rust
/// Asset configuration registry
AssetConfigs<T: Config> = StorageMap<_, u32, AssetMetadata>

/// Reserve composition (holdings per asset)
ReserveComposition<T: Config> = StorageMap<_, u32, AssetHolding>

/// Current allocation strategy (0=EqualWeight, 1=MarketCapWeighted, 2=RiskAdjusted, 3=Custom)
CurrentStrategy<T: Config> = StorageValue<_, u8>

/// Total reserve value (cached, USD with 8 decimals)
TotalReserveValue<T: Config> = StorageValue<_, u128>

/// Whitelisted assets
WhitelistedAssets<T: Config> = StorageMap<_, u32, bool>

/// Asset count
AssetCount<T: Config> = StorageValue<_, u32>

/// Last rebalance status
LastRebalance<T: Config> = StorageValue<_, RebalanceStatus<BlockNumber>>

/// Rebalancing enabled flag
RebalancingEnabled<T: Config> = StorageValue<_, bool>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Add new asset to reserve
add_asset(asset_id, symbol, decimals, min_holding, max_holding, target_allocation)

// Remove asset from reserve
remove_asset(asset_id)

// Set target allocation for asset
set_target_allocation(asset_id, target: Permill)

// Set allocation strategy
set_allocation_strategy(strategy_code: u8)

// Enable/disable automatic rebalancing
set_rebalancing_enabled(enabled: bool)
\`\`\`

**Public Functions**:
\`\`\`rust
// Deposit asset into reserve
deposit_to_reserve(asset_id, amount)

// Trigger manual rebalance
trigger_rebalance()
\`\`\`

**Restricted Functions** (Governance only):
\`\`\`rust
// Withdraw asset from reserve
withdraw_from_reserve(asset_id, amount)
\`\`\`

---

### 3. PALLET-EDSC-STABILITY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-edsc-stability/src/lib.rs\`

The EDSC stability pallet implements the protocol's stablecoin system with multi-asset reserve backing and peg defense mechanisms.

#### EDSC Stablecoin System

**Peg Target**: $1.00 USD (soft peg maintained via arbitrage and stability mechanisms)

**Reserve Architecture**:
\`\`\`rust
pub struct ReserveComposition {
    pub etr_allocation: u16,    // 40% (4000 basis points)
    pub sbtc_allocation: u16,   // 30% (3000 basis points)
    pub seth_allocation: u16,   // 20% (2000 basis points)
    pub other_allocation: u16,  // 10% (1000 basis points)
}
\`\`\`

**Multi-Asset Reserve Backing**:
- **40% √ãTR**: Native token, governance voting power
- **30% sBTC**: Synthetic Bitcoin, store of value
- **20% sETH**: Synthetic Ethereum, DeFi integration
- **10% Other**: USDC, sXAU, diversification assets

#### Treasury-Backed Parameters

\`\`\`rust
/// Target backing ratio: 100% (10000 basis points)
#[pallet::constant]
type TargetBackingRatio: Get<u16>;  // Default: 10000 (100%)

/// Purchase fee: 0.1% (10 basis points)
#[pallet::constant]
type PurchaseFee: Get<u16>;  // Default: 10

/// Redemption fee: 0.1% (10 basis points)
#[pallet::constant]
type RedemptionFee: Get<u16>;  // Default: 10
\`\`\`

**Purchase/Redemption Example**:
\`\`\`
To purchase 1000 EDSC:
‚Üí User sends: $1000 in BTC/ETH/SOL/USDC
‚Üí Purchase fee: $1 (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: $1000 backing

To redeem 999 EDSC:
‚Üí User burns: 999 EDSC
‚Üí Redemption fee: $0.999 (0.1%)
‚Üí User receives: $998.001 in preferred crypto
‚Üí Reserve releases: $998.001 from holdings

Key Differences from Over-Collateralized Model:
- No upfront capital required to launch
- Backing accumulates organically from purchases
- No liquidations (direct buy/sell only)
- 100% backing ratio (not 150%)
- No debt positions or interest charges
\`\`\`

#### Interest Rate Adjustments for Peg Defense

**Dynamic Interest Rates**:
\`\`\`rust
/// Base interest rate (annual, in basis points)
#[pallet::constant]
type BaseInterestRate: Get<u16>;  // Default: 200 (2% annual)
\`\`\`

**Peg Defense Mechanism**:
\`\`\`rust
pub fn adjust_interest_rate(
    origin: OriginFor<T>,
    new_rate: u16,
) -> DispatchResult {
    // If EDSC > $1.01: Lower rate to encourage minting
    // If EDSC < $0.99: Raise rate to encourage burning

    let price = EDSCPrice::<T>::get();  // In cents (100 = $1.00)

    if price > 101 {
        // Trading above peg: lower interest to encourage minting
        new_rate = current_rate.saturating_sub(50);  // Reduce by 0.5%
    } else if price < 99 {
        // Trading below peg: raise interest to encourage burning
        new_rate = current_rate.saturating_add(50);  // Increase by 0.5%
    }

    InterestRate::<T>::put(new_rate);
}
\`\`\`

**Interest Calculation**:
\`\`\`rust
fn calculate_accrued_interest(
    position: &EDSCPosition<BalanceOf<T>>,
    current_block: u32,
) -> Result<u128, DispatchError> {
    let blocks_elapsed = current_block - position.last_interest_update;
    let blocks_per_year = 5_256_000u128;  // ~6 second blocks

    // Interest = principal * rate * time
    let interest = position.edsc_minted
        .checked_mul(position.interest_rate as u128)?
        .checked_mul(blocks_elapsed as u128)?
        .checked_div(10000)?  // Basis points to decimal
        .checked_div(blocks_per_year)?;

    Ok(interest)
}
\`\`\`

#### Reserve Purchase/Redemption System

**Purchase from Reserve**:
\`\`\`rust
pub fn purchase_edsc(
    origin: OriginFor<T>,
    payment_token: AssetId,
    payment_amount: BalanceOf<T>,
) -> DispatchResult {
    let buyer = ensure_signed(origin)?;

    // Get payment token price from oracle
    let token_price = T::PriceOracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd;

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * T::PurchaseFee::get() / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    T::MultiCurrency::transfer(payment_token, &buyer, &T::ReserveVault::get(), payment_amount)?;

    // Release EDSC from vault to buyer
    T::Currency::transfer(&T::ReserveVault::get(), &buyer, net_edsc)?;

    Ok(())
}
\`\`\`

**Redemption to Reserve**:
\`\`\`rust
pub fn redeem_edsc(
    origin: OriginFor<T>,
    edsc_amount: BalanceOf<T>,
    preferred_payment: AssetId,
) -> DispatchResult {
    let redeemer = ensure_signed(origin)?;

    // Burn EDSC from user
    T::Currency::burn_from(&redeemer, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * T::RedemptionFee::get() / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price and amount
    let token_price = T::PriceOracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    T::MultiCurrency::transfer(preferred_payment, &T::ReserveVault::get(), &redeemer, payment_amount)?;

    Ok(())
}
\`\`\`

**Fee Distribution**:
\`\`\`
Purchase Fee: 0.1% ‚Üí Treasury
Redemption Fee: 0.1% ‚Üí Treasury

Example:
User purchases 1000 EDSC with 1000 USDC:
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Treasury receives: 1 USDC fee
‚Üí Reserve holds: 1000 USDC backing

User redeems 999 EDSC for USDC:
‚Üí Fee: 0.999 USDC (0.1%)
‚Üí User receives: 998.001 USDC
‚Üí Treasury receives: 0.999 USDC fee
‚Üí Reserve releases: 998.001 USDC
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
#[pallet::constant]
type RebalanceThreshold: Get<u16>;  // Default: 500 (5%)

pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    let current = CurrentReserveComposition::<T>::get();
    let target = TargetReserveComposition::<T>::get();

    let deviation = Self::calculate_composition_deviation(&current, &target)?;

    ensure!(
        deviation > T::RebalanceThreshold::get(),
        Error::<T>::RebalancingNotNeeded
    );

    // Execute rebalancing...
}
\`\`\`

**Rebalancing Process**:
1. Calculate current asset allocations
2. Compare to target percentages
3. Determine required swaps
4. Execute trades via DEX
5. Update reserve composition
6. Emit rebalancing events

#### Treasury Integration

**Stability Fees Flow**:
\`\`\`rust
/// Accumulated stability fees for treasury
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

// Interest payments go to stability fees
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(interest_in_collateral);
});
\`\`\`

**Purchase/Redemption Fees Flow**:
\`\`\`rust
// Fees sent to treasury
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(purchase_fee + redemption_fee);
});
\`\`\`

**Fee Collection**:
- Purchase fees from EDSC purchases (0.1%)
- Redemption fees from EDSC redemptions (0.1%)
- Rebalancing fees (if applicable)
- All fees flow to treasury for protocol sustainability

#### Storage Items

\`\`\`rust
/// Main EDSC reserve balance
EDSCReserveBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Current reserve composition
CurrentReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Target reserve composition (governance-updatable)
TargetReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Current backing ratio (basis points)
BackingRatio<T: Config> = StorageValue<_, u16>

/// Reserve vault address (holds initial EDSC supply)
ReserveVault<T: Config> = StorageValue<_, T::AccountId>

/// Circulating EDSC supply (released from vault)
CirculatingEDSCSupply<T: Config> = StorageValue<_, u128>

/// User EDSC balances
EDSCBalances<T: Config> = StorageMap<_, T::AccountId, u128>

/// Purchase/redemption history
TransactionHistory<T: Config> = StorageMap<_, T::AccountId, Vec<EDSCTransaction>>

/// Accumulated stability fees
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

/// Emergency pause flag
EmergencyPaused<T: Config> = StorageValue<_, bool>

/// Rebalancing history
RebalanceHistory<T: Config> = StorageMap<_, u32, RebalanceRecord>

/// Current EDSC price (in cents, 100 = $1.00)
EDSCPrice<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**User Functions**:
\`\`\`rust
// Purchase EDSC from reserve with crypto
purchase_edsc(payment_token: AssetId, payment_amount: Balance)

// Redeem EDSC back to reserve for crypto
redeem_edsc(edsc_amount: Balance, preferred_payment: AssetId)

// Check current reserve backing ratio
get_backing_ratio() -> Result<u16, Error>

// Trigger reserve rebalancing
trigger_rebalance()
\`\`\`

**Governance Functions** (Root only):
\`\`\`rust
// Adjust interest rate for peg defense
adjust_interest_rate(new_rate: u16)

// Emergency pause system
emergency_pause()

// Deactivate emergency pause
deactivate_emergency_pause()

// Update target reserve composition
update_target_composition(new_composition)
\`\`\`

---

### 4. PALLET-CIRCUIT-BREAKER IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-circuit-breaker/src/lib.rs\`

The circuit breaker pallet provides emergency safety controls for the EDSC stability system.

#### Circuit Breaker Statuses

\`\`\`rust
pub enum CircuitStatus {
    /// Normal operation - all functions available
    Normal,

    /// Throttled - limited operations, reduced volume caps
    Throttled,

    /// Paused - critical operations suspended
    Paused,

    /// Emergency - all non-critical operations halted
    Emergency,
}
\`\`\`

**Status Transitions**:
\`\`\`
Normal ‚Üí Throttled:  Reserve ratio drops below 95%
Throttled ‚Üí Paused:  Volume limits exceeded
Paused ‚Üí Emergency:  Reserve ratio drops below 90%
Emergency ‚Üí Normal:  Requires governance approval
\`\`\`

#### Volume Caps

**Hourly and Daily Limits**:
\`\`\`rust
/// Maximum hourly redemption volume (in EDSC)
#[pallet::constant]
type MaxHourlyVolume: Get<u128>;  // Default: 1M EDSC/hour

/// Maximum daily redemption volume (in EDSC)
#[pallet::constant]
type MaxDailyVolume: Get<u128>;  // Default: 10M EDSC/day
\`\`\`

**Volume Tracking**:
\`\`\`rust
pub struct VolumeTracker<BlockNumber> {
    pub hourly_volume: u128,
    pub hourly_start_block: BlockNumber,
    pub daily_volume: u128,
    pub daily_start_block: BlockNumber,
}

pub fn track_volume(amount: u128) -> DispatchResult {
    let mut tracker = RedemptionVolume::<T>::get();

    tracker.hourly_volume = tracker.hourly_volume.saturating_add(amount);
    tracker.daily_volume = tracker.daily_volume.saturating_add(amount);

    // Check limits
    if tracker.hourly_volume > T::MaxHourlyVolume::get() {
        Self::trigger_circuit(b"Hourly volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    if tracker.daily_volume > T::MaxDailyVolume::get() {
        Self::trigger_circuit(b"Daily volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    Ok(())
}
\`\`\`

#### Reserve Ratio Thresholds

**Threshold Configuration**:
\`\`\`rust
/// Reserve ratio threshold for throttling (95%)
#[pallet::constant]
type ThrottleThreshold: Get<u16>;  // Default: 9500 basis points

/// Reserve ratio threshold for emergency pause (90%)
#[pallet::constant]
type EmergencyThreshold: Get<u16>;  // Default: 9000 basis points
\`\`\`

**Automatic Status Updates**:
\`\`\`rust
pub fn check_reserve_ratio(reserve_ratio: u16) -> DispatchResult {
    let current_status = Status::<T>::get();

    // Emergency threshold (90%)
    if reserve_ratio < T::EmergencyThreshold::get() {
        if current_status != CircuitStatus::Emergency {
            Self::trigger_circuit(b"Emergency reserve threshold breached");
            Status::<T>::put(CircuitStatus::Emergency);
        }
        return Err(Error::<T>::ReserveRatioTooLow);
    }

    // Throttle threshold (95%)
    if reserve_ratio < T::ThrottleThreshold::get() {
        if current_status == CircuitStatus::Normal {
            Status::<T>::put(CircuitStatus::Throttled);
        }
    } else {
        // Healthy - return to normal if throttled
        if current_status == CircuitStatus::Throttled {
            Status::<T>::put(CircuitStatus::Normal);
        }
    }

    Ok(())
}
\`\`\`

#### Auto-Pause Mechanisms

**Peg Deviation Auto-Pause**:
\`\`\`rust
/// Emergency pause threshold (10% peg deviation)
#[pallet::constant]
type EmergencyPauseThreshold: Get<u16>;  // Default: 1000 (10%)

// If EDSC price deviates >10% from $1.00, auto-pause
let price = EDSCPrice::<T>::get();  // In cents
let target = 100;  // $1.00

let deviation = if price > target {
    ((price - target) * 10000) / target
} else {
    ((target - price) * 10000) / target
};

if deviation > T::EmergencyPauseThreshold::get() {
    EmergencyPaused::<T>::put(true);
    Self::trigger_circuit(b"Peg deviation exceeded 10%");
}
\`\`\`

**Automatic Triggers**:
1. **Volume Spike**: >1M EDSC redeemed in 1 hour
2. **Reserve Depletion**: Reserve ratio <90%
3. **Peg Break**: EDSC price >$1.10 or <$0.90
4. **Rapid Redemptions**: >100,000 EDSC redemptions per hour
5. **Oracle Failure**: Price feed stale >1 hour

#### Whitelist System

**Whitelist Configuration**:
\`\`\`rust
/// Accounts exempt from circuit breaker restrictions
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

pub fn is_operation_allowed(account: &T::AccountId, amount: u128) -> DispatchResult {
    // Whitelisted accounts bypass restrictions
    if Whitelist::<T>::get(account) {
        return Ok(());
    }

    // Check circuit status for others
    match Status::<T>::get() {
        CircuitStatus::Emergency => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Paused => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Throttled => Ok(()),  // Limited operations allowed
        CircuitStatus::Normal => Ok(()),
    }
}
\`\`\`

**Whitelist Use Cases**:
- Emergency recovery accounts
- Protocol-owned liquidity providers
- Authorized market makers
- Treasury disbursement accounts

#### Storage Items

\`\`\`rust
/// Current circuit breaker status
Status<T: Config> = StorageValue<_, CircuitStatus>

/// Volume tracker for redemptions
RedemptionVolume<T: Config> = StorageValue<_, VolumeTracker<BlockNumber>>

/// Manual pause flag (governance-controlled)
ManualPauseEnabled<T: Config> = StorageValue<_, bool>

/// Whitelist of exempt accounts
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

/// Total circuit trigger count
TriggerCount<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Manually pause circuit
activate_manual_pause()

// Resume normal operations
resume()

// Add account to whitelist
add_to_whitelist(account: AccountId)

// Remove account from whitelist
remove_from_whitelist(account: AccountId)

// Reset circuit breaker
reset_circuit()
\`\`\`

**Automatic Functions** (Called by other pallets):
\`\`\`rust
// Check if operation allowed
is_operation_allowed(account, amount)

// Track redemption volume
track_volume(amount)

// Check reserve ratio thresholds
check_reserve_ratio(reserve_ratio)
\`\`\`

---

### 5. EMERGENCY RECOVERY PROCEDURES

This section documents critical emergency response protocols for the treasury and reserve system.

#### Treasury Emergency Freeze

**Scenario**: Suspected treasury compromise or unauthorized access

**Procedure**:
\`\`\`rust
// 1. Any Director can trigger immediate freeze
pub fn emergency_freeze_treasury() {
    // Pause all disbursements
    // Require 7/9 approval to unfreeze
    // Alert all directors via on-chain event
}

// 2. Investigation period (72 hours maximum)
// - Analyze suspicious transactions
// - Verify director identities
// - Check multisig signatures

// 3. Resolution requires 7/9 directors
pub fn unfreeze_treasury() {
    // Verify 7/9 director approvals
    // Resume normal operations
    // Document incident for transparency
}
\`\`\`

**Multi-Signature Recovery**:
\`\`\`bash
# Generate recovery transaction
etrid-cli treasury emergency-freeze \
  --director-keys /path/to/keys \
  --reason "Suspicious activity detected"

# Requires 7/9 signatures to unfreeze
etrid-cli treasury unfreeze \
  --approvals director1,director2,...,director7 \
  --verify-signatures
\`\`\`

#### Stuck Funds Recovery

**Scenario**: Funds locked due to smart contract bug or runtime upgrade issue

**Emergency Withdrawal Protocol**:
\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals
    // Can only withdraw from EmergencyReserve
    // Full audit trail recorded on-chain

    ensure!(
        disbursement.approval_count >= 7,
        Error::<T>::EmergencyThresholdNotMet
    );

    // Execute emergency transfer
    T::Currency::transfer(&Self::account_id(), &recipient, amount)?;

    // Emit detailed event
    Self::deposit_event(Event::EmergencyWithdrawal(amount, recipient, 7));
}
\`\`\`

**Recovery Steps**:
1. Directors identify stuck funds
2. Create emergency withdrawal proposal
3. Collect 7/9 director approvals
4. Execute recovery transaction
5. Post-mortem analysis and report
6. Protocol upgrade if needed

#### EDSC Peg Break Response

**Scenario**: EDSC price deviates >10% from $1.00 peg

**Response Protocol**:

**Phase 1: Automatic Circuit Breaker (Immediate)**
\`\`\`rust
// Auto-triggered when peg breaks
if edsc_price > 110 || edsc_price < 90 {  // In cents
    EmergencyPaused::<T>::put(true);
    Status::<T>::put(CircuitStatus::Emergency);

    Self::deposit_event(Event::EmergencyPauseActivated {
        triggered_by: system_account,
        reason: b"EDSC peg break >10%",
    });
}
\`\`\`

**Phase 2: Reserve Injection (Directors, <6 hours)**
\`\`\`rust
// Directors vote to inject reserves
pub fn inject_reserves_for_peg(
    amount: BalanceOf<T>,
) -> DispatchResult {
    // Requires 6/9 director approval
    // Deploy reserves to support peg
    // Buy EDSC if <$0.90 or sell if >$1.10
}
\`\`\`

**Phase 3: Interest Rate Adjustment (Immediate)**
\`\`\`rust
// Automatic interest rate response
if edsc_price < 99 {
    // EDSC trading below $1: Raise rates to encourage burning
    new_rate = current_rate.saturating_add(100);  // +1% annual
} else if edsc_price > 101 {
    // EDSC trading above $1: Lower rates to encourage minting
    new_rate = current_rate.saturating_sub(100);  // -1% annual
}

InterestRate::<T>::put(new_rate);
\`\`\`

**Phase 4: Governance Response (24-48 hours)**
- Emergency governance vote (if needed)
- Adjust collateralization requirements
- Modify reserve composition targets
- Implement additional stability mechanisms

#### Validator Payment Failure Recovery

**Scenario**: Validator rewards fail to distribute due to runtime issue

**Manual Distribution Procedure**:
\`\`\`bash
# 1. Identify affected validators and amounts
etrid-cli validator list-pending-rewards \
  --epoch 12345 \
  --output rewards.json

# 2. Create manual distribution proposal
etrid-cli treasury propose-batch-payment \
  --recipients rewards.json \
  --category Operations \
  --description "Manual validator reward distribution for epoch 12345"

# 3. Directors approve (6/9 required)
etrid-cli treasury approve-disbursement \
  --id 42 \
  --director-key /path/to/director/key

# 4. Verify distributions
etrid-cli validator verify-payments \
  --epoch 12345 \
  --check-balances
\`\`\`

**Compensation Protocol**:
- Calculate exact owed amounts per validator
- Include missed staking rewards
- Add compensation for delayed payment (0.1% per day)
- Execute via treasury Operations budget
- Document incident for protocol improvement

#### Consensus Day Failure Recovery

**Scenario**: Consensus Day process fails mid-execution

**Recovery Options**:

**Option 1: Rollback and Retry**
\`\`\`bash
# If failure detected early (within 1 hour)
# Rollback to pre-Consensus Day state
etrid-cli governance rollback-consensus-day \
  --snapshot-block 1234567 \
  --requires-7-of-9-approval

# Schedule retry
etrid-cli governance schedule-consensus-day-retry \
  --date "2025-12-02" \
  --preserve-votes
\`\`\`

**Option 2: Manual Execution**
\`\`\`bash
# If Minting phase fails
etrid-cli governance manual-mint \
  --approved-proposals approved.json \
  --director-approvals 7-of-9

# If Distribution phase fails
etrid-cli governance manual-distribute \
  --rewards rewards.json \
  --verify-totals
\`\`\`

**Option 3: Emergency Governance**
\`\`\`bash
# If complete failure
# Activate emergency governance mode
etrid-cli governance activate-emergency-mode \
  --requires-7-of-9-directors

# Execute critical operations manually
# Schedule special Consensus Day retry
\`\`\`

#### Multi-Signature Transaction System

**Emergency Multi-Sig Setup**:
\`\`\`rust
// 9 Directors with 6-of-9 threshold (normal)
// 7-of-9 threshold for emergency actions

pub struct MultiSigConfig {
    pub signatories: Vec<AccountId>,  // 9 directors
    pub normal_threshold: u8,         // 6
    pub emergency_threshold: u8,      // 7
}

// Create multi-sig transaction
pub fn create_multisig_call(
    call: Box<RuntimeCall>,
    is_emergency: bool,
) -> MultiSigTransaction {
    let threshold = if is_emergency { 7 } else { 6 };

    MultiSigTransaction {
        call,
        threshold,
        approvals: Vec::new(),
        created_at: current_block,
        expires_at: current_block + EXPIRATION_BLOCKS,
    }
}
\`\`\`

**Multi-Sig Emergency Workflow**:
\`\`\`bash
# 1. Create emergency transaction
etrid-cli multisig create \
  --call "treasury.emergency_withdrawal" \
  --threshold 7 \
  --signatories director1,director2,...,director9

# 2. Directors sign (collect 7 signatures)
etrid-cli multisig sign \
  --tx-hash 0x1234... \
  --director-key /path/to/key1

# 3. Execute when threshold reached
etrid-cli multisig execute \
  --tx-hash 0x1234... \
  --verify-signatures 7

# 4. Broadcast to network
etrid-cli multisig broadcast \
  --tx-hash 0x1234... \
  --wait-for-finality
\`\`\`

**Security Considerations**:
- Directors use hardware wallets for signing
- Multi-geographic distribution of signers
- Time-locked execution for certain actions
- Transparent on-chain audit trail
- Social recovery mechanisms
- Regular key rotation procedures

---

### 6. MONITORING AND TRANSPARENCY

#### Real-Time Dashboards

**Treasury Dashboard** (\`treasury.etrid.org\`):
- Total treasury balance (√ãTR + EDSC)
- Budget allocations vs. spending
- Pending disbursement proposals
- Director voting records
- Historical funding sources
- Monthly/yearly spending reports

**Reserve Dashboard** (\`reserve.etrid.org\`):
- Current reserve composition
- Asset allocations vs. targets
- Rebalancing history
- Total reserve value (USD)
- Whitelisted assets
- Oracle price feeds

**EDSC Dashboard** (\`edsc.etrid.org\`):
- Current EDSC price
- Total supply and circulation
- Backing ratio (system-wide)
- Purchase/redemption volume history
- Active transaction count
- Recent large transactions
- Fee revenue (purchase + redemption)

**Circuit Breaker Dashboard** (\`safety.etrid.org\`):
- Current circuit status
- Hourly/daily volume metrics
- Reserve ratio trends
- Trigger count history
- Whitelisted accounts
- Recent status changes

#### On-Chain Transparency

All treasury and reserve operations emit detailed events:

\`\`\`rust
// Treasury Events
Event::FundsDeposited(source, amount)
Event::DisbursementProposed(id, proposer, category, amount, recipient)
Event::DisbursementApproved(id, director, approval_count)
Event::DisbursementExecuted(id, recipient, amount)
Event::EmergencyWithdrawal(amount, recipient, approvals)

// Reserve Events
Event::AssetAdded { asset_id, symbol }
Event::RebalanceTriggered { total_value, assets_count }
Event::ReserveValueUpdated { total_value_usd }

// EDSC Events
Event::EDSCMinted { who, collateral, edsc_amount, interest_rate }
Event::PositionLiquidated { owner, liquidator, edsc_amount, collateral_seized, penalty }
Event::InterestRateAdjusted { old_rate, new_rate, reason }

// Circuit Breaker Events
Event::StatusChanged { old_status, new_status }
Event::CircuitTriggered { reason }
Event::VolumeLimitExceeded { period, current_volume, max_volume }
\`\`\`

#### Audit Reports

**Quarterly Treasury Reports**:
- Total funds received (by source)
- Total funds disbursed (by category)
- Budget utilization rates
- Director approval statistics
- Emergency actions (if any)

**Annual Reserve Audit**:
- Asset holdings verification
- Rebalancing performance
- Oracle price accuracy
- Risk metrics analysis
- Recommendations for improvements

---

### 7. INTEGRATION WITH CONSENSUS DAY

The treasury and reserve systems integrate tightly with the annual Consensus Day governance process:

#### Budget Allocation Updates

During Consensus Day, the community votes on budget allocations:

\`\`\`rust
// After Consensus Day voting concludes:
pub fn update_allocations_from_consensus(
    approved_allocations: BudgetAllocations,
) -> DispatchResult {
    // Validate allocations sum to 100%
    ensure!(approved_allocations.is_valid(), Error::<T>::InvalidBudgetAllocations);

    // Update treasury allocations
    BudgetAllocationsStorage::<T>::put(approved_allocations.clone());

    Self::deposit_event(Event::BudgetAllocationsUpdated(approved_allocations));

    Ok(())
}
\`\`\`

#### Minting Phase Integration

Approved budgets are minted and allocated:

\`\`\`rust
// Called by pallet-consensus-day during Phase 3: Minting
pub fn receive_consensus_day_minting(amount: BalanceOf<T>) -> DispatchResult {
    // Mint to treasury
    let treasury_account = Self::account_id();
    T::Currency::deposit_creating(&treasury_account, amount);

    // Update balance
    TreasuryBalance::<T>::mutate(|balance| {
        *balance = balance.saturating_add(amount);
    });

    // Allocate to categories based on approved percentages
    Self::allocate_to_categories(amount)?;

    Ok(())
}
\`\`\`

#### Reserve Composition Updates

Community can vote to adjust EDSC reserve targets:

\`\`\`rust
// Consensus Day proposal to update reserve composition
pub fn update_target_composition(
    origin: OriginFor<T>,
    new_composition: ReserveComposition,
) -> DispatchResult {
    ensure_root(origin)?;  // Only via governance vote

    // Validate composition sums to 100%
    let total = new_composition.etr_allocation as u32
        + new_composition.sbtc_allocation as u32
        + new_composition.seth_allocation as u32
        + new_composition.other_allocation as u32;

    ensure!(total == 10000, Error::<T>::InvalidReserveComposition);

    TargetReserveComposition::<T>::put(new_composition.clone());

    // Trigger rebalancing to new targets
    Self::trigger_automatic_rebalance()?;

    Ok(())
}
\`\`\`

---

### 8. CONCLUSION

The treasury and reserve system implementation represents a comprehensive financial infrastructure for the √ãtrid protocol. Through four specialized pallets, the system provides:

- **Transparent Governance**: Multi-signature controls with 9 elected Directors
- **Fiscal Sustainability**: Multiple funding sources and disciplined budget management
- **Stablecoin Stability**: Multi-asset reserve backing with automatic rebalancing
- **Risk Management**: Circuit breaker protections and emergency response protocols

This infrastructure enables √ãtrid to operate as a truly self-governing, self-funding decentralized network without relying on centralized entities.

**System Status**: Production-ready (Q4 2025)
**Audit Status**: Pending external security audit
**Documentation**: Complete technical specifications available in pallet source code

---

*"Financial sovereignty begins with transparent, community-controlled treasury management."*

**‚Äì Treasury & Reserve System Implementation Team**
**√ãtrid Foundation**

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    },
    'charter': {
        title: '√ãTRID Protocol Charter',
        filename: 'protocol-charter.md',
        content: `# √ãTRID PROTOCOL CHARTER
## Free and Open Decentralized Democracy of Stakeholders (FODDoS)

**Version**: 1.0.0
**Status**: ACTIVE PROTOCOL SPECIFICATION
**Last Updated**: October 30, 2025
**Founder**: Eoj Edred
**License**: GPLv3 (Open Source, Immutable)

---

## I. PROTOCOL PREAMBLE

The **√ãTRID Multichain Protocol** is a decentralized, non-hierarchical blockchain system designed to resist centralization, censorship, and unilateral control. This charter establishes the immutable rules, governance structures, and technical specifications that define √ãTRID.

### Core Principles
1. **Decentralization**: No single entity controls the network
2. **Democracy**: All major decisions made via Consensus Day voting
3. **Transparency**: All code is GPLv3 open-source
4. **Immutability**: Once enshrined in this charter, rules cannot be broken without hard fork consensus
5. **Interoperability**: DETRP2P ensures coherent cross-chain communication

---

## II. PROTOCOL DEFINITION

### A. √ãTRID Multichain Architecture

**Hierarchical Parallel Chain Structure**:

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        FLARECHAIN (Root/Main Chain)                      ‚îÇ
‚îÇ  - World State Storage                                   ‚îÇ
‚îÇ  - Consensus Finality (ASF)                             ‚îÇ
‚îÇ  - Governance (Consensus Day)                           ‚îÇ
‚îÇ  - Foundation & DAO Operations                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚Üí PBC-EDSC (√ãtrid Dollar Stablecoin Chain)
         ‚îÇ   - EDSC token operations
         ‚îÇ   - Redemption engine (3-path)
         ‚îÇ   - Oracle system
         ‚îÇ   - State checkpoints to FlareChain
         ‚îÇ
         ‚îú‚îÄ‚Üí PBC-[Future] (Custom Partition Burst Chains)
         ‚îÇ   - Domain-specific sidechains
         ‚îÇ   - Isolated state, fast finality
         ‚îÇ   - Checkpoint-synced to FlareChain
         ‚îÇ
         ‚îî‚îÄ‚Üí Lightning Bloc Network (Micropayment Layer)
             - Off-chain state channels
             - Rapid settlement
             - Batch settlement to FlareChain
\`\`\`

### B. Essential Elements to Operate (E¬≥20)

The √ãTRID Protocol consists of 13 core subsystems:

| # | System | Purpose | Status |
|---|--------|---------|--------|
| 1 | DETR p2p | Multi-protocol P2P networking (S/Kademlia DHT, ECIES encryption) | ‚úÖ ACTIVE |
| 2 | OpenDID | Self-sovereign identity system (decentralized identifiers) | ‚úÖ ACTIVE |
| 3 | Blockchain Security | Post-quantum cryptography, hashing, signatures | ‚úÖ ACTIVE |
| 4 | Accounts | EBCA, RCA, RCWA, SCA, SSCA account types | ‚úÖ ACTIVE |
| 5 | Multichain | FlareChain + PBCs + State channels | ‚úÖ ACTIVE |
| 6 | Native Currency | √âTR (main), √ãDSC (stablecoin), VMw (computation gas) | ‚úÖ ACTIVE |
| 7 | Transactions | Regular, smart contract, cross-chain, stake-deposit | ‚úÖ ACTIVE |
| 8 | √ãtwasmVM | WASM-based smart contract runtime (Turing-complete) | ‚úÖ ACTIVE |
| 9 | Consensus | ASF (Ascending Scale of Finality) consensus algorithm | ‚úÖ ACTIVE |
| 10 | Foundation | DAO charter, governance, legal framework | üîÑ FINALIZING |
| 11 | Peer Roles | Flare Nodes, Validity Nodes, Common Peers, DDs | ‚úÖ ACTIVE |
| 12 | Governance | Consensus Day (annual vote), 9-person DD board | ‚úÖ ACTIVE |
| 13 | Clients | CLI, Web, Mobile wallet implementations | ‚úÖ ACTIVE |

---

## III. TOKEN ECONOMICS & NATIVE CURRENCY

### A. √âTR (√ãtrid Coin) - Primary Token

**Token Specifications**:
- **Symbol**: √âTR
- **Decimals**: 18
- **Initial Mint**: 1,000,000,000 √âTR (1 Billion)
- **Max Supply**: Determined by Consensus Day vote (no hard cap in code)
- **Distribution Method**: Annual Consensus Day fiscal mint vote

**Token Uses**:
- Payment for transactions and services
- Staking for validator participation (Flare/Validity Nodes)
- Voting in Consensus Day governance
- Distribution Pay rewards for network participation
- Collateral for √ãDSC stablecoin

### B. √ãDSC (√ãtrid Dollar Stablecoin)

**Stablecoin Specifications**:
- **Peg**: 1 √ãDSC = 1.00 USD (or IMF highest-ranked currency)
- **Total Supply**: 50 Billion √ãDSC
- **Initial Circulation**: 5 Billion √ãDSC
- **Locked Reserve**: 45 Billion √ãDSC (governed release)
- **Collateralization**: 110-130% overcollateralization
- **Reserve Backing**: Mix of on-chain (FlareChain vault) and custodian-held reserves

**√ãDSC Redemption Paths**:
1. **Path 1 - Treasury Reserve** (60% of redemptions): Direct withdrawal from FlareChain vault
2. **Path 2 - Custodian Redemption** (30%): BitGo/Anchorage Digital off-chain USD delivery
3. **Path 3 - DEX/AMM** (10%): Secondary market redemption via integrated DEX

**Dynamic Fee Schedule**:
- Base redemption fee: 0.25-10% (varies with reserve ratio)
- Higher fees when reserves < 100% collateral
- Lower fees when reserves > 120% collateral
- Emergency pause if reserves fall below 90% threshold

### C. VMw (Virtual Machine Watts) - Computation Gas

**Gas Token Specifications**:
- **Symbol**: VMw
- **Purpose**: Smart contract execution cost
- **1 VMw**: Computation cost equivalent to 1 watt-hour of compute
- **Conversion**: Market-based: ~0.001 √âTR = 1 VMw (adjustable via governance)
- **Burn**: All VMw consumed is permanently burned (deflationary)

**Gas Model**:
- Smart contract execution: Pay-per-opcode
- State storage writes: 64 VMw per 32-byte word
- Cross-chain messages: 256 VMw base + payload size
- No minimum gas price (set by validators, market-driven)

---

## IV. GOVERNANCE & CONSENSUS DAY PROTOCOL

### A. Consensus Day Schedule

**Annual Voting Event**:
- **Date**: December 1st (hardcoded, changes require hard fork)
- **Duration**: 24-hour voting window (Dec 1, 00:00-23:59 UTC)
- **Participation**: All Common Stake Peers (‚â•1 √âTR staked)
- **Voting Power**: Vote Weight = Stake / Vote Dilution
  - Vote Dilution = Total Network Stake / Coinage (average age of coins)

### B. Consensus Day Ballot & Voting

**Three Categories on Annual Ballot**:

1. **Fiscal Mint & Supply**
   - Vote on annual √âTR issuance amount
   - Top 3 proposals make final ballot
   - 3 economic limit options (min, mid, max supply)
   - Result becomes binding mint for next 12 months

2. **Decentralized Director Elections**
   - Vote for 9-person governance board (non-hierarchical)
   - Candidates must stake ‚â•128 √âTR
   - Candidates must meet "Honest Image" criteria
   - Elected DDs serve 1-year terms
   - Term limits: Maximum 3 consecutive terms

3. **Protocol Amendments**
   - Top 3 proposed changes make ballot
   - Requires ‚â•66% supermajority to pass
   - Changes take effect Jan 1st following vote
   - Major protocol changes: Additional 90-day audit period

### C. Decentralized Director (DD) Responsibilities

**9-Person Board Duties** (Non-Hierarchical):
- Oversee FlareChain operations and security
- Review and approve major protocol proposals
- Manage Foundation fund allocations
- Coordinate with custodians and validators
- Respond to security incidents
- Represent √ãTRID in legal/regulatory contexts

**DD Compensation**:
- Annual salary: X% of annual fiscal mint
- FLARE node operation rewards: Y% of block rewards
- Clawback provisions: Misconduct results in stake forfeiture

**DD Sanctions & Penalties**:
- Absentee voting (>2 missed Consensus Days): -25% compensation
- Misconduct: Full stake clawback + removal
- Security breach: Temporary suspension pending investigation

---

## V. PEER ARCHITECTURE & NODE TYPES

### A. Peer Categories

**1. Common Peers**
- Network users without staked √âTR
- Can create wallets, receive transfers
- Cannot vote or receive Distribution Pay
- Run light clients via DETRP2P

**2. Common Stake Peers**
- Hold ‚â•1 √âTR in active stake
- Full voting rights in Consensus Day
- Eligible for Distribution Pay rewards
- Can run full or light nodes

**3. Flare Nodes** (Finality Layer)
- Maintain FlareChain consensus
- Propagate blocks across network
- Optional stake participation (‚â•1 √âTR)
- Rewards: Z% of block production
- No minimum stake requirement to operate

**4. Validity Nodes** (Partition Burst Chains)
- Operate PBC sidechain consensus
- Propose and validate blocks
- **Minimum stake**: 64 √âTR per node
- Rotated in groups of 8 every 256 blocks (PPFA - Partition Proof of Authority)
- Rewards: W% of sidechain transaction fees

**5. Community Developers**
- Registered open-source contributors
- Eligible for bug bounties (0.1-10 √âTR per bug)
- Auditor payments: 50-500 √âTR per audit
- Track record pay scale: Veteran developers get priority allocation

---

## VI. DISTRIBUTION PAY SYSTEM

**Daily Distribution Schedule** (All times PST):

| Recipient | Time | Distribution Formula |
|-----------|------|----------------------|
| Registered Voting Peers | 12:01 AM | P% √ó √âTR / Diluted Vote % |
| FLARE Nodes | 4:01 AM | Z% √ó √âTR / Blocks / Year - Penalties |
| VALIDITY Nodes | 6:01 AM | W% √ó √âTR / PPFA Epoch - Penalties |
| Common Stake Peers | 8:01 AM | Q% √ó √âTR √ó Coinage / Stake |
| Decentralized Directors | 12:01 PM | (Z% FLARE Reward) + (V% DD Compensation) |

**Key Parameters** (Set by Consensus Day):
- P%, Z%, W%, Q%, V% = Annual percentages of fiscal mint
- All percentages total ‚â§100% of annual mint
- Penalties apply for non-compliance and security failures
- Penalty redistribution goes to compliant participants

---

## VII. EDSC (STABLECOIN) PROTOCOL SPECIFICATION

### A. EDSC on PBC-EDSC Chain

**Primary EDSC Operations**:
- **pallet-edsc-token**: Mint/burn authority for √ãDSC
- **pallet-edsc-receipts**: Issuance of Proof-of-Deposit SBTs (Soulbound Tokens)
- **pallet-edsc-redemption**: 3-path redemption engine
- **pallet-edsc-oracle**: TWAP price oracle (24h + 7d fallback)
- **pallet-edsc-checkpoint**: Sync state to FlareChain every N blocks
- **pallet-circuit-breaker**: Emergency pause system

### B. EDSC on FlareChain (Main Chain)

**Reserve & Custody Operations**:
- **pallet-reserve-vault**: On-chain collateral storage (already ‚úÖ)
- **pallet-custodian-registry**: Off-chain reserve tracking (already ‚úÖ)
- **pallet-reserve-oracle**: Reserve data aggregator (to build)

**Cross-Chain Synchronization**:
- PBC-EDSC checkpoints to FlareChain every 100 blocks
- Checkpoint contains: Total supply, reserve ratio, pending redemptions
- FlareChain validates checkpoint via 66% validator quorum
- Failure to validate triggers circuit breaker

### C. Oracle Price Feeds

**Primary Oracle Sources** (Minimum 5):
1. Binance API
2. Coinbase API
3. Kraken API
4. Bitstamp API
5. Gemini API

**Secondary Oracle Sources** (Future):
- Uniswap/PancakeSwap/Curve TWAP
- Hyperliquid (post-HyperEVM launch)
- Chainlink oracle (if available)

**Outlier Rejection**:
- If any price deviates >2% from median, mark as outlier
- Ignore top/bottom outliers before computing TWAP
- Staleness timeout: 100 blocks (marks oracle stale)

---

## VIII. LEGAL FRAMEWORK & FOUNDATION

### A. √ãTRID Foundation Structure

**Entity Type**: Delaware Non-Profit Corporation (or equivalent jurisdiction)

**Mission**: Facilitate √ãTRID peer network, enforce GPLv3 open-source license, execute governance decisions

**Governance**:
- Board of 9 Decentralized Directors (elected annually)
- Committees: Technical, Legal, Community, Security
- Annual budget: Funded by Consensus Day allocation

### B. Intellectual Property

**License**: GNU General Public License v3 (GPLv3)
- All code remains open-source in perpetuity
- Derivatives must also be open-source
- Commercial use allowed with proper attribution
- No patents filed; software remains patent-free

**Trademarks**:
- √ãTRID‚Ñ¢ is trademarked
- √ãDSC‚Ñ¢ is trademarked
- FODDoS‚Ñ¢ is trademarked
- All trademarks managed by Foundation

### C. Community Developer Agreements

**Contributor License Agreement (CLA)**:
- All contributors must sign CLA
- Contributions licensed under GPLv3
- Foundation gets perpetual license
- Contributor retains copyright

**Bug Bounty Program**:
- Low severity: 0.1-1 √âTR
- Medium severity: 1-5 √âTR
- High severity: 5-50 √âTR
- Critical severity: 50-500 √âTR
- Foundation Treasury funds bounties

---

## IX. SECURITY & NETWORK SAFETY

### A. Post-Quantum Cryptography

**Hash Functions**:
- SHA-3 (Keccak) for general hashing
- Blake2b for performance-critical paths

**Signatures**:
- EdDSA (Ed25519) for most signatures
- SPHINCS+ (lattice-based) for post-quantum resistance
- Hybrid approach during transition period

**Key Derivation**:
- HKDF-Blake2b for key derivation
- BIP39 mnemonic seed phrases (128-bit minimum)
- BIP44 hierarchical deterministic wallets

### B. Circuit Breaker System

**Automated Safety Mechanisms**:
- Reserve ratio drops below 100%: 50% redemption cap
- Reserve ratio drops below 90%: Full pause (emergency mode)
- Pending redemptions exceed 10,000: Throttle new redemptions
- Oracle staleness >100 blocks: Fallback to 7-day TWAP

**Manual Interventions** (DD-authorized only):
- Emergency pause requires 5/9 DD signatures
- Pause can last maximum 7 days
- Must notify community within 1 hour
- Post-pause audit required

### C. Penalty & Slashing System

**Validator Penalties**:
- Missing block proposal: 0.1% of annual stake
- Double-sign attempt: 1% of annual stake
- 3 consecutive slashes: Node removal for 1 year

**Voter Penalties**:
- Absentee voting (no vote cast): 0.05% annual stake
- Invalid vote submission: 0.1% annual stake
- Penalties redistributed to compliant voters

---

## X. TECHNICAL SPECIFICATIONS

### A. Network Parameters

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Block Time | 12 seconds | Balance between finality and throughput |
| Finality Time | ~5 minutes | ASF consensus with ~25 validators |
| Max Block Size | 4 MB | Substrate standard, flexible via governance |
| State Version | Substrate v27+ | Post-quantum ready |
| Network Port | 30333 (default) | Standard Substrate P2P |
| RPC Port | 9933 (default) | JSON-RPC endpoint |
| WS Port | 9944 (default) | WebSocket gateway |

### B. Account Specifications

**Account Types**:

1. **EBCA** (External Blockchain Account)
   - Any non-√ãTRID keypair
   - Generated outside √ãTRID Key Generation Protocol
   - Can receive but not validate
   - Example: MetaMask wallet, Ethereum address

2. **RCA** (Root Chain Account)
   - Generated by √ãTRID Key Generation Protocol
   - Valid on FlareChain only
   - Can vote, stake, validate

3. **SCA** (Side Chain Account)
   - Account on specific PBC
   - Different keypair per PBC allowed
   - Faster local transactions

4. **SSCA** (Smart Side Chain Account)
   - Automated smart contract accounts
   - Controlled by √ãtwasmVM logic
   - No private key (code-governed)

**Account Format**:
- SS58 address format (Substrate standard)
- Checksum included for typo detection
- Examples:
  - FlareChain: \`1XY...\` prefix
  - PBC-EDSC: \`3AB...\` prefix

### C. Transaction Fees

**Base Fee Structure**:
- Extrinsic encoding: 0.01 √âTR per kilobyte
- Byte multiplier: 0.001 √âTR per byte
- Weight multiplier: 0.00001 √âTR per weight unit
- Priority tip: Optional (for faster inclusion)

**Example Costs**:
- Simple transfer: ~0.1 √âTR
- Smart contract call: 1-100 √âTR (depends on complexity)
- Cross-chain message: 0.25-1 √âTR

**Fee Destination**:
- 80% to active validators
- 20% to Foundation treasury

---

## XI. DEPLOYMENT ROADMAP

### Phase 1: Core Infrastructure (Weeks 1-4) ‚úÖ COMPLETE
- ‚úÖ DETR p2p networking stack
- ‚úÖ OpenDID identity system
- ‚úÖ Core cryptography & security
- ‚úÖ FlareChain reference implementation

### Phase 2: Economics & Governance (Weeks 5-8) ‚úÖ COMPLETE
- ‚úÖ √âTR token implementation
- ‚úÖ Consensus Day voting system
- ‚úÖ Distribution Pay engine
- ‚úÖ DD election mechanism

### Phase 3: Stablecoins & EDSC (Weeks 9-16) ‚úÖ COMPLETE
- ‚úÖ pallet-edsc-token (core minting)
- ‚úÖ pallet-edsc-receipts (SBT system)
- ‚úÖ pallet-edsc-redemption (3-path engine)
- ‚úÖ pallet-edsc-oracle (TWAP pricing)
- ‚úÖ pallet-edsc-checkpoint (state sync)
- ‚úÖ pallet-circuit-breaker (safety controls)

### Phase 4: Partition Burst Chains (Weeks 17-20) ‚úÖ COMPLETE
- ‚úÖ Build custom PBC infrastructure
- ‚úÖ Implement PBC-specific governance
- ‚úÖ Deploy first community PBC

### Phase 5: Legal & DAO Registration (Weeks 21-24) ‚úÖ COMPLETE
- ‚úÖ Register √ãTRID Foundation (Delaware)
- ‚úÖ Finalize legal agreements
- ‚úÖ SEC/regulatory review (if applicable)

### Phase 6: Smart Contracts & √ãtwasmVM (Weeks 25-28) ‚úÖ COMPLETE
- ‚úÖ Deploy √ãtwasmVM runtime
- ‚úÖ Release smart contract toolkit
- ‚úÖ Community contract deployments

### Phase 7: AI Governance Integration (Weeks 29-32) ‚úÖ COMPLETE
- ‚úÖ pallet-ai-authority (AI node attestation)
- ‚úÖ pallet-attestation-verifier (AI proof verification)
- ‚úÖ pallet-poc-oracle (Proof-of-Computation oracle)

### Phase 8: Mainnet Launch (Week 32+) ‚úÖ COMPLETE
- ‚úÖ Full mainnet deployment
- ‚úÖ Token exchange listings
- ‚úÖ Foundation handoff to community DDs

---

## XII. PROTOCOL AMENDMENTS & HARD FORKS

### A. Amendment Process

**Soft Forks** (Governance-only, no code changes):
- Requires 50% + 1 consensus on Consensus Day ballot
- Takes effect Jan 1st following vote
- Examples: Adjust validator count, change oracle sources

**Hard Forks** (Code changes, consensus required):
- Requires 66% supermajority on Consensus Day ballot
- 90-day security audit period
- Community notice at least 30 days before deployment
- Validators must upgrade or fork off

**Emergency Hard Forks** (Security only):
- DD board (5/9 majority) can authorize emergency hard fork
- Requires 24-hour community vote confirmation
- Only for critical security vulnerabilities
- Post-fork audit mandatory

### B. Fork Management

**Version Numbers**:
- Major.Minor.Patch (e.g., 1.2.3)
- Major version: Hard fork or major protocol change
- Minor version: New features, soft fork
- Patch version: Bug fixes

**Rollback Procedures**:
- Validators can vote to rollback within 1 hour of fork
- Requires 66% consensus on rollback ballot
- State rolled back to pre-fork checkpoint

---

## XIII. CLOSING STATEMENT

The √ãTRID Protocol represents a fundamental reimagining of blockchain governance. By combining decentralized democracy (Consensus Day), non-hierarchical leadership (9-person DD board), and technical innovation (DETR p2p, ASF consensus, √´twasmVM), √ãTRID offers a genuine alternative to centralized or semi-centralized blockchain projects.

This charter establishes the immutable rules. Deviation requires consensus. Evolution is democratic. The network remains free and open, in perpetuity.

**"We are in a unique period in which power can be reclaimed by the powerless."**  
‚Äî Eoj Edred, √ãTRID Founder

---

## XIV. APPENDIX: ABBREVIATIONS & DEFINITIONS

| Abbreviation | Definition |
|--------------|-----------|
| **ASF** | Ascending Scale of Finality (consensus algorithm) |
| **DD** | Decentralized Director (board member) |
| **DETR p2p** | Decentralized, Encrypted, Trustless, Resilient Peer-to-Peer |
| **EBCA** | External Blockchain Account |
| **√ãDSC** | √ãtrid Dollar Stablecoin |
| **√âTR** | √ãtrid Coin (native token) |
| **E¬≥20** | Essential Elements to Operate (Reference Implementation) |
| **FODDoS** | Free and Open Decentralized Democracy of Stakeholders |
| **PPFA** | Partition Proof of Authority (8-validator rotation) |
| **PBC** | Partition Burst Chain (sidechain) |
| **RCA** | Root Chain Account |
| **SBT** | Soulbound Token (non-transferable) |
| **SCA** | Side Chain Account |
| **SSCA** | Smart Side Chain Account |
| **TWAP** | Time-Weighted Average Price |
| **√ãtwasmVM** | √ãtrid WebAssembly Virtual Machine |
| **VMw** | Virtual Machine Watts (computation gas) |

---

**END OF √ãTRID PROTOCOL CHARTER**

*This document is the source of truth for all √ãTRID development, governance, and deployment decisions. Changes require Consensus Day supermajority vote. Distributed under GPLv3 open-source license.*

`
    }
        };

    let base_reward = participation_pool * voter_share;
    let final_reward = base_reward * completeness_multiplier;

    Balance::from(final_reward as u128)
}
\`\`\`

**Distribution Components**:
1. **Participation Rewards**: 1% of minted tokens divided among voters
2. **Validator Rewards**: Validators receive 0.5% bonus for participation
3. **Proposer Rewards**: Approved proposals earn 100 √âTR per proposal
4. **Director Stipends**: 9 Directors receive equal shares (total: 0.2% of mint)

**Distribution Example**:

If 100M √âTR minted during Consensus Day:
\`\`\`
Total Minted:            100,000,000 √âTR
Participation Pool (1%):   1,000,000 √âTR ‚Üí Divided among voters
Validator Bonus (0.5%):      500,000 √âTR ‚Üí Divided among validators
Director Stipends (0.2%):    200,000 √âTR ‚Üí 22,222 √âTR per Director
Proposer Rewards:            100 √âTR √ó approved proposals
Remaining:               98,300,000 √âTR ‚Üí Treasury for budgets
\`\`\`

---

## 2. GOVERNANCE ROLES & RESPONSIBILITIES

### Role Hierarchy

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Community (All √âTR Holders)      ‚îÇ
‚îÇ  - Vote on proposals                        ‚îÇ
‚îÇ  - Elect Directors                          ‚îÇ
‚îÇ  - Propose changes (‚â•10k √âTR)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Directors   ‚îÇ   ‚îÇ    Validators    ‚îÇ
‚îÇ  (9 members) ‚îÇ   ‚îÇ  (Active Set)    ‚îÇ
‚îÇ  - Oversee   ‚îÇ   ‚îÇ  - Validate      ‚îÇ
‚îÇ  - Veto      ‚îÇ   ‚îÇ  - Secure        ‚îÇ
‚îÇ  - Emergency ‚îÇ   ‚îÇ  - Vote          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### The Community (Token Holders)

**Power**:
- Vote on all proposals during Consensus Day
- Elect 9 Decentralized Directors annually
- Propose protocol changes (requires ‚â•10,000 √âTR bond)
- Delegate voting power to trusted parties

**Responsibilities**:
- Participate in annual governance
- Review proposals and technical documentation
- Report bugs, vulnerabilities, exploits
- Contribute to ecosystem growth

**Rights**:
- Receive staking rewards
- Access to all governance decisions and data
- Freedom to fork the network (GPLv3)

### Decentralized Directors (The Board)

**Composition**: 9 individuals elected annually

**Requirements**:
- **Minimum stake: 128 √âTR**
- **Must serve as OD Flare Nodes** (Operational Director Flare Nodes)
- Must maintain active participation in network operations

**Term**: 1 year (renewable via re-election)

**Term Limits**:
- **One-year terms**
- **One-year cooldown** between terms
- **Maximum 3 lifetime terms** (cannot serve more than 3 total terms)

**Election Process**:
1. Candidates announce during Pre-Consensus Period (Jan 1 - Oct 31)
2. Community votes on Consensus Day (December 1)
3. Top 9 vote-getters elected
4. Ties resolved by stake-weighted runoff
5. Voting power = Staked √âTR √ó Coinage

**Powers**:
1. **Governance Oversight**: Oversee development and consensus proposals
2. **Protocol Maintenance**: Coordinate security audits, bug bounties
3. **Representation**: Speak for √ãtrid at conferences, media, partnerships
4. **Treasury Management**: Approve budget disbursements (community-authorized)
5. **Emergency Coordination**: Coordinate response to network emergencies

**Limitations**:
- Cannot change protocol without community consensus vote
- Cannot mint tokens outside Consensus Day
- **No hierarchy** among Directors - all decisions are community-driven
- Cannot override community supermajority
- Subject to term limits (max 3 lifetime terms)

**Compensation**:
- **Community-voted salaries** (determined annually on Consensus Day)
- No predetermined amounts - stakeholders decide compensation
- Funded from Consensus Day distribution

**Accountability**:
- Regular public reports required
- Can be removed mid-term via emergency community vote
- All communications public and logged
- Bound by Foundation bylaws

### VALIDITY Nodes (Validators)

**Role**: √ãtrid Partitioned Burst Chain nodes in consensus, syncing with Flare Chain. Responsible for block production, finality attestation, and cross-chain state verification.

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC
- Identity: Must verify on-chain identity (no KYC, just persistent identity)

**Node Statuses**:
- Registered
- Pending
- Sequenced
- Chilled
- De-Sequenced
- Re-Sequenced

**Rewards**:
\`\`\`rust
fn calculate_validator_reward(
    validator: &Validator,
    epoch_duration: BlockNumber,
    total_validator_pool: Balance,
) -> Balance {
    // Base reward proportional to stake
    let stake_ratio = validator.stake / total_active_stake();
    let base_reward = total_validator_pool * stake_ratio;

    // Uptime multiplier (0.90 - 1.10)
    let uptime_multiplier = 0.9 + (validator.uptime - 0.95).max(0.0) * 2.0;

    // Finality contribution (signed blocks / expected blocks)
    let finality_multiplier = validator.blocks_signed / validator.blocks_expected;

    // Final reward
    base_reward * uptime_multiplier * finality_multiplier
}
\`\`\`

**Slashing**:
- **Downtime**: -1% stake per day offline (after 24h grace period)
- **Equivocation**: -10% stake for double-signing blocks
- **Malicious Behavior**: -50% stake + removal for provable attacks
- **Censorship**: -5% stake for ignoring valid transactions

### Common Stake Peers

**Role**: Stakeholders who participate in governance without running full node infrastructure

**Requirements**:
- **Minimum stake: 1+ √âTR**

**Privileges**:
- Voting on proposals during Consensus Day
- Campaigning for proposals
- Reporting faults and issues
- Earning rewards based on stake, coinage, and activity

**Voting Power Formula**:
\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where coinage represents how long tokens have been staked (time-weighted stake)
- Must run full nodes for FlareChain + ‚â•3 PBCs
- Must respond to verification requests within 10 blocks

**Rewards**:
- 0.1% fee on all cross-chain transactions
- Proportional to verification work performed
- Paid from cross-chain transaction fees

**Slashing**:
- -20% stake for incorrect verification
- -50% stake for colluding to pass invalid proofs

### The Foundation (Pre-Mainnet Only)

**Role**: Bootstrap the network until first Consensus Day

**Powers**:
- Set initial parameters (inflation, fees, block times)
- Deploy initial infrastructure
- Fund initial development
- Conduct security audits

**Sunset Clause**:
- Foundation dissolves after first successful Consensus Day
- All remaining funds transferred to community treasury
- No ongoing authority or control

---

## 3. FISCAL CYCLE & TREASURY MANAGEMENT

### Treasury Architecture

**Treasury Account**: On-chain multisig controlled by 9 Directors (6-of-9 threshold)

**Funding Sources**:
1. **Transaction Fees**: 50% of all fees ‚Üí Treasury (50% burned)
2. **Consensus Day Minting**: Approved budgets minted to treasury
3. **Validator Slashing**: 50% of slashed stakes ‚Üí Treasury (50% burned)
4. **Cross-Chain Fees**: 10% of bridge fees ‚Üí Treasury

**Treasury Balance Formula**:
\`\`\`rust
fn calculate_treasury_balance() -> Balance {
    let inflows = transaction_fees * 0.5
                + consensus_day_mint
                + slashing_proceeds * 0.5
                + bridge_fees * 0.1;

    let outflows = budget_disbursements
                 + validator_rewards
                 + director_stipends
                 + emergency_expenses;

    previous_balance + inflows - outflows
}
\`\`\`

### Fiscal Year Cycle

**Fiscal Year**: December 1st ‚Üí November 30th (aligned with Consensus Day)

**Budget Categories**:
1. **Development** (40% of budget): Core protocol, tools, libraries
2. **Marketing** (20% of budget): Education, outreach, partnerships
3. **Operations** (15% of budget): Infrastructure, monitoring, support
4. **Grants** (15% of budget): Community projects, research, ecosystem
5. **Emergency Reserve** (10% of budget): Held for crisis response

**Budget Approval Process**:
1. **Consensus Day**: Community votes on budget allocation per category
2. **Director Oversight**: Directors approve individual disbursements
3. **Quarterly Review**: Directors publish spending reports every 3 months
4. **Annual Audit**: Third-party audit published before next Consensus Day

### Treasury Transparency

**All treasury actions emit events**:
\`\`\`rust
enum TreasuryEvent {
    Deposit { source: DepositSource, amount: Balance },
    Disbursement { category: BudgetCategory, recipient: AccountId, amount: Balance },
    DirectorVote { director: AccountId, proposal_id: u64, vote: bool },
    QuarterlyReport { quarter: u8, total_spent: Balance, category_breakdown: Vec<(BudgetCategory, Balance)> },
}
\`\`\`

**Public Dashboard**:
- Real-time treasury balance
- All incoming/outgoing transactions
- Budget vs. actual spending per category
- Director voting records
- Historical trends (YoY comparison)

### Mint and Burn Dynamics

**Minting Events**:
1. **Consensus Day**: Annual minting for approved budgets
2. **Emergency Minting**: Directors can mint (7/9 vote) in crisis (max 1% of supply)

**Burning Events**:
1. **Transaction Fees**: 50% of all fees burned
2. **Validator Slashing**: 50% of slashed stakes burned
3. **Deflationary Votes**: Community can vote to burn treasury reserves

**Net Supply Formula**:
\`\`\`rust
fn calculate_net_supply_change(epoch: Epoch) -> i128 {
    let minted = consensus_day_mint + emergency_mint;
    let burned = transaction_fees * 0.5 + slashing_proceeds * 0.5 + voluntary_burns;

    (minted as i128) - (burned as i128)
}
\`\`\`

**Target**: Long-term supply should stabilize or decrease slowly (deflationary tendency)

---

## 4. TOKEN ECONOMICS (√âTR, EDSC, VMw)

### √âTR (√ãtrid Token)

**Purpose**: Governance, staking, gas fees

**Total Supply**: 1 Billion √âTR (initial), subject to inflation/deflation

**Initial Distribution**:
\`\`\`
Genesis Block:           1,000,000,000 √âTR

Allocation:
- Public Sale (40%):       400,000,000 √âTR
- Foundation (25%):        250,000,000 √âTR (4-year vesting)
- Team (15%):              150,000,000 √âTR (3-year vesting)
- Validators (10%):        100,000,000 √âTR (incentive pool)
- Ecosystem Grants (10%):  100,000,000 √âTR (unlocked)
\`\`\`

**Inflation/Deflation**:
- **Inflation**: Voted annually (0-5% cap), minted on Consensus Day
- **Deflation**: Transaction fees + slashing continuously burned
- **Net Effect**: Tends toward slight deflation long-term

**Use Cases**:
1. **Staking**: Lock √âTR to become validator or voter
2. **Gas Fees**: Pay for transactions (measured in VMw, priced in √âTR)
3. **Governance**: Vote on proposals during Consensus Day
4. **Reserve Asset**: Held in multi-asset treasury backing EDSC stablecoin

### EDSC (√ãtrid Dollar Stablecoin)

**Purpose**: Stable unit of account for payments, contracts

**Peg**: $1.00 USD (maintained by direct reserve buy/sell + arbitrage)

**Backing Model**: Treasury-backed with 100% backing from organic purchases (no pre-funding required)

**Reserve Infrastructure**:

EDSC is backed by a diversified multi-asset reserve managed through two specialized pallets:

1. **pallet-multiasset-reserve**: Manages reserve composition and automated rebalancing
2. **pallet-reserve-backed-token**: Handles EDSC purchase/redemption and reserve management

**Reserve Composition**:
\`\`\`
Target Allocation (accumulates organically from purchases):
- 30% USDC (stablecoin purchases)
- 25% ETH (bridged from ETH-PBC)
- 20% BTC (bridged from BTC-PBC)
- 15% SOL (bridged from SOL-PBC)
- 10% Other assets (governance-approved)

Rebalancing:
- Triggered when deviation exceeds 5%
- Automated via pallet-multiasset-reserve
- Governance can adjust allocation strategy
\`\`\`

**Allocation Strategies**:
- **EqualWeight**: Equal distribution across all reserve assets
- **MarketCapWeighted**: Weight by market capitalization
- **RiskAdjusted**: Weight by volatility/risk metrics
- **Custom**: Custom weights set by governance vote

**Purchase Process**:
\`\`\`rust
fn purchase_edsc(
    payment_token: AssetId,
    payment_amount: Balance
) -> Result<Balance, Error> {
    // Get payment token price from oracle
    let token_price_usd = oracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price_usd;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd; // 1 EDSC = $1.00

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * 10 / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    transfer_to_reserve(caller, payment_token, payment_amount)?;

    // Release EDSC from reserve vault to buyer
    release_from_vault(caller, net_edsc)?;

    // Reserve automatically rebalances if needed
    if should_rebalance() {
        trigger_rebalance()?;
    }

    Ok(net_edsc)
}
\`\`\`

**Redemption Process**:
\`\`\`rust
fn redeem_edsc(
    edsc_amount: Balance,
    preferred_payment: AssetId
) -> Result<Balance, Error> {
    // Burn EDSC from user
    burn_edsc(caller, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * 10 / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price
    let token_price = oracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    transfer_from_reserve(caller, preferred_payment, payment_amount)?;

    Ok(payment_amount)
}
\`\`\`

**Treasury-Backed Parameters**:
\`\`\`
Target Backing Ratio:    100% (purchase value)
Purchase Price:          $1.00 per EDSC
Redemption Price:        $1.00 per EDSC
Purchase Fee:            0.1% (goes to treasury)
Redemption Fee:          0.1% (goes to treasury)

Example:
User purchases 1000 EDSC with USDC:
‚Üí User sends: 1000 USDC ($1000)
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: 1000 USDC backing
‚Üí Backing ratio: 100% ($1000 backing 999 circulating EDSC)
\`\`\`

**Stability Mechanisms**:
1. **Multi-Asset Reserve**: Reduces correlation risk compared to single-asset backing
2. **Automated Rebalancing**: Maintains target allocations via pallet-multiasset-reserve
3. **Direct Purchase/Redemption**: Reserve always buys/sells at $1.00, maintaining peg
4. **Organic Backing**: 100% backing accumulates from user purchases (no pre-funding)
5. **Purchase/Redemption Fees**: 0.1% fees prevent spam while generating treasury revenue
6. **No Liquidations**: Simple buy/sell model eliminates liquidation risk
7. **Arbitrage**: Price deviations create profitable arbitrage opportunities
8. **DEX Integration**: FlareSwap enables efficient √âTR/EDSC trading and price discovery

**Reserve-Backed Token Framework**:

Beyond EDSC, the reserve infrastructure enables creation of diverse synthetic assets:

**Synthetic Asset Types**:
- **Stablecoins**: EDSC (USD), EEUR (Euro), EGBP (Pound)
- **Commodities**: EXAU (Gold), EXAG (Silver), EXOIL (Oil)
- **Equities**: ETSLA (Tesla), EAAPL (Apple), EGOOG (Google)
- **Indices**: ES&P (S&P 500), ENASDAQ (Nasdaq), EDJI (Dow Jones)

**Governance Controls**:
- Whitelisting of reserve assets (Consensus Day vote required)
- Adjustment of backing ratios per synthetic
- Rebalancing strategy selection
- Emergency pause of purchase/redemption

### VMw (Virtual Machine Watts)

**Purpose**: Measure computational cost (gas metering)

**Definition**: 1 VMw = 1 Watt-second of CPU energy

**Pricing**:
\`\`\`rust
fn calculate_gas_price() -> Balance {
    // Dynamic pricing based on block fullness
    let block_utilization = current_block_vmw / max_block_vmw; // 0.0 - 1.0

    // Base price: 1 VMw = 0.000001 √âTR
    let base_price = 1_000_000_000_000u128; // 1e-6 √âTR in plancks

    // Price increases exponentially with utilization
    let surge_multiplier = if block_utilization > 0.75 {
        1.0 + ((block_utilization - 0.75) * 8.0)
    } else {
        1.0
    };

    Balance::from((base_price as f64 * surge_multiplier) as u128)
}
\`\`\`

**Block Limits**:
- **Max VMw per block**: 10,000,000 VMw
- **Target utilization**: 50% (5,000,000 VMw)
- **Surge pricing**: Kicks in above 75% utilization

**Example Transaction Costs**:
\`\`\`
Simple Transfer:           100 VMw   ‚âà 0.0001 √âTR   ($0.001 at $10/√âTR)
Token Swap:              5,000 VMw   ‚âà 0.005 √âTR    ($0.05)
Complex Contract:       50,000 VMw   ‚âà 0.05 √âTR     ($0.50)
Cross-Chain Bridge:    200,000 VMw   ‚âà 0.2 √âTR      ($2.00)
\`\`\`

---

## 5. PROPOSAL SYSTEM & VOTING MECHANISMS

### Proposal Lifecycle

\`\`\`
1. Draft ‚Üí 2. Submission ‚Üí 3. Discussion ‚Üí 4. Voting ‚Üí 5. Execution
   (Off-chain)  (Registration)   (48h window)    (12h vote)   (Minting + Distribution)
\`\`\`

### Proposal Template

**Minimum Requirements**:
\`\`\`markdown
# Proposal Title (max 100 chars)

## Summary (max 300 chars)
One-paragraph overview accessible to all voters.

## Motivation
Why is this proposal necessary? What problem does it solve?

## Specification
Technical details. How will this be implemented?

## Budget Request (if applicable)
Amount: _______ √âTR
Breakdown:
  - Development: _______ √âTR
  - Audit: _______ √âTR
  - Deployment: _______ √âTR

## Implementation Timeline
Phase 1: (date range) - Milestone 1
Phase 2: (date range) - Milestone 2
...

## Success Criteria
How will we know this proposal succeeded?

## Risks & Mitigations
What could go wrong? How will we address it?

## Supporting Validators (min 3)
- Validator 1: [address]
- Validator 2: [address]
- Validator 3: [address]
\`\`\`

### Voting Rules

**Vote Types**:
1. **Yes**: Support the proposal
2. **No**: Reject the proposal
3. **Abstain**: Count toward quorum but not approval

**Quadratic Voting** (Optional, for contentious issues):
\`\`\`rust
fn calculate_quadratic_vote_cost(num_votes: u32) -> Balance {
    // Cost increases quadratically
    // 1 vote = 1 √âTR, 2 votes = 4 √âTR, 3 votes = 9 √âTR, etc.
    let cost_per_vote = num_votes * num_votes;
    Balance::from(cost_per_vote as u128 * VOTE_COST_BASE)
}
\`\`\`

**Conviction Voting** (Optional, for long-term decisions):
\`\`\`rust
enum Conviction {
    None,       // 1x voting power, unlock immediately
    Locked1x,   // 1x voting power, locked 1 epoch after vote
    Locked2x,   // 2x voting power, locked 2 epochs
    Locked4x,   // 4x voting power, locked 4 epochs
    Locked8x,   // 8x voting power, locked 8 epochs
}
\`\`\`

### Proposal Execution

**Automatic Execution**:
- If proposal approved with quorum ‚Üí Executed in Phase 3 (Minting)
- If proposal rejected ‚Üí Bond returned (if >5% quorum), proposal archived
- If proposal doesn't reach quorum ‚Üí Bond slashed, proposal discarded

**Manual Execution** (for protocol upgrades):
- Directors + validators coordinate deployment
- Upgrade scheduled for specific block height
- All nodes must upgrade before deadline

---

## 6. REWARD DISTRIBUTION & SLASHING

### Validator Rewards

**Annual Validator Reward Pool**: ~3% of circulating supply

**Distribution**:
\`\`\`rust
fn distribute_epoch_rewards(epoch: Epoch) {
    let total_pool = circulating_supply() * 0.03 / EPOCHS_PER_YEAR;

    for validator in active_validators() {
        let base_reward = total_pool * (validator.stake / total_stake);
        let adjusted_reward = base_reward * validator.performance_multiplier;

        // Pay 50% to validator, 50% to delegators
        pay_reward(validator.account, adjusted_reward * 0.5);
        pay_delegators(validator, adjusted_reward * 0.5);
    }
}
\`\`\`

**Performance Multiplier**:
\`\`\`rust
fn calculate_performance_multiplier(validator: &Validator) -> f64 {
    let uptime_score = validator.uptime; // 0.0 - 1.0
    let finality_score = validator.blocks_signed / validator.blocks_expected;
    let participation_score = if validator.voted_consensus_day { 1.1 } else { 1.0 };

    uptime_score * finality_score * participation_score
}
\`\`\`

### Delegator Rewards

**Delegation Mechanism**:
- Token holders can delegate √âTR to validators
- Validators charge commission (0-100%, set by validator)
- Rewards automatically distributed each epoch

**Commission Structure**:
\`\`\`rust
fn distribute_delegation_rewards(validator: &Validator, total_reward: Balance) {
    let commission_rate = validator.commission; // e.g., 0.10 = 10%
    let commission_amount = total_reward * commission_rate;
    let delegator_pool = total_reward - commission_amount;

    // Pay commission to validator
    pay_reward(validator.account, commission_amount);

    // Distribute remaining to delegators proportionally
    for delegator in validator.delegators() {
        let delegator_share = delegator.stake / validator.total_delegated;
        let delegator_reward = delegator_pool * delegator_share;
        pay_reward(delegator.account, delegator_reward);
    }
}
\`\`\`

### Slashing Conditions

**Offense Types**:

| Offense | Severity | Slash Amount | Cooldown |
|---------|----------|--------------|----------|
| Downtime (>24h) | Low | 1% per day | 7 days |
| Missed blocks (>10%) | Low | 0.5% | 3 days |
| Equivocation (double-sign) | High | 10% | 30 days |
| Invalid finality vote | High | 5% | 14 days |
| Censorship (provable) | Medium | 5% | 14 days |
| Coordinated attack | Critical | 50% + removal | Permanent ban |

**Slashing Execution**:
\`\`\`rust
fn execute_slash(
    validator: AccountId,
    offense: OffenseType,
    evidence: Vec<u8>,
) -> Result<(), Error> {
    // Verify evidence
    verify_offense_evidence(offense, evidence)?;

    // Calculate slash amount
    let slash_amount = match offense {
        OffenseType::Downtime => validator.stake * 0.01,
        OffenseType::Equivocation => validator.stake * 0.10,
        OffenseType::MaliciousAttack => validator.stake * 0.50,
        // ... other offenses
    };

    // Execute slash
    burn_tokens(validator, slash_amount * 0.5); // 50% burned
    transfer_to_treasury(slash_amount * 0.5);   // 50% to treasury

    // Apply cooldown
    apply_validator_cooldown(validator, offense.cooldown_period);

    // Emit event
    emit_event(Event::ValidatorSlashed {
        validator,
        offense,
        amount: slash_amount,
        timestamp: current_block(),
    });

    Ok(())
}
\`\`\`

### Appeal Process

**Validators can appeal slashing**:
1. Submit appeal within 72 hours (costs 1,000 √âTR bond)
2. Directors review evidence (7/9 vote required to overturn)
3. If appeal successful: slash reversed, bond returned
4. If appeal rejected: bond added to treasury

---

## 7. ECONOMIC SUSTAINABILITY MODEL

### Long-Term Supply Dynamics

**Target**: Slightly deflationary long-term (~1% annual deflation)

**Inflows** (Minting):
- Consensus Day approved budgets: 0-5% per year (voted)
- Emergency minting: <0.1% per year (rare)

**Outflows** (Burning):
- Transaction fees: ~50% of fees (continuous)
- Slashing: ~50% of slashed stakes (episodic)
- Voluntary burns: Community-voted (rare)

**Net Supply Projection**:
\`\`\`
Year 1:  1.00B √âTR (genesis)
Year 2:  1.02B √âTR (+2% voted inflation - 1% burned = +1% net)
Year 3:  1.03B √âTR (+2% inflation - 1.5% burned = +0.5% net)
Year 5:  1.04B √âTR (+1.5% inflation - 2% burned = -0.5% net)
Year 10: 1.00B √âTR (back to genesis, deflationary equilibrium)
\`\`\`

### Fee Market Dynamics

**Transaction Fee Formula**:
\`\`\`rust
fn calculate_transaction_fee(vmw_cost: u64, priority: Priority) -> Balance {
    let base_fee = vmw_cost * get_current_vmw_price(); // Dynamic pricing

    let priority_multiplier = match priority {
        Priority::Low => 0.8,
        Priority::Normal => 1.0,
        Priority::High => 1.5,
        Priority::Urgent => 3.0,
    };

    base_fee * priority_multiplier
}
\`\`\`

**Fee Allocation**:
- 50% burned (deflationary pressure)
- 40% to validators (reward for block production)
- 10% to treasury (public goods funding)

### Economic Security

**Attack Cost Analysis**:

To attack √ãtrid, an adversary must:
1. Acquire >33% of staked √âTR (to disrupt finality)
2. Operate attack for multiple epochs before detection
3. Survive slashing and social coordination against them

**Cost**:
\`\`\`
Assume 40% of supply staked (400M √âTR)
33% of staked = 132M √âTR
At $10/√âTR = $1.32 Billion capital requirement

Cost of attack:
- Capital cost: $1.32B
- Slashing risk: 50% = $660M loss if caught
- Opportunity cost: 8% APY = $105M/year forgone rewards
- Reputation cost: √âTR price crash ‚Üí total loss

Total cost: >$2 Billion for 51% attack
\`\`\`

**Conclusion**: Economic security increases with network value and participation

---

## 8. EMERGENCY PROCEDURES & CRISIS RESPONSE

### Emergency Powers

**Directors Emergency Authority** (7-of-9 vote):
1. **Pause Chains**: Temporarily halt block production (max 72 hours)
2. **Emergency Upgrade**: Deploy hotfix without Consensus Day vote
3. **Slash Malicious Actors**: Immediate slashing for provable attacks
4. **Emergency Mint**: Mint up to 1% of supply for critical bug bounty

### Crisis Response Protocol

**Level 1: Minor Issue** (e.g., validator downtime spike)
- Response Team: On-call validators
- Action: Monitor, alert community
- Timeline: 24-hour resolution

**Level 2: Moderate Issue** (e.g., smart contract exploit)
- Response Team: Directors + Security Team
- Action: Pause affected pallets, deploy patch
- Timeline: 48-hour resolution

**Level 3: Critical Issue** (e.g., consensus failure)
- Response Team: All Directors + Core Developers + Community
- Action: Emergency governance vote, possible chain halt
- Timeline: Immediate action, 7-day resolution

### Social Recovery

**If network becomes compromised beyond repair**:
1. **Snapshot**: Take state snapshot at last known good block
2. **Fork**: Create new chain from snapshot
3. **Migrate**: Community coordinates migration to new chain
4. **Deprecate**: Old chain deprecated, new chain becomes canonical

**GPLv3 Protection**: Anyone can fork and continue the network

---

## 9. CONCLUSION: GOVERNANCE AS A LIVING SYSTEM

### Why This Model Works

1. **Alignment**: Token holders, validators, and users all benefit from network success
2. **Adaptation**: Annual Consensus Day forces regular evolution
3. **Transparency**: All decisions on-chain, all treasury actions public
4. **Resilience**: No single point of failure, multiple layers of accountability
5. **Sustainability**: Self-funding via fees, deflationary tendency prevents inflation

### Comparison to Other Models

| Feature | √ãtrid | Bitcoin | Ethereum | Polkadot |
|---------|-------|---------|----------|----------|
| **Governance** | On-chain annual vote | Off-chain (BIPs) | Off-chain (EIPs) | On-chain (referenda) |
| **Treasury** | Autonomous | None | Foundation-controlled | Autonomous |
| **Inflation** | Voted (0-5%) | Fixed (halving) | Fixed (~1%) | Fixed (~10%) |
| **Participation** | >33% quorum | N/A | ~5% typical | ~10% typical |
| **Emergency Powers** | Directors (7/9) | None | Foundation | Council |

### The Path to Sovereignty

√ãtrid governance is designed to achieve **true decentralization** through:
- **Economic incentives** (rewards for participation)
- **Social accountability** (transparent decisions, elected directors)
- **Technical constraints** (protocol-enforced caps, slashing)
- **Regular rhythm** (annual Consensus Day prevents drift)

**The goal**: A network that governs itself, funds itself, and evolves without relying on any central authority.

---

## APPENDIX A: Consensus Day Checklist

**For Voters**:
- [ ] Review all proposals (published 7 days before Consensus Day)
- [ ] Lock √âTR during Registration Phase (6 hours)
- [ ] Vote on all proposals during Voting Phase (12 hours)
- [ ] Claim participation rewards during Distribution Phase (1 hour)

**For Validators**:
- [ ] Signal participation during Registration Phase
- [ ] Vote on all proposals during Voting Phase
- [ ] Monitor network health during Minting Phase
- [ ] Verify reward distribution during Distribution Phase

**For Directors**:
- [ ] Review all proposals and publish recommendations
- [ ] Monitor quorum and voting during Voting Phase
- [ ] Execute approved budgets during Minting Phase
- [ ] Verify distribution accuracy during Distribution Phase

---

## APPENDIX B: Governance Formulas

### Quorum Calculation
\`\`\`rust
fn quorum_met(proposal: &Proposal) -> bool {
    let community_votes = proposal.total_votes;
    let validator_votes = proposal.validator_count;

    (community_votes >= circulating_supply() * 0.33) &&
    (validator_votes >= active_validator_count() * 0.51)
}
\`\`\`

### Approval Calculation
\`\`\`rust
fn proposal_approved(proposal: &Proposal) -> bool {
    let yes_votes = proposal.yes_votes;
    let total_votes = proposal.yes_votes + proposal.no_votes; // Abstain doesn't count

    let threshold = match proposal.category {
        ProposalCategory::BudgetAllocation => 0.50,
        ProposalCategory::ParameterChange => 0.50,
        ProposalCategory::ProtocolUpgrade => 0.66,
        ProposalCategory::EmergencyAction => 0.66,
    };

    (yes_votes as f64 / total_votes as f64) >= threshold
}
\`\`\`

---

## APPENDIX C: Further Reading

**Volume I**: Conceptual Architecture (Vision, Problem, Solution, Philosophy)
**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime)

**Online Resources**:
- Governance Portal: governance.etrid.org
- Proposal Archive: proposals.etrid.org
- Treasury Dashboard: treasury.etrid.org

---

**End of Volume III**

**√ãtrid Ivory Papers Complete**

---

*"Governance is not a feature to be added. It is the fundamental architecture of coordination."*

---

**Document Status**: ACTIVE PROTOCOL SPECIFICATION
**Next Review**: Consensus Day 2026 (December 1, 2026)

---

## ADDENDUM: TREASURY AND RESERVE SYSTEM IMPLEMENTATION (2025)

### Overview

Following the specifications outlined in this volume, the √ãtrid protocol has implemented a comprehensive treasury and reserve system through four specialized pallets. This addendum documents the technical implementation details, operational procedures, and emergency protocols for these critical financial infrastructure components.

**Implementation Status**: ACTIVE (Deployed Q4 2025)
**Pallet Locations**: \`/Users/macbook/Desktop/etrid/src/pallets/\`

---

### 1. PALLET-TREASURY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-treasury/src/lib.rs\`

The treasury pallet implements the protocol's fiscal management system with multi-signature governance controls.

#### Multisig Architecture

**Configuration**:
- **Directors**: 9 elected representatives (via Consensus Day)
- **Normal Operations**: 6-of-9 approval threshold
- **Emergency Actions**: 7-of-9 approval threshold
- **Term Length**: 1 year (renewable via re-election)

**Director Requirements**:
\`\`\`rust
// Minimum stake: 128 √ãTR
// Must serve as OD Flare Nodes
// Subject to term limits (max 3 lifetime terms)
// One-year cooldown between terms
\`\`\`

**Multisig Controls**:
\`\`\`rust
pub struct Disbursement<T: Config> {
    pub id: u64,
    pub category: BudgetCategory,
    pub recipient: T::AccountId,
    pub amount: BalanceOf<T>,
    pub proposer: T::AccountId,
    pub status: DisbursementStatus,
    pub approval_count: u8,
    pub is_emergency: bool,  // Requires 7/9 instead of 6/9
}
\`\`\`

#### Budget Categories

Default allocations (modifiable via Consensus Day governance):

\`\`\`rust
pub struct BudgetAllocations {
    pub development_bps: u32,      // 40% (4000 basis points)
    pub marketing_bps: u32,        // 20% (2000 basis points)
    pub operations_bps: u32,       // 15% (1500 basis points)
    pub grants_bps: u32,           // 15% (1500 basis points)
    pub emergency_reserve_bps: u32, // 10% (1000 basis points)
}
\`\`\`

**Budget Category Details**:

1. **Development (40%)**:
   - Core protocol development
   - Research and innovation
   - Infrastructure improvements
   - Security audits and bug bounties

2. **Marketing (20%)**:
   - Community growth initiatives
   - Partnership development
   - Educational content
   - Brand awareness campaigns

3. **Operations (15%)**:
   - Team salaries (community-voted)
   - Legal and compliance
   - Administrative expenses
   - Operational infrastructure

4. **Grants (15%)**:
   - Ecosystem development grants
   - Developer support programs
   - Research initiatives
   - Community projects

5. **Emergency Reserve (10%)**:
   - Locked for critical situations
   - Requires 7-of-9 approval for access
   - Protocol security responses
   - Network stability measures

#### Disbursement Workflow

**Step 1: Proposal**
\`\`\`rust
// Any director can propose disbursement
pub fn propose_disbursement(
    origin: OriginFor<T>,
    category: BudgetCategory,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult
\`\`\`

**Step 2: Approval**
\`\`\`rust
// Other directors vote (need 6 total approvals, 7 for emergency)
pub fn approve_disbursement(
    origin: OriginFor<T>,
    disbursement_id: u64,
) -> DispatchResult
\`\`\`

**Step 3: Automatic Execution**
\`\`\`rust
// Executes automatically when threshold reached
if disbursement.approval_count >= threshold {
    Self::execute_disbursement_internal(disbursement_id)?;
}
\`\`\`

**Safeguards**:
- Proposals expire after 7 days if quorum not reached
- Directors cannot approve same proposal twice
- Category allocations checked before disbursement
- All actions emit transparent on-chain events

#### Emergency Withdrawal Procedures

Emergency withdrawals require heightened security:

\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals (higher threshold)
    // Can only withdraw from EmergencyReserve
    // Used for critical protocol emergencies
}
\`\`\`

**Emergency Scenarios**:
- Critical security vulnerabilities
- Protocol-threatening exploits
- Network stability emergencies
- Consensus failure recovery

#### Funding Source Integration

The treasury receives funds from multiple sources:

\`\`\`rust
pub enum FundingSource {
    TransactionFees,      // 50% of all transaction fees
    ConsensusDayMinting,  // Approved budgets from annual vote
    ValidatorSlashing,    // 50% of slashing penalties
    CrossChainFees,       // 10% of bridge transaction fees
    Other,                // Donations, etc.
}
\`\`\`

**Funding Flow Example**:
\`\`\`
Transaction: 1000 √ãTR fee collected
‚Üí 50% (500 √ãTR) burned (deflationary)
‚Üí 40% (400 √ãTR) to validators
‚Üí 10% (100 √ãTR) to treasury

Consensus Day: 100M √ãTR minted
‚Üí 98.3M to treasury for budgets
‚Üí 1.0M to participation rewards
‚Üí 0.5M to validator bonuses
‚Üí 0.2M to director stipends
\`\`\`

#### Storage Items

**Core Storage**:
\`\`\`rust
/// Total √ãTR balance in treasury
TreasuryBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// EDSC stablecoin balance
EdscBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Budget allocation percentages
BudgetAllocationsStorage<T: Config> = StorageValue<_, BudgetAllocations>

/// Category-specific allocated amounts
CategoryAllocations<T: Config> = StorageMap<_, BudgetCategory, BalanceOf<T>>

/// Pending and historical disbursements
Disbursements<T: Config> = StorageMap<_, u64, Disbursement<T>>

/// Director approvals per disbursement
DirectorApprovals<T: Config> = StorageMap<_, u64, BoundedVec<T::AccountId, ConstU32<9>>>

/// Current 9 directors
Directors<T: Config> = StorageValue<_, BoundedVec<T::AccountId, ConstU32<9>>>

/// Emergency reserve balance
EmergencyReserve<T: Config> = StorageValue<_, BalanceOf<T>>
\`\`\`

#### Extrinsics

**Public Functions**:
\`\`\`rust
// Fund treasury from various sources
fund_treasury(source: FundingSource, amount: Balance)

// Director proposes spending
propose_disbursement(category, recipient, amount, description)

// Director approves proposal (6/9 needed)
approve_disbursement(disbursement_id)

// Emergency reserve access (7/9 needed)
emergency_withdrawal(recipient, amount, description)
\`\`\`

**Governance Functions** (Root/Consensus Day only):
\`\`\`rust
// Update budget percentages
set_budget_allocations(allocations: BudgetAllocations)

// Allocate funds to categories
allocate_to_categories(total_amount: Balance)

// Add/remove directors
add_director(director: AccountId)
remove_director(director: AccountId)
\`\`\`

---

### 2. PALLET-MULTIASSET-RESERVE IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-multiasset-reserve/src/lib.rs\`

The multiasset reserve pallet enables diversified reserve management with automatic rebalancing capabilities.

#### Multi-Asset Reserve Management

**Asset Configuration**:
\`\`\`rust
pub struct AssetMetadata {
    pub symbol: BoundedVec<u8, ConstU32<16>>,  // BTC, ETH, etc.
    pub decimals: u8,
    pub is_active: bool,
    pub min_holding: u128,
    pub max_holding: u128,
    pub target_allocation: Permill,
    pub last_rebalance: u32,
}
\`\`\`

**Reserve Composition**:
\`\`\`rust
pub struct AssetHolding {
    pub asset_id: u32,
    pub amount: u128,
    pub value_usd: u128,      // Cached with 8 decimals
    pub last_price_update: u32,
}
\`\`\`

**Supported Asset Types**:
- Native √ãTR token
- Bridged Bitcoin (sBTC)
- Bridged Ethereum (sETH)
- Stablecoins (USDC, USDT)
- Synthetic gold (sXAU)
- Other governance-approved assets

#### Allocation Strategies

Four distinct strategies available:

\`\`\`rust
pub enum AllocationStrategy {
    /// Equal weight allocation (each asset gets equal %)
    EqualWeight = 0,

    /// Market cap weighted (higher cap = higher allocation)
    MarketCapWeighted = 1,

    /// Risk-adjusted (lower volatility = higher allocation)
    RiskAdjusted = 2,

    /// Custom manual allocations (default)
    Custom = 3,
}
\`\`\`

**Strategy Selection**:
\`\`\`rust
// Governance can set strategy via:
pub fn set_allocation_strategy(
    origin: OriginFor<T>,
    strategy_code: u8,  // 0-3 corresponding to enum
) -> DispatchResult
\`\`\`

**Example Custom Allocation**:
\`\`\`
For EDSC backing:
- 40% √ãTR (native token, low correlation)
- 30% sBTC (store of value, established)
- 20% sETH (smart contract ecosystem)
- 10% Other (USDC, sXAU, diversification)
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
/// Triggered when deviation exceeds 5% threshold
#[pallet::constant]
type RebalanceThreshold: Get<Permill>;  // Default: 500 (5%)
\`\`\`

**Rebalancing Logic**:
\`\`\`rust
pub fn needs_rebalancing() -> bool {
    let threshold = T::RebalanceThreshold::get();

    for (asset_id, config) in AssetConfigs::<T>::iter() {
        let current_alloc = Self::get_asset_allocation(asset_id)?;
        let target = config.target_allocation;

        let deviation = if current_alloc > target {
            current_alloc.saturating_sub(target)
        } else {
            target.saturating_sub(current_alloc)
        };

        if deviation > threshold {
            return true;  // Rebalancing needed
        }
    }

    false
}
\`\`\`

**Rebalancing Execution**:
\`\`\`rust
pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    // Check rebalance interval (minimum time between rebalances)
    // Calculate required swaps to reach target allocations
    // Execute swaps via DEX integration
    // Update holdings and emit events
    // Record rebalancing history
}
\`\`\`

#### Oracle Integration

**Price Oracle Dependency**:
\`\`\`rust
trait Config: frame_system::Config + pallet_reserve_oracle::Config {
    // Inherits oracle functionality for real-time pricing
}
\`\`\`

**Price Updates**:
- Real-time asset prices from oracle network
- Cached USD values for performance
- 8 decimal precision for accuracy
- Automatic updates on reserve operations

#### Vault Integration

**Secure Asset Storage**:
- Integration with \`pallet-reserve-vault\` for custody
- Multi-signature controls for asset movements
- Separation of hot/cold storage
- Audit trail for all asset transfers

#### Asset Whitelisting and Position Limits

**Whitelisting**:
\`\`\`rust
/// Governance-controlled asset approval
pub type WhitelistedAssets<T: Config> = StorageMap<
    _, Blake2_128Concat, u32, bool
>;

// Only whitelisted assets can be added to reserve
ensure!(WhitelistedAssets::<T>::get(asset_id), Error::<T>::AssetNotWhitelisted);
\`\`\`

**Position Limits**:
\`\`\`rust
// Per-asset min/max holdings
ensure!(amount >= config.min_holding, Error::<T>::BelowMinimumHolding);
ensure!(amount <= config.max_holding, Error::<T>::ExceedsMaximumHolding);
\`\`\`

**Risk Management**:
- Maximum exposure limits per asset class
- Diversification requirements
- Liquidity constraints
- Correlation monitoring

#### Storage Items

\`\`\`rust
/// Asset configuration registry
AssetConfigs<T: Config> = StorageMap<_, u32, AssetMetadata>

/// Reserve composition (holdings per asset)
ReserveComposition<T: Config> = StorageMap<_, u32, AssetHolding>

/// Current allocation strategy (0=EqualWeight, 1=MarketCapWeighted, 2=RiskAdjusted, 3=Custom)
CurrentStrategy<T: Config> = StorageValue<_, u8>

/// Total reserve value (cached, USD with 8 decimals)
TotalReserveValue<T: Config> = StorageValue<_, u128>

/// Whitelisted assets
WhitelistedAssets<T: Config> = StorageMap<_, u32, bool>

/// Asset count
AssetCount<T: Config> = StorageValue<_, u32>

/// Last rebalance status
LastRebalance<T: Config> = StorageValue<_, RebalanceStatus<BlockNumber>>

/// Rebalancing enabled flag
RebalancingEnabled<T: Config> = StorageValue<_, bool>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Add new asset to reserve
add_asset(asset_id, symbol, decimals, min_holding, max_holding, target_allocation)

// Remove asset from reserve
remove_asset(asset_id)

// Set target allocation for asset
set_target_allocation(asset_id, target: Permill)

// Set allocation strategy
set_allocation_strategy(strategy_code: u8)

// Enable/disable automatic rebalancing
set_rebalancing_enabled(enabled: bool)
\`\`\`

**Public Functions**:
\`\`\`rust
// Deposit asset into reserve
deposit_to_reserve(asset_id, amount)

// Trigger manual rebalance
trigger_rebalance()
\`\`\`

**Restricted Functions** (Governance only):
\`\`\`rust
// Withdraw asset from reserve
withdraw_from_reserve(asset_id, amount)
\`\`\`

---

### 3. PALLET-EDSC-STABILITY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-edsc-stability/src/lib.rs\`

The EDSC stability pallet implements the protocol's stablecoin system with multi-asset reserve backing and peg defense mechanisms.

#### EDSC Stablecoin System

**Peg Target**: $1.00 USD (soft peg maintained via arbitrage and stability mechanisms)

**Reserve Architecture**:
\`\`\`rust
pub struct ReserveComposition {
    pub etr_allocation: u16,    // 40% (4000 basis points)
    pub sbtc_allocation: u16,   // 30% (3000 basis points)
    pub seth_allocation: u16,   // 20% (2000 basis points)
    pub other_allocation: u16,  // 10% (1000 basis points)
}
\`\`\`

**Multi-Asset Reserve Backing**:
- **40% √ãTR**: Native token, governance voting power
- **30% sBTC**: Synthetic Bitcoin, store of value
- **20% sETH**: Synthetic Ethereum, DeFi integration
- **10% Other**: USDC, sXAU, diversification assets

#### Treasury-Backed Parameters

\`\`\`rust
/// Target backing ratio: 100% (10000 basis points)
#[pallet::constant]
type TargetBackingRatio: Get<u16>;  // Default: 10000 (100%)

/// Purchase fee: 0.1% (10 basis points)
#[pallet::constant]
type PurchaseFee: Get<u16>;  // Default: 10

/// Redemption fee: 0.1% (10 basis points)
#[pallet::constant]
type RedemptionFee: Get<u16>;  // Default: 10
\`\`\`

**Purchase/Redemption Example**:
\`\`\`
To purchase 1000 EDSC:
‚Üí User sends: $1000 in BTC/ETH/SOL/USDC
‚Üí Purchase fee: $1 (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Reserve holds: $1000 backing

To redeem 999 EDSC:
‚Üí User burns: 999 EDSC
‚Üí Redemption fee: $0.999 (0.1%)
‚Üí User receives: $998.001 in preferred crypto
‚Üí Reserve releases: $998.001 from holdings

Key Differences from Over-Collateralized Model:
- No upfront capital required to launch
- Backing accumulates organically from purchases
- No liquidations (direct buy/sell only)
- 100% backing ratio (not 150%)
- No debt positions or interest charges
\`\`\`

#### Interest Rate Adjustments for Peg Defense

**Dynamic Interest Rates**:
\`\`\`rust
/// Base interest rate (annual, in basis points)
#[pallet::constant]
type BaseInterestRate: Get<u16>;  // Default: 200 (2% annual)
\`\`\`

**Peg Defense Mechanism**:
\`\`\`rust
pub fn adjust_interest_rate(
    origin: OriginFor<T>,
    new_rate: u16,
) -> DispatchResult {
    // If EDSC > $1.01: Lower rate to encourage minting
    // If EDSC < $0.99: Raise rate to encourage burning

    let price = EDSCPrice::<T>::get();  // In cents (100 = $1.00)

    if price > 101 {
        // Trading above peg: lower interest to encourage minting
        new_rate = current_rate.saturating_sub(50);  // Reduce by 0.5%
    } else if price < 99 {
        // Trading below peg: raise interest to encourage burning
        new_rate = current_rate.saturating_add(50);  // Increase by 0.5%
    }

    InterestRate::<T>::put(new_rate);
}
\`\`\`

**Interest Calculation**:
\`\`\`rust
fn calculate_accrued_interest(
    position: &EDSCPosition<BalanceOf<T>>,
    current_block: u32,
) -> Result<u128, DispatchError> {
    let blocks_elapsed = current_block - position.last_interest_update;
    let blocks_per_year = 5_256_000u128;  // ~6 second blocks

    // Interest = principal * rate * time
    let interest = position.edsc_minted
        .checked_mul(position.interest_rate as u128)?
        .checked_mul(blocks_elapsed as u128)?
        .checked_div(10000)?  // Basis points to decimal
        .checked_div(blocks_per_year)?;

    Ok(interest)
}
\`\`\`

#### Reserve Purchase/Redemption System

**Purchase from Reserve**:
\`\`\`rust
pub fn purchase_edsc(
    origin: OriginFor<T>,
    payment_token: AssetId,
    payment_amount: BalanceOf<T>,
) -> DispatchResult {
    let buyer = ensure_signed(origin)?;

    // Get payment token price from oracle
    let token_price = T::PriceOracle::get_price(payment_token)?;
    let payment_value_usd = payment_amount * token_price;

    // Calculate EDSC amount at $1.00 peg
    let edsc_amount = payment_value_usd;

    // Apply purchase fee (0.1%)
    let fee = edsc_amount * T::PurchaseFee::get() / 10000;
    let net_edsc = edsc_amount - fee;

    // Transfer payment to reserve vault
    T::MultiCurrency::transfer(payment_token, &buyer, &T::ReserveVault::get(), payment_amount)?;

    // Release EDSC from vault to buyer
    T::Currency::transfer(&T::ReserveVault::get(), &buyer, net_edsc)?;

    Ok(())
}
\`\`\`

**Redemption to Reserve**:
\`\`\`rust
pub fn redeem_edsc(
    origin: OriginFor<T>,
    edsc_amount: BalanceOf<T>,
    preferred_payment: AssetId,
) -> DispatchResult {
    let redeemer = ensure_signed(origin)?;

    // Burn EDSC from user
    T::Currency::burn_from(&redeemer, edsc_amount)?;

    // Calculate redemption value ($1.00 per EDSC)
    let redemption_value_usd = edsc_amount;

    // Apply redemption fee (0.1%)
    let fee = redemption_value_usd * T::RedemptionFee::get() / 10000;
    let net_value = redemption_value_usd - fee;

    // Get payment token price and amount
    let token_price = T::PriceOracle::get_price(preferred_payment)?;
    let payment_amount = net_value / token_price;

    // Transfer crypto from reserve to user
    T::MultiCurrency::transfer(preferred_payment, &T::ReserveVault::get(), &redeemer, payment_amount)?;

    Ok(())
}
\`\`\`

**Fee Distribution**:
\`\`\`
Purchase Fee: 0.1% ‚Üí Treasury
Redemption Fee: 0.1% ‚Üí Treasury

Example:
User purchases 1000 EDSC with 1000 USDC:
‚Üí Fee: 1 USDC (0.1%)
‚Üí User receives: 999 EDSC
‚Üí Treasury receives: 1 USDC fee
‚Üí Reserve holds: 1000 USDC backing

User redeems 999 EDSC for USDC:
‚Üí Fee: 0.999 USDC (0.1%)
‚Üí User receives: 998.001 USDC
‚Üí Treasury receives: 0.999 USDC fee
‚Üí Reserve releases: 998.001 USDC
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
#[pallet::constant]
type RebalanceThreshold: Get<u16>;  // Default: 500 (5%)

pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    let current = CurrentReserveComposition::<T>::get();
    let target = TargetReserveComposition::<T>::get();

    let deviation = Self::calculate_composition_deviation(&current, &target)?;

    ensure!(
        deviation > T::RebalanceThreshold::get(),
        Error::<T>::RebalancingNotNeeded
    );

    // Execute rebalancing...
}
\`\`\`

**Rebalancing Process**:
1. Calculate current asset allocations
2. Compare to target percentages
3. Determine required swaps
4. Execute trades via DEX
5. Update reserve composition
6. Emit rebalancing events

#### Treasury Integration

**Stability Fees Flow**:
\`\`\`rust
/// Accumulated stability fees for treasury
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

// Interest payments go to stability fees
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(interest_in_collateral);
});
\`\`\`

**Purchase/Redemption Fees Flow**:
\`\`\`rust
// Fees sent to treasury
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(purchase_fee + redemption_fee);
});
\`\`\`

**Fee Collection**:
- Purchase fees from EDSC purchases (0.1%)
- Redemption fees from EDSC redemptions (0.1%)
- Rebalancing fees (if applicable)
- All fees flow to treasury for protocol sustainability

#### Storage Items

\`\`\`rust
/// Main EDSC reserve balance
EDSCReserveBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Current reserve composition
CurrentReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Target reserve composition (governance-updatable)
TargetReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Current backing ratio (basis points)
BackingRatio<T: Config> = StorageValue<_, u16>

/// Reserve vault address (holds initial EDSC supply)
ReserveVault<T: Config> = StorageValue<_, T::AccountId>

/// Circulating EDSC supply (released from vault)
CirculatingEDSCSupply<T: Config> = StorageValue<_, u128>

/// User EDSC balances
EDSCBalances<T: Config> = StorageMap<_, T::AccountId, u128>

/// Purchase/redemption history
TransactionHistory<T: Config> = StorageMap<_, T::AccountId, Vec<EDSCTransaction>>

/// Accumulated stability fees
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

/// Emergency pause flag
EmergencyPaused<T: Config> = StorageValue<_, bool>

/// Rebalancing history
RebalanceHistory<T: Config> = StorageMap<_, u32, RebalanceRecord>

/// Current EDSC price (in cents, 100 = $1.00)
EDSCPrice<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**User Functions**:
\`\`\`rust
// Purchase EDSC from reserve with crypto
purchase_edsc(payment_token: AssetId, payment_amount: Balance)

// Redeem EDSC back to reserve for crypto
redeem_edsc(edsc_amount: Balance, preferred_payment: AssetId)

// Check current reserve backing ratio
get_backing_ratio() -> Result<u16, Error>

// Trigger reserve rebalancing
trigger_rebalance()
\`\`\`

**Governance Functions** (Root only):
\`\`\`rust
// Adjust interest rate for peg defense
adjust_interest_rate(new_rate: u16)

// Emergency pause system
emergency_pause()

// Deactivate emergency pause
deactivate_emergency_pause()

// Update target reserve composition
update_target_composition(new_composition)
\`\`\`

---

### 4. PALLET-CIRCUIT-BREAKER IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-circuit-breaker/src/lib.rs\`

The circuit breaker pallet provides emergency safety controls for the EDSC stability system.

#### Circuit Breaker Statuses

\`\`\`rust
pub enum CircuitStatus {
    /// Normal operation - all functions available
    Normal,

    /// Throttled - limited operations, reduced volume caps
    Throttled,

    /// Paused - critical operations suspended
    Paused,

    /// Emergency - all non-critical operations halted
    Emergency,
}
\`\`\`

**Status Transitions**:
\`\`\`
Normal ‚Üí Throttled:  Reserve ratio drops below 95%
Throttled ‚Üí Paused:  Volume limits exceeded
Paused ‚Üí Emergency:  Reserve ratio drops below 90%
Emergency ‚Üí Normal:  Requires governance approval
\`\`\`

#### Volume Caps

**Hourly and Daily Limits**:
\`\`\`rust
/// Maximum hourly redemption volume (in EDSC)
#[pallet::constant]
type MaxHourlyVolume: Get<u128>;  // Default: 1M EDSC/hour

/// Maximum daily redemption volume (in EDSC)
#[pallet::constant]
type MaxDailyVolume: Get<u128>;  // Default: 10M EDSC/day
\`\`\`

**Volume Tracking**:
\`\`\`rust
pub struct VolumeTracker<BlockNumber> {
    pub hourly_volume: u128,
    pub hourly_start_block: BlockNumber,
    pub daily_volume: u128,
    pub daily_start_block: BlockNumber,
}

pub fn track_volume(amount: u128) -> DispatchResult {
    let mut tracker = RedemptionVolume::<T>::get();

    tracker.hourly_volume = tracker.hourly_volume.saturating_add(amount);
    tracker.daily_volume = tracker.daily_volume.saturating_add(amount);

    // Check limits
    if tracker.hourly_volume > T::MaxHourlyVolume::get() {
        Self::trigger_circuit(b"Hourly volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    if tracker.daily_volume > T::MaxDailyVolume::get() {
        Self::trigger_circuit(b"Daily volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    Ok(())
}
\`\`\`

#### Reserve Ratio Thresholds

**Threshold Configuration**:
\`\`\`rust
/// Reserve ratio threshold for throttling (95%)
#[pallet::constant]
type ThrottleThreshold: Get<u16>;  // Default: 9500 basis points

/// Reserve ratio threshold for emergency pause (90%)
#[pallet::constant]
type EmergencyThreshold: Get<u16>;  // Default: 9000 basis points
\`\`\`

**Automatic Status Updates**:
\`\`\`rust
pub fn check_reserve_ratio(reserve_ratio: u16) -> DispatchResult {
    let current_status = Status::<T>::get();

    // Emergency threshold (90%)
    if reserve_ratio < T::EmergencyThreshold::get() {
        if current_status != CircuitStatus::Emergency {
            Self::trigger_circuit(b"Emergency reserve threshold breached");
            Status::<T>::put(CircuitStatus::Emergency);
        }
        return Err(Error::<T>::ReserveRatioTooLow);
    }

    // Throttle threshold (95%)
    if reserve_ratio < T::ThrottleThreshold::get() {
        if current_status == CircuitStatus::Normal {
            Status::<T>::put(CircuitStatus::Throttled);
        }
    } else {
        // Healthy - return to normal if throttled
        if current_status == CircuitStatus::Throttled {
            Status::<T>::put(CircuitStatus::Normal);
        }
    }

    Ok(())
}
\`\`\`

#### Auto-Pause Mechanisms

**Peg Deviation Auto-Pause**:
\`\`\`rust
/// Emergency pause threshold (10% peg deviation)
#[pallet::constant]
type EmergencyPauseThreshold: Get<u16>;  // Default: 1000 (10%)

// If EDSC price deviates >10% from $1.00, auto-pause
let price = EDSCPrice::<T>::get();  // In cents
let target = 100;  // $1.00

let deviation = if price > target {
    ((price - target) * 10000) / target
} else {
    ((target - price) * 10000) / target
};

if deviation > T::EmergencyPauseThreshold::get() {
    EmergencyPaused::<T>::put(true);
    Self::trigger_circuit(b"Peg deviation exceeded 10%");
}
\`\`\`

**Automatic Triggers**:
1. **Volume Spike**: >1M EDSC redeemed in 1 hour
2. **Reserve Depletion**: Reserve ratio <90%
3. **Peg Break**: EDSC price >$1.10 or <$0.90
4. **Rapid Redemptions**: >100,000 EDSC redemptions per hour
5. **Oracle Failure**: Price feed stale >1 hour

#### Whitelist System

**Whitelist Configuration**:
\`\`\`rust
/// Accounts exempt from circuit breaker restrictions
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

pub fn is_operation_allowed(account: &T::AccountId, amount: u128) -> DispatchResult {
    // Whitelisted accounts bypass restrictions
    if Whitelist::<T>::get(account) {
        return Ok(());
    }

    // Check circuit status for others
    match Status::<T>::get() {
        CircuitStatus::Emergency => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Paused => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Throttled => Ok(()),  // Limited operations allowed
        CircuitStatus::Normal => Ok(()),
    }
}
\`\`\`

**Whitelist Use Cases**:
- Emergency recovery accounts
- Protocol-owned liquidity providers
- Authorized market makers
- Treasury disbursement accounts

#### Storage Items

\`\`\`rust
/// Current circuit breaker status
Status<T: Config> = StorageValue<_, CircuitStatus>

/// Volume tracker for redemptions
RedemptionVolume<T: Config> = StorageValue<_, VolumeTracker<BlockNumber>>

/// Manual pause flag (governance-controlled)
ManualPauseEnabled<T: Config> = StorageValue<_, bool>

/// Whitelist of exempt accounts
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

/// Total circuit trigger count
TriggerCount<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Manually pause circuit
activate_manual_pause()

// Resume normal operations
resume()

// Add account to whitelist
add_to_whitelist(account: AccountId)

// Remove account from whitelist
remove_from_whitelist(account: AccountId)

// Reset circuit breaker
reset_circuit()
\`\`\`

**Automatic Functions** (Called by other pallets):
\`\`\`rust
// Check if operation allowed
is_operation_allowed(account, amount)

// Track redemption volume
track_volume(amount)

// Check reserve ratio thresholds
check_reserve_ratio(reserve_ratio)
\`\`\`

---

### 5. EMERGENCY RECOVERY PROCEDURES

This section documents critical emergency response protocols for the treasury and reserve system.

#### Treasury Emergency Freeze

**Scenario**: Suspected treasury compromise or unauthorized access

**Procedure**:
\`\`\`rust
// 1. Any Director can trigger immediate freeze
pub fn emergency_freeze_treasury() {
    // Pause all disbursements
    // Require 7/9 approval to unfreeze
    // Alert all directors via on-chain event
}

// 2. Investigation period (72 hours maximum)
// - Analyze suspicious transactions
// - Verify director identities
// - Check multisig signatures

// 3. Resolution requires 7/9 directors
pub fn unfreeze_treasury() {
    // Verify 7/9 director approvals
    // Resume normal operations
    // Document incident for transparency
}
\`\`\`

**Multi-Signature Recovery**:
\`\`\`bash
# Generate recovery transaction
etrid-cli treasury emergency-freeze \
  --director-keys /path/to/keys \
  --reason "Suspicious activity detected"

# Requires 7/9 signatures to unfreeze
etrid-cli treasury unfreeze \
  --approvals director1,director2,...,director7 \
  --verify-signatures
\`\`\`

#### Stuck Funds Recovery

**Scenario**: Funds locked due to smart contract bug or runtime upgrade issue

**Emergency Withdrawal Protocol**:
\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals
    // Can only withdraw from EmergencyReserve
    // Full audit trail recorded on-chain

    ensure!(
        disbursement.approval_count >= 7,
        Error::<T>::EmergencyThresholdNotMet
    );

    // Execute emergency transfer
    T::Currency::transfer(&Self::account_id(), &recipient, amount)?;

    // Emit detailed event
    Self::deposit_event(Event::EmergencyWithdrawal(amount, recipient, 7));
}
\`\`\`

**Recovery Steps**:
1. Directors identify stuck funds
2. Create emergency withdrawal proposal
3. Collect 7/9 director approvals
4. Execute recovery transaction
5. Post-mortem analysis and report
6. Protocol upgrade if needed

#### EDSC Peg Break Response

**Scenario**: EDSC price deviates >10% from $1.00 peg

**Response Protocol**:

**Phase 1: Automatic Circuit Breaker (Immediate)**
\`\`\`rust
// Auto-triggered when peg breaks
if edsc_price > 110 || edsc_price < 90 {  // In cents
    EmergencyPaused::<T>::put(true);
    Status::<T>::put(CircuitStatus::Emergency);

    Self::deposit_event(Event::EmergencyPauseActivated {
        triggered_by: system_account,
        reason: b"EDSC peg break >10%",
    });
}
\`\`\`

**Phase 2: Reserve Injection (Directors, <6 hours)**
\`\`\`rust
// Directors vote to inject reserves
pub fn inject_reserves_for_peg(
    amount: BalanceOf<T>,
) -> DispatchResult {
    // Requires 6/9 director approval
    // Deploy reserves to support peg
    // Buy EDSC if <$0.90 or sell if >$1.10
}
\`\`\`

**Phase 3: Interest Rate Adjustment (Immediate)**
\`\`\`rust
// Automatic interest rate response
if edsc_price < 99 {
    // EDSC trading below $1: Raise rates to encourage burning
    new_rate = current_rate.saturating_add(100);  // +1% annual
} else if edsc_price > 101 {
    // EDSC trading above $1: Lower rates to encourage minting
    new_rate = current_rate.saturating_sub(100);  // -1% annual
}

InterestRate::<T>::put(new_rate);
\`\`\`

**Phase 4: Governance Response (24-48 hours)**
- Emergency governance vote (if needed)
- Adjust collateralization requirements
- Modify reserve composition targets
- Implement additional stability mechanisms

#### Validator Payment Failure Recovery

**Scenario**: Validator rewards fail to distribute due to runtime issue

**Manual Distribution Procedure**:
\`\`\`bash
# 1. Identify affected validators and amounts
etrid-cli validator list-pending-rewards \
  --epoch 12345 \
  --output rewards.json

# 2. Create manual distribution proposal
etrid-cli treasury propose-batch-payment \
  --recipients rewards.json \
  --category Operations \
  --description "Manual validator reward distribution for epoch 12345"

# 3. Directors approve (6/9 required)
etrid-cli treasury approve-disbursement \
  --id 42 \
  --director-key /path/to/director/key

# 4. Verify distributions
etrid-cli validator verify-payments \
  --epoch 12345 \
  --check-balances
\`\`\`

**Compensation Protocol**:
- Calculate exact owed amounts per validator
- Include missed staking rewards
- Add compensation for delayed payment (0.1% per day)
- Execute via treasury Operations budget
- Document incident for protocol improvement

#### Consensus Day Failure Recovery

**Scenario**: Consensus Day process fails mid-execution

**Recovery Options**:

**Option 1: Rollback and Retry**
\`\`\`bash
# If failure detected early (within 1 hour)
# Rollback to pre-Consensus Day state
etrid-cli governance rollback-consensus-day \
  --snapshot-block 1234567 \
  --requires-7-of-9-approval

# Schedule retry
etrid-cli governance schedule-consensus-day-retry \
  --date "2025-12-02" \
  --preserve-votes
\`\`\`

**Option 2: Manual Execution**
\`\`\`bash
# If Minting phase fails
etrid-cli governance manual-mint \
  --approved-proposals approved.json \
  --director-approvals 7-of-9

# If Distribution phase fails
etrid-cli governance manual-distribute \
  --rewards rewards.json \
  --verify-totals
\`\`\`

**Option 3: Emergency Governance**
\`\`\`bash
# If complete failure
# Activate emergency governance mode
etrid-cli governance activate-emergency-mode \
  --requires-7-of-9-directors

# Execute critical operations manually
# Schedule special Consensus Day retry
\`\`\`

#### Multi-Signature Transaction System

**Emergency Multi-Sig Setup**:
\`\`\`rust
// 9 Directors with 6-of-9 threshold (normal)
// 7-of-9 threshold for emergency actions

pub struct MultiSigConfig {
    pub signatories: Vec<AccountId>,  // 9 directors
    pub normal_threshold: u8,         // 6
    pub emergency_threshold: u8,      // 7
}

// Create multi-sig transaction
pub fn create_multisig_call(
    call: Box<RuntimeCall>,
    is_emergency: bool,
) -> MultiSigTransaction {
    let threshold = if is_emergency { 7 } else { 6 };

    MultiSigTransaction {
        call,
        threshold,
        approvals: Vec::new(),
        created_at: current_block,
        expires_at: current_block + EXPIRATION_BLOCKS,
    }
}
\`\`\`

**Multi-Sig Emergency Workflow**:
\`\`\`bash
# 1. Create emergency transaction
etrid-cli multisig create \
  --call "treasury.emergency_withdrawal" \
  --threshold 7 \
  --signatories director1,director2,...,director9

# 2. Directors sign (collect 7 signatures)
etrid-cli multisig sign \
  --tx-hash 0x1234... \
  --director-key /path/to/key1

# 3. Execute when threshold reached
etrid-cli multisig execute \
  --tx-hash 0x1234... \
  --verify-signatures 7

# 4. Broadcast to network
etrid-cli multisig broadcast \
  --tx-hash 0x1234... \
  --wait-for-finality
\`\`\`

**Security Considerations**:
- Directors use hardware wallets for signing
- Multi-geographic distribution of signers
- Time-locked execution for certain actions
- Transparent on-chain audit trail
- Social recovery mechanisms
- Regular key rotation procedures

---

### 6. MONITORING AND TRANSPARENCY

#### Real-Time Dashboards

**Treasury Dashboard** (\`treasury.etrid.org\`):
- Total treasury balance (√ãTR + EDSC)
- Budget allocations vs. spending
- Pending disbursement proposals
- Director voting records
- Historical funding sources
- Monthly/yearly spending reports

**Reserve Dashboard** (\`reserve.etrid.org\`):
- Current reserve composition
- Asset allocations vs. targets
- Rebalancing history
- Total reserve value (USD)
- Whitelisted assets
- Oracle price feeds

**EDSC Dashboard** (\`edsc.etrid.org\`):
- Current EDSC price
- Total supply and circulation
- Backing ratio (system-wide)
- Purchase/redemption volume history
- Active transaction count
- Recent large transactions
- Fee revenue (purchase + redemption)

**Circuit Breaker Dashboard** (\`safety.etrid.org\`):
- Current circuit status
- Hourly/daily volume metrics
- Reserve ratio trends
- Trigger count history
- Whitelisted accounts
- Recent status changes

#### On-Chain Transparency

All treasury and reserve operations emit detailed events:

\`\`\`rust
// Treasury Events
Event::FundsDeposited(source, amount)
Event::DisbursementProposed(id, proposer, category, amount, recipient)
Event::DisbursementApproved(id, director, approval_count)
Event::DisbursementExecuted(id, recipient, amount)
Event::EmergencyWithdrawal(amount, recipient, approvals)

// Reserve Events
Event::AssetAdded { asset_id, symbol }
Event::RebalanceTriggered { total_value, assets_count }
Event::ReserveValueUpdated { total_value_usd }

// EDSC Events
Event::EDSCMinted { who, collateral, edsc_amount, interest_rate }
Event::PositionLiquidated { owner, liquidator, edsc_amount, collateral_seized, penalty }
Event::InterestRateAdjusted { old_rate, new_rate, reason }

// Circuit Breaker Events
Event::StatusChanged { old_status, new_status }
Event::CircuitTriggered { reason }
Event::VolumeLimitExceeded { period, current_volume, max_volume }
\`\`\`

#### Audit Reports

**Quarterly Treasury Reports**:
- Total funds received (by source)
- Total funds disbursed (by category)
- Budget utilization rates
- Director approval statistics
- Emergency actions (if any)

**Annual Reserve Audit**:
- Asset holdings verification
- Rebalancing performance
- Oracle price accuracy
- Risk metrics analysis
- Recommendations for improvements

---

### 7. INTEGRATION WITH CONSENSUS DAY

The treasury and reserve systems integrate tightly with the annual Consensus Day governance process:

#### Budget Allocation Updates

During Consensus Day, the community votes on budget allocations:

\`\`\`rust
// After Consensus Day voting concludes:
pub fn update_allocations_from_consensus(
    approved_allocations: BudgetAllocations,
) -> DispatchResult {
    // Validate allocations sum to 100%
    ensure!(approved_allocations.is_valid(), Error::<T>::InvalidBudgetAllocations);

    // Update treasury allocations
    BudgetAllocationsStorage::<T>::put(approved_allocations.clone());

    Self::deposit_event(Event::BudgetAllocationsUpdated(approved_allocations));

    Ok(())
}
\`\`\`

#### Minting Phase Integration

Approved budgets are minted and allocated:

\`\`\`rust
// Called by pallet-consensus-day during Phase 3: Minting
pub fn receive_consensus_day_minting(amount: BalanceOf<T>) -> DispatchResult {
    // Mint to treasury
    let treasury_account = Self::account_id();
    T::Currency::deposit_creating(&treasury_account, amount);

    // Update balance
    TreasuryBalance::<T>::mutate(|balance| {
        *balance = balance.saturating_add(amount);
    });

    // Allocate to categories based on approved percentages
    Self::allocate_to_categories(amount)?;

    Ok(())
}
\`\`\`

#### Reserve Composition Updates

Community can vote to adjust EDSC reserve targets:

\`\`\`rust
// Consensus Day proposal to update reserve composition
pub fn update_target_composition(
    origin: OriginFor<T>,
    new_composition: ReserveComposition,
) -> DispatchResult {
    ensure_root(origin)?;  // Only via governance vote

    // Validate composition sums to 100%
    let total = new_composition.etr_allocation as u32
        + new_composition.sbtc_allocation as u32
        + new_composition.seth_allocation as u32
        + new_composition.other_allocation as u32;

    ensure!(total == 10000, Error::<T>::InvalidReserveComposition);

    TargetReserveComposition::<T>::put(new_composition.clone());

    // Trigger rebalancing to new targets
    Self::trigger_automatic_rebalance()?;

    Ok(())
}
\`\`\`

---

### 8. CONCLUSION

The treasury and reserve system implementation represents a comprehensive financial infrastructure for the √ãtrid protocol. Through four specialized pallets, the system provides:

- **Transparent Governance**: Multi-signature controls with 9 elected Directors
- **Fiscal Sustainability**: Multiple funding sources and disciplined budget management
- **Stablecoin Stability**: Multi-asset reserve backing with automatic rebalancing
- **Risk Management**: Circuit breaker protections and emergency response protocols

This infrastructure enables √ãtrid to operate as a truly self-governing, self-funding decentralized network without relying on centralized entities.

**System Status**: Production-ready (Q4 2025)
**Audit Status**: Pending external security audit
**Documentation**: Complete technical specifications available in pallet source code

---

*"Financial sovereignty begins with transparent, community-controlled treasury management."*

**‚Äì Treasury & Reserve System Implementation Team**
**√ãtrid Foundation**

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    }
        };

    let base_reward = participation_pool * voter_share;
    let final_reward = base_reward * completeness_multiplier;

    Balance::from(final_reward as u128)
}
\`\`\`

**Distribution Components**:
1. **Participation Rewards**: 1% of minted tokens divided among voters
2. **Validator Rewards**: Validators receive 0.5% bonus for participation
3. **Proposer Rewards**: Approved proposals earn 100 √âTR per proposal
4. **Director Stipends**: 9 Directors receive equal shares (total: 0.2% of mint)

**Distribution Example**:

If 100M √âTR minted during Consensus Day:
\`\`\`
Total Minted:            100,000,000 √âTR
Participation Pool (1%):   1,000,000 √âTR ‚Üí Divided among voters
Validator Bonus (0.5%):      500,000 √âTR ‚Üí Divided among validators
Director Stipends (0.2%):    200,000 √âTR ‚Üí 22,222 √âTR per Director
Proposer Rewards:            100 √âTR √ó approved proposals
Remaining:               98,300,000 √âTR ‚Üí Treasury for budgets
\`\`\`

---

## 2. GOVERNANCE ROLES & RESPONSIBILITIES

### Role Hierarchy

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Community (All √âTR Holders)      ‚îÇ
‚îÇ  - Vote on proposals                        ‚îÇ
‚îÇ  - Elect Directors                          ‚îÇ
‚îÇ  - Propose changes (‚â•10k √âTR)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Directors   ‚îÇ   ‚îÇ    Validators    ‚îÇ
‚îÇ  (9 members) ‚îÇ   ‚îÇ  (Active Set)    ‚îÇ
‚îÇ  - Oversee   ‚îÇ   ‚îÇ  - Validate      ‚îÇ
‚îÇ  - Veto      ‚îÇ   ‚îÇ  - Secure        ‚îÇ
‚îÇ  - Emergency ‚îÇ   ‚îÇ  - Vote          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### The Community (Token Holders)

**Power**:
- Vote on all proposals during Consensus Day
- Elect 9 Decentralized Directors annually
- Propose protocol changes (requires ‚â•10,000 √âTR bond)
- Delegate voting power to trusted parties

**Responsibilities**:
- Participate in annual governance
- Review proposals and technical documentation
- Report bugs, vulnerabilities, exploits
- Contribute to ecosystem growth

**Rights**:
- Receive staking rewards
- Access to all governance decisions and data
- Freedom to fork the network (GPLv3)

### Decentralized Directors (The Board)

**Composition**: 9 individuals elected annually

**Requirements**:
- **Minimum stake: 128 √âTR**
- **Must serve as OD Flare Nodes** (Operational Director Flare Nodes)
- Must maintain active participation in network operations

**Term**: 1 year (renewable via re-election)

**Term Limits**:
- **One-year terms**
- **One-year cooldown** between terms
- **Maximum 3 lifetime terms** (cannot serve more than 3 total terms)

**Election Process**:
1. Candidates announce during Pre-Consensus Period (Jan 1 - Oct 31)
2. Community votes on Consensus Day (December 1)
3. Top 9 vote-getters elected
4. Ties resolved by stake-weighted runoff
5. Voting power = Staked √âTR √ó Coinage

**Powers**:
1. **Governance Oversight**: Oversee development and consensus proposals
2. **Protocol Maintenance**: Coordinate security audits, bug bounties
3. **Representation**: Speak for √ãtrid at conferences, media, partnerships
4. **Treasury Management**: Approve budget disbursements (community-authorized)
5. **Emergency Coordination**: Coordinate response to network emergencies

**Limitations**:
- Cannot change protocol without community consensus vote
- Cannot mint tokens outside Consensus Day
- **No hierarchy** among Directors - all decisions are community-driven
- Cannot override community supermajority
- Subject to term limits (max 3 lifetime terms)

**Compensation**:
- **Community-voted salaries** (determined annually on Consensus Day)
- No predetermined amounts - stakeholders decide compensation
- Funded from Consensus Day distribution

**Accountability**:
- Regular public reports required
- Can be removed mid-term via emergency community vote
- All communications public and logged
- Bound by Foundation bylaws

### VALIDITY Nodes (Validators)

**Role**: √ãtrid Partitioned Burst Chain nodes in consensus, syncing with Flare Chain. Responsible for block production, finality attestation, and cross-chain state verification.

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC
- Identity: Must verify on-chain identity (no KYC, just persistent identity)

**Node Statuses**:
- Registered
- Pending
- Sequenced
- Chilled
- De-Sequenced
- Re-Sequenced

**Rewards**:
\`\`\`rust
fn calculate_validator_reward(
    validator: &Validator,
    epoch_duration: BlockNumber,
    total_validator_pool: Balance,
) -> Balance {
    // Base reward proportional to stake
    let stake_ratio = validator.stake / total_active_stake();
    let base_reward = total_validator_pool * stake_ratio;

    // Uptime multiplier (0.90 - 1.10)
    let uptime_multiplier = 0.9 + (validator.uptime - 0.95).max(0.0) * 2.0;

    // Finality contribution (signed blocks / expected blocks)
    let finality_multiplier = validator.blocks_signed / validator.blocks_expected;

    // Final reward
    base_reward * uptime_multiplier * finality_multiplier
}
\`\`\`

**Slashing**:
- **Downtime**: -1% stake per day offline (after 24h grace period)
- **Equivocation**: -10% stake for double-signing blocks
- **Malicious Behavior**: -50% stake + removal for provable attacks
- **Censorship**: -5% stake for ignoring valid transactions

### Common Stake Peers

**Role**: Stakeholders who participate in governance without running full node infrastructure

**Requirements**:
- **Minimum stake: 1+ √âTR**

**Privileges**:
- Voting on proposals during Consensus Day
- Campaigning for proposals
- Reporting faults and issues
- Earning rewards based on stake, coinage, and activity

**Voting Power Formula**:
\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where coinage represents how long tokens have been staked (time-weighted stake)
- Must run full nodes for FlareChain + ‚â•3 PBCs
- Must respond to verification requests within 10 blocks

**Rewards**:
- 0.1% fee on all cross-chain transactions
- Proportional to verification work performed
- Paid from cross-chain transaction fees

**Slashing**:
- -20% stake for incorrect verification
- -50% stake for colluding to pass invalid proofs

### The Foundation (Pre-Mainnet Only)

**Role**: Bootstrap the network until first Consensus Day

**Powers**:
- Set initial parameters (inflation, fees, block times)
- Deploy initial infrastructure
- Fund initial development
- Conduct security audits

**Sunset Clause**:
- Foundation dissolves after first successful Consensus Day
- All remaining funds transferred to community treasury
- No ongoing authority or control

---

## 3. FISCAL CYCLE & TREASURY MANAGEMENT

### Treasury Architecture

**Treasury Account**: On-chain multisig controlled by 9 Directors (6-of-9 threshold)

**Funding Sources**:
1. **Transaction Fees**: 50% of all fees ‚Üí Treasury (50% burned)
2. **Consensus Day Minting**: Approved budgets minted to treasury
3. **Validator Slashing**: 50% of slashed stakes ‚Üí Treasury (50% burned)
4. **Cross-Chain Fees**: 10% of bridge fees ‚Üí Treasury

**Treasury Balance Formula**:
\`\`\`rust
fn calculate_treasury_balance() -> Balance {
    let inflows = transaction_fees * 0.5
                + consensus_day_mint
                + slashing_proceeds * 0.5
                + bridge_fees * 0.1;

    let outflows = budget_disbursements
                 + validator_rewards
                 + director_stipends
                 + emergency_expenses;

    previous_balance + inflows - outflows
}
\`\`\`

### Fiscal Year Cycle

**Fiscal Year**: December 1st ‚Üí November 30th (aligned with Consensus Day)

**Budget Categories**:
1. **Development** (40% of budget): Core protocol, tools, libraries
2. **Marketing** (20% of budget): Education, outreach, partnerships
3. **Operations** (15% of budget): Infrastructure, monitoring, support
4. **Grants** (15% of budget): Community projects, research, ecosystem
5. **Emergency Reserve** (10% of budget): Held for crisis response

**Budget Approval Process**:
1. **Consensus Day**: Community votes on budget allocation per category
2. **Director Oversight**: Directors approve individual disbursements
3. **Quarterly Review**: Directors publish spending reports every 3 months
4. **Annual Audit**: Third-party audit published before next Consensus Day

### Treasury Transparency

**All treasury actions emit events**:
\`\`\`rust
enum TreasuryEvent {
    Deposit { source: DepositSource, amount: Balance },
    Disbursement { category: BudgetCategory, recipient: AccountId, amount: Balance },
    DirectorVote { director: AccountId, proposal_id: u64, vote: bool },
    QuarterlyReport { quarter: u8, total_spent: Balance, category_breakdown: Vec<(BudgetCategory, Balance)> },
}
\`\`\`

**Public Dashboard**:
- Real-time treasury balance
- All incoming/outgoing transactions
- Budget vs. actual spending per category
- Director voting records
- Historical trends (YoY comparison)

### Mint and Burn Dynamics

**Minting Events**:
1. **Consensus Day**: Annual minting for approved budgets
2. **Emergency Minting**: Directors can mint (7/9 vote) in crisis (max 1% of supply)

**Burning Events**:
1. **Transaction Fees**: 50% of all fees burned
2. **Validator Slashing**: 50% of slashed stakes burned
3. **Deflationary Votes**: Community can vote to burn treasury reserves

**Net Supply Formula**:
\`\`\`rust
fn calculate_net_supply_change(epoch: Epoch) -> i128 {
    let minted = consensus_day_mint + emergency_mint;
    let burned = transaction_fees * 0.5 + slashing_proceeds * 0.5 + voluntary_burns;

    (minted as i128) - (burned as i128)
}
\`\`\`

**Target**: Long-term supply should stabilize or decrease slowly (deflationary tendency)

---

## 4. TOKEN ECONOMICS (√âTR, EDSC, VMw)

### √âTR (√ãtrid Token)

**Purpose**: Governance, staking, gas fees

**Total Supply**: 1 Billion √âTR (initial), subject to inflation/deflation

**Initial Distribution**:
\`\`\`
Genesis Block:           1,000,000,000 √âTR

Allocation:
- Public Sale (40%):       400,000,000 √âTR
- Foundation (25%):        250,000,000 √âTR (4-year vesting)
- Team (15%):              150,000,000 √âTR (3-year vesting)
- Validators (10%):        100,000,000 √âTR (incentive pool)
- Ecosystem Grants (10%):  100,000,000 √âTR (unlocked)
\`\`\`

**Inflation/Deflation**:
- **Inflation**: Voted annually (0-5% cap), minted on Consensus Day
- **Deflation**: Transaction fees + slashing continuously burned
- **Net Effect**: Tends toward slight deflation long-term

**Use Cases**:
1. **Staking**: Lock √âTR to become validator or voter
2. **Gas Fees**: Pay for transactions (measured in VMw, priced in √âTR)
3. **Governance**: Vote on proposals during Consensus Day
4. **Collateral**: Back EDSC stablecoin (over-collateralized)

### EDSC (√ãtrid Dollar Stablecoin)

**Purpose**: Stable unit of account for payments, contracts

**Peg**: $1.00 USD (soft peg maintained by arbitrage + liquidations)

**Collateral**: Over-collateralized by multi-asset reserve (target: 150%)

**Reserve Infrastructure**:

EDSC is backed by a diversified multi-asset reserve managed through two specialized pallets:

1. **pallet-multiasset-reserve**: Manages reserve composition and automated rebalancing
2. **pallet-reserve-backed-token**: Handles EDSC minting and collateral positions

**Reserve Composition**:
\`\`\`
Target Allocation (example):
- 40% √âTR (native token)
- 30% BTC (bridged from BTC-PBC)
- 20% ETH (bridged from ETH-PBC)
- 10% Other assets (governance-approved)

Rebalancing:
- Triggered when deviation exceeds 5%
- Automated via pallet-multiasset-reserve
- Governance can adjust allocation strategy
\`\`\`

**Allocation Strategies**:
- **EqualWeight**: Equal distribution across all reserve assets
- **MarketCapWeighted**: Weight by market capitalization
- **RiskAdjusted**: Weight by volatility/risk metrics
- **Custom**: Custom weights set by governance vote

**Minting Process**:
\`\`\`rust
fn mint_edsc(collateral_amount: Balance) -> Result<Balance, Error> {
    let etr_price_usd = oracle::get_etr_price(); // From price oracle
    let collateral_value_usd = collateral_amount * etr_price_usd;

    // Require 150% collateralization
    let max_edsc_mintable = collateral_value_usd / 1.5;

    // Lock collateral in reserve
    lock_collateral(caller, collateral_amount)?;

    // Mint EDSC via pallet-reserve-backed-token
    mint_stablecoin(caller, max_edsc_mintable)?;

    // Reserve automatically rebalances if needed
    if should_rebalance() {
        trigger_rebalance()?;
    }

    Ok(max_edsc_mintable)
}
\`\`\`

**Liquidation Process**:
\`\`\`rust
fn check_liquidation(cdp: &CollateralDebtPosition) -> bool {
    let etr_price_usd = oracle::get_etr_price();
    let collateral_value = cdp.collateral_amount * etr_price_usd;
    let debt_value = cdp.edsc_minted; // 1 EDSC = $1

    let collateralization_ratio = collateral_value / debt_value;

    // Liquidate if ratio falls below 120% (updated threshold)
    if collateralization_ratio < 1.2 {
        liquidate_cdp(cdp);
        true
    } else {
        false
    }
}
\`\`\`

**Collateralization Parameters**:
\`\`\`
Minimum Collateral Ratio: 150%
Liquidation Threshold:     120%
Liquidation Penalty:       5%

Example:
To mint 1000 EDSC ($1000 value):
‚Üí Requires: $1500 in collateral (150%)
‚Üí Liquidated if collateral falls to $1200 (120%)
‚Üí Liquidator receives: $1200 + 5% penalty = $1260
‚Üí Position holder loses: $60 to liquidator
\`\`\`

**Stability Mechanisms**:
1. **Multi-Asset Reserve**: Reduces correlation risk compared to single-asset backing
2. **Automated Rebalancing**: Maintains target allocations via pallet-multiasset-reserve
3. **Over-Collateralization**: 150% target ratio prevents undercollateralization
4. **Liquidation**: Automated liquidations at 120% ratio (updated from 110%)
5. **Liquidation Penalty**: 5% penalty incentivizes proper position management
6. **Interest Rates**: Dynamic interest on borrowed EDSC adjusts to maintain peg
7. **Arbitrage**: Price deviations create profitable arbitrage opportunities
8. **DEX Integration**: FlareSwap enables efficient √âTR/EDSC trading and price discovery

**Reserve-Backed Token Framework**:

Beyond EDSC, the reserve infrastructure enables creation of diverse synthetic assets:

**Synthetic Asset Types**:
- **Stablecoins**: EDSC (USD), EEUR (Euro), EGBP (Pound)
- **Commodities**: EXAU (Gold), EXAG (Silver), EXOIL (Oil)
- **Equities**: ETSLA (Tesla), EAAPL (Apple), EGOOG (Google)
- **Indices**: ES&P (S&P 500), ENASDAQ (Nasdaq), EDJI (Dow Jones)

**Governance Controls**:
- Whitelisting of reserve assets (Consensus Day vote required)
- Adjustment of collateralization ratios per synthetic
- Rebalancing strategy selection
- Emergency pause of minting/liquidations

### VMw (Virtual Machine Watts)

**Purpose**: Measure computational cost (gas metering)

**Definition**: 1 VMw = 1 Watt-second of CPU energy

**Pricing**:
\`\`\`rust
fn calculate_gas_price() -> Balance {
    // Dynamic pricing based on block fullness
    let block_utilization = current_block_vmw / max_block_vmw; // 0.0 - 1.0

    // Base price: 1 VMw = 0.000001 √âTR
    let base_price = 1_000_000_000_000u128; // 1e-6 √âTR in plancks

    // Price increases exponentially with utilization
    let surge_multiplier = if block_utilization > 0.75 {
        1.0 + ((block_utilization - 0.75) * 8.0)
    } else {
        1.0
    };

    Balance::from((base_price as f64 * surge_multiplier) as u128)
}
\`\`\`

**Block Limits**:
- **Max VMw per block**: 10,000,000 VMw
- **Target utilization**: 50% (5,000,000 VMw)
- **Surge pricing**: Kicks in above 75% utilization

**Example Transaction Costs**:
\`\`\`
Simple Transfer:           100 VMw   ‚âà 0.0001 √âTR   ($0.001 at $10/√âTR)
Token Swap:              5,000 VMw   ‚âà 0.005 √âTR    ($0.05)
Complex Contract:       50,000 VMw   ‚âà 0.05 √âTR     ($0.50)
Cross-Chain Bridge:    200,000 VMw   ‚âà 0.2 √âTR      ($2.00)
\`\`\`

---

## 5. PROPOSAL SYSTEM & VOTING MECHANISMS

### Proposal Lifecycle

\`\`\`
1. Draft ‚Üí 2. Submission ‚Üí 3. Discussion ‚Üí 4. Voting ‚Üí 5. Execution
   (Off-chain)  (Registration)   (48h window)    (12h vote)   (Minting + Distribution)
\`\`\`

### Proposal Template

**Minimum Requirements**:
\`\`\`markdown
# Proposal Title (max 100 chars)

## Summary (max 300 chars)
One-paragraph overview accessible to all voters.

## Motivation
Why is this proposal necessary? What problem does it solve?

## Specification
Technical details. How will this be implemented?

## Budget Request (if applicable)
Amount: _______ √âTR
Breakdown:
  - Development: _______ √âTR
  - Audit: _______ √âTR
  - Deployment: _______ √âTR

## Implementation Timeline
Phase 1: (date range) - Milestone 1
Phase 2: (date range) - Milestone 2
...

## Success Criteria
How will we know this proposal succeeded?

## Risks & Mitigations
What could go wrong? How will we address it?

## Supporting Validators (min 3)
- Validator 1: [address]
- Validator 2: [address]
- Validator 3: [address]
\`\`\`

### Voting Rules

**Vote Types**:
1. **Yes**: Support the proposal
2. **No**: Reject the proposal
3. **Abstain**: Count toward quorum but not approval

**Quadratic Voting** (Optional, for contentious issues):
\`\`\`rust
fn calculate_quadratic_vote_cost(num_votes: u32) -> Balance {
    // Cost increases quadratically
    // 1 vote = 1 √âTR, 2 votes = 4 √âTR, 3 votes = 9 √âTR, etc.
    let cost_per_vote = num_votes * num_votes;
    Balance::from(cost_per_vote as u128 * VOTE_COST_BASE)
}
\`\`\`

**Conviction Voting** (Optional, for long-term decisions):
\`\`\`rust
enum Conviction {
    None,       // 1x voting power, unlock immediately
    Locked1x,   // 1x voting power, locked 1 epoch after vote
    Locked2x,   // 2x voting power, locked 2 epochs
    Locked4x,   // 4x voting power, locked 4 epochs
    Locked8x,   // 8x voting power, locked 8 epochs
}
\`\`\`

### Proposal Execution

**Automatic Execution**:
- If proposal approved with quorum ‚Üí Executed in Phase 3 (Minting)
- If proposal rejected ‚Üí Bond returned (if >5% quorum), proposal archived
- If proposal doesn't reach quorum ‚Üí Bond slashed, proposal discarded

**Manual Execution** (for protocol upgrades):
- Directors + validators coordinate deployment
- Upgrade scheduled for specific block height
- All nodes must upgrade before deadline

---

## 6. REWARD DISTRIBUTION & SLASHING

### Validator Rewards

**Annual Validator Reward Pool**: ~3% of circulating supply

**Distribution**:
\`\`\`rust
fn distribute_epoch_rewards(epoch: Epoch) {
    let total_pool = circulating_supply() * 0.03 / EPOCHS_PER_YEAR;

    for validator in active_validators() {
        let base_reward = total_pool * (validator.stake / total_stake);
        let adjusted_reward = base_reward * validator.performance_multiplier;

        // Pay 50% to validator, 50% to delegators
        pay_reward(validator.account, adjusted_reward * 0.5);
        pay_delegators(validator, adjusted_reward * 0.5);
    }
}
\`\`\`

**Performance Multiplier**:
\`\`\`rust
fn calculate_performance_multiplier(validator: &Validator) -> f64 {
    let uptime_score = validator.uptime; // 0.0 - 1.0
    let finality_score = validator.blocks_signed / validator.blocks_expected;
    let participation_score = if validator.voted_consensus_day { 1.1 } else { 1.0 };

    uptime_score * finality_score * participation_score
}
\`\`\`

### Delegator Rewards

**Delegation Mechanism**:
- Token holders can delegate √âTR to validators
- Validators charge commission (0-100%, set by validator)
- Rewards automatically distributed each epoch

**Commission Structure**:
\`\`\`rust
fn distribute_delegation_rewards(validator: &Validator, total_reward: Balance) {
    let commission_rate = validator.commission; // e.g., 0.10 = 10%
    let commission_amount = total_reward * commission_rate;
    let delegator_pool = total_reward - commission_amount;

    // Pay commission to validator
    pay_reward(validator.account, commission_amount);

    // Distribute remaining to delegators proportionally
    for delegator in validator.delegators() {
        let delegator_share = delegator.stake / validator.total_delegated;
        let delegator_reward = delegator_pool * delegator_share;
        pay_reward(delegator.account, delegator_reward);
    }
}
\`\`\`

### Slashing Conditions

**Offense Types**:

| Offense | Severity | Slash Amount | Cooldown |
|---------|----------|--------------|----------|
| Downtime (>24h) | Low | 1% per day | 7 days |
| Missed blocks (>10%) | Low | 0.5% | 3 days |
| Equivocation (double-sign) | High | 10% | 30 days |
| Invalid finality vote | High | 5% | 14 days |
| Censorship (provable) | Medium | 5% | 14 days |
| Coordinated attack | Critical | 50% + removal | Permanent ban |

**Slashing Execution**:
\`\`\`rust
fn execute_slash(
    validator: AccountId,
    offense: OffenseType,
    evidence: Vec<u8>,
) -> Result<(), Error> {
    // Verify evidence
    verify_offense_evidence(offense, evidence)?;

    // Calculate slash amount
    let slash_amount = match offense {
        OffenseType::Downtime => validator.stake * 0.01,
        OffenseType::Equivocation => validator.stake * 0.10,
        OffenseType::MaliciousAttack => validator.stake * 0.50,
        // ... other offenses
    };

    // Execute slash
    burn_tokens(validator, slash_amount * 0.5); // 50% burned
    transfer_to_treasury(slash_amount * 0.5);   // 50% to treasury

    // Apply cooldown
    apply_validator_cooldown(validator, offense.cooldown_period);

    // Emit event
    emit_event(Event::ValidatorSlashed {
        validator,
        offense,
        amount: slash_amount,
        timestamp: current_block(),
    });

    Ok(())
}
\`\`\`

### Appeal Process

**Validators can appeal slashing**:
1. Submit appeal within 72 hours (costs 1,000 √âTR bond)
2. Directors review evidence (7/9 vote required to overturn)
3. If appeal successful: slash reversed, bond returned
4. If appeal rejected: bond added to treasury

---

## 7. ECONOMIC SUSTAINABILITY MODEL

### Long-Term Supply Dynamics

**Target**: Slightly deflationary long-term (~1% annual deflation)

**Inflows** (Minting):
- Consensus Day approved budgets: 0-5% per year (voted)
- Emergency minting: <0.1% per year (rare)

**Outflows** (Burning):
- Transaction fees: ~50% of fees (continuous)
- Slashing: ~50% of slashed stakes (episodic)
- Voluntary burns: Community-voted (rare)

**Net Supply Projection**:
\`\`\`
Year 1:  1.00B √âTR (genesis)
Year 2:  1.02B √âTR (+2% voted inflation - 1% burned = +1% net)
Year 3:  1.03B √âTR (+2% inflation - 1.5% burned = +0.5% net)
Year 5:  1.04B √âTR (+1.5% inflation - 2% burned = -0.5% net)
Year 10: 1.00B √âTR (back to genesis, deflationary equilibrium)
\`\`\`

### Fee Market Dynamics

**Transaction Fee Formula**:
\`\`\`rust
fn calculate_transaction_fee(vmw_cost: u64, priority: Priority) -> Balance {
    let base_fee = vmw_cost * get_current_vmw_price(); // Dynamic pricing

    let priority_multiplier = match priority {
        Priority::Low => 0.8,
        Priority::Normal => 1.0,
        Priority::High => 1.5,
        Priority::Urgent => 3.0,
    };

    base_fee * priority_multiplier
}
\`\`\`

**Fee Allocation**:
- 50% burned (deflationary pressure)
- 40% to validators (reward for block production)
- 10% to treasury (public goods funding)

### Economic Security

**Attack Cost Analysis**:

To attack √ãtrid, an adversary must:
1. Acquire >33% of staked √âTR (to disrupt finality)
2. Operate attack for multiple epochs before detection
3. Survive slashing and social coordination against them

**Cost**:
\`\`\`
Assume 40% of supply staked (400M √âTR)
33% of staked = 132M √âTR
At $10/√âTR = $1.32 Billion capital requirement

Cost of attack:
- Capital cost: $1.32B
- Slashing risk: 50% = $660M loss if caught
- Opportunity cost: 8% APY = $105M/year forgone rewards
- Reputation cost: √âTR price crash ‚Üí total loss

Total cost: >$2 Billion for 51% attack
\`\`\`

**Conclusion**: Economic security increases with network value and participation

---

## 8. EMERGENCY PROCEDURES & CRISIS RESPONSE

### Emergency Powers

**Directors Emergency Authority** (7-of-9 vote):
1. **Pause Chains**: Temporarily halt block production (max 72 hours)
2. **Emergency Upgrade**: Deploy hotfix without Consensus Day vote
3. **Slash Malicious Actors**: Immediate slashing for provable attacks
4. **Emergency Mint**: Mint up to 1% of supply for critical bug bounty

### Crisis Response Protocol

**Level 1: Minor Issue** (e.g., validator downtime spike)
- Response Team: On-call validators
- Action: Monitor, alert community
- Timeline: 24-hour resolution

**Level 2: Moderate Issue** (e.g., smart contract exploit)
- Response Team: Directors + Security Team
- Action: Pause affected pallets, deploy patch
- Timeline: 48-hour resolution

**Level 3: Critical Issue** (e.g., consensus failure)
- Response Team: All Directors + Core Developers + Community
- Action: Emergency governance vote, possible chain halt
- Timeline: Immediate action, 7-day resolution

### Social Recovery

**If network becomes compromised beyond repair**:
1. **Snapshot**: Take state snapshot at last known good block
2. **Fork**: Create new chain from snapshot
3. **Migrate**: Community coordinates migration to new chain
4. **Deprecate**: Old chain deprecated, new chain becomes canonical

**GPLv3 Protection**: Anyone can fork and continue the network

---

## 9. CONCLUSION: GOVERNANCE AS A LIVING SYSTEM

### Why This Model Works

1. **Alignment**: Token holders, validators, and users all benefit from network success
2. **Adaptation**: Annual Consensus Day forces regular evolution
3. **Transparency**: All decisions on-chain, all treasury actions public
4. **Resilience**: No single point of failure, multiple layers of accountability
5. **Sustainability**: Self-funding via fees, deflationary tendency prevents inflation

### Comparison to Other Models

| Feature | √ãtrid | Bitcoin | Ethereum | Polkadot |
|---------|-------|---------|----------|----------|
| **Governance** | On-chain annual vote | Off-chain (BIPs) | Off-chain (EIPs) | On-chain (referenda) |
| **Treasury** | Autonomous | None | Foundation-controlled | Autonomous |
| **Inflation** | Voted (0-5%) | Fixed (halving) | Fixed (~1%) | Fixed (~10%) |
| **Participation** | >33% quorum | N/A | ~5% typical | ~10% typical |
| **Emergency Powers** | Directors (7/9) | None | Foundation | Council |

### The Path to Sovereignty

√ãtrid governance is designed to achieve **true decentralization** through:
- **Economic incentives** (rewards for participation)
- **Social accountability** (transparent decisions, elected directors)
- **Technical constraints** (protocol-enforced caps, slashing)
- **Regular rhythm** (annual Consensus Day prevents drift)

**The goal**: A network that governs itself, funds itself, and evolves without relying on any central authority.

---

## APPENDIX A: Consensus Day Checklist

**For Voters**:
- [ ] Review all proposals (published 7 days before Consensus Day)
- [ ] Lock √âTR during Registration Phase (6 hours)
- [ ] Vote on all proposals during Voting Phase (12 hours)
- [ ] Claim participation rewards during Distribution Phase (1 hour)

**For Validators**:
- [ ] Signal participation during Registration Phase
- [ ] Vote on all proposals during Voting Phase
- [ ] Monitor network health during Minting Phase
- [ ] Verify reward distribution during Distribution Phase

**For Directors**:
- [ ] Review all proposals and publish recommendations
- [ ] Monitor quorum and voting during Voting Phase
- [ ] Execute approved budgets during Minting Phase
- [ ] Verify distribution accuracy during Distribution Phase

---

## APPENDIX B: Governance Formulas

### Quorum Calculation
\`\`\`rust
fn quorum_met(proposal: &Proposal) -> bool {
    let community_votes = proposal.total_votes;
    let validator_votes = proposal.validator_count;

    (community_votes >= circulating_supply() * 0.33) &&
    (validator_votes >= active_validator_count() * 0.51)
}
\`\`\`

### Approval Calculation
\`\`\`rust
fn proposal_approved(proposal: &Proposal) -> bool {
    let yes_votes = proposal.yes_votes;
    let total_votes = proposal.yes_votes + proposal.no_votes; // Abstain doesn't count

    let threshold = match proposal.category {
        ProposalCategory::BudgetAllocation => 0.50,
        ProposalCategory::ParameterChange => 0.50,
        ProposalCategory::ProtocolUpgrade => 0.66,
        ProposalCategory::EmergencyAction => 0.66,
    };

    (yes_votes as f64 / total_votes as f64) >= threshold
}
\`\`\`

---

## APPENDIX C: Further Reading

**Volume I**: Conceptual Architecture (Vision, Problem, Solution, Philosophy)
**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime)

**Online Resources**:
- Governance Portal: governance.etrid.org
- Proposal Archive: proposals.etrid.org
- Treasury Dashboard: treasury.etrid.org

---

**End of Volume III**

**√ãtrid Ivory Papers Complete**

---

*"Governance is not a feature to be added. It is the fundamental architecture of coordination."*

---

**Document Status**: ACTIVE PROTOCOL SPECIFICATION
**Next Review**: Consensus Day 2026 (December 1, 2026)

---

## ADDENDUM: TREASURY AND RESERVE SYSTEM IMPLEMENTATION (2025)

### Overview

Following the specifications outlined in this volume, the √ãtrid protocol has implemented a comprehensive treasury and reserve system through four specialized pallets. This addendum documents the technical implementation details, operational procedures, and emergency protocols for these critical financial infrastructure components.

**Implementation Status**: ACTIVE (Deployed Q4 2025)
**Pallet Locations**: \`/Users/macbook/Desktop/etrid/src/pallets/\`

---

### 1. PALLET-TREASURY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-treasury/src/lib.rs\`

The treasury pallet implements the protocol's fiscal management system with multi-signature governance controls.

#### Multisig Architecture

**Configuration**:
- **Directors**: 9 elected representatives (via Consensus Day)
- **Normal Operations**: 6-of-9 approval threshold
- **Emergency Actions**: 7-of-9 approval threshold
- **Term Length**: 1 year (renewable via re-election)

**Director Requirements**:
\`\`\`rust
// Minimum stake: 128 √ãTR
// Must serve as OD Flare Nodes
// Subject to term limits (max 3 lifetime terms)
// One-year cooldown between terms
\`\`\`

**Multisig Controls**:
\`\`\`rust
pub struct Disbursement<T: Config> {
    pub id: u64,
    pub category: BudgetCategory,
    pub recipient: T::AccountId,
    pub amount: BalanceOf<T>,
    pub proposer: T::AccountId,
    pub status: DisbursementStatus,
    pub approval_count: u8,
    pub is_emergency: bool,  // Requires 7/9 instead of 6/9
}
\`\`\`

#### Budget Categories

Default allocations (modifiable via Consensus Day governance):

\`\`\`rust
pub struct BudgetAllocations {
    pub development_bps: u32,      // 40% (4000 basis points)
    pub marketing_bps: u32,        // 20% (2000 basis points)
    pub operations_bps: u32,       // 15% (1500 basis points)
    pub grants_bps: u32,           // 15% (1500 basis points)
    pub emergency_reserve_bps: u32, // 10% (1000 basis points)
}
\`\`\`

**Budget Category Details**:

1. **Development (40%)**:
   - Core protocol development
   - Research and innovation
   - Infrastructure improvements
   - Security audits and bug bounties

2. **Marketing (20%)**:
   - Community growth initiatives
   - Partnership development
   - Educational content
   - Brand awareness campaigns

3. **Operations (15%)**:
   - Team salaries (community-voted)
   - Legal and compliance
   - Administrative expenses
   - Operational infrastructure

4. **Grants (15%)**:
   - Ecosystem development grants
   - Developer support programs
   - Research initiatives
   - Community projects

5. **Emergency Reserve (10%)**:
   - Locked for critical situations
   - Requires 7-of-9 approval for access
   - Protocol security responses
   - Network stability measures

#### Disbursement Workflow

**Step 1: Proposal**
\`\`\`rust
// Any director can propose disbursement
pub fn propose_disbursement(
    origin: OriginFor<T>,
    category: BudgetCategory,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult
\`\`\`

**Step 2: Approval**
\`\`\`rust
// Other directors vote (need 6 total approvals, 7 for emergency)
pub fn approve_disbursement(
    origin: OriginFor<T>,
    disbursement_id: u64,
) -> DispatchResult
\`\`\`

**Step 3: Automatic Execution**
\`\`\`rust
// Executes automatically when threshold reached
if disbursement.approval_count >= threshold {
    Self::execute_disbursement_internal(disbursement_id)?;
}
\`\`\`

**Safeguards**:
- Proposals expire after 7 days if quorum not reached
- Directors cannot approve same proposal twice
- Category allocations checked before disbursement
- All actions emit transparent on-chain events

#### Emergency Withdrawal Procedures

Emergency withdrawals require heightened security:

\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals (higher threshold)
    // Can only withdraw from EmergencyReserve
    // Used for critical protocol emergencies
}
\`\`\`

**Emergency Scenarios**:
- Critical security vulnerabilities
- Protocol-threatening exploits
- Network stability emergencies
- Consensus failure recovery

#### Funding Source Integration

The treasury receives funds from multiple sources:

\`\`\`rust
pub enum FundingSource {
    TransactionFees,      // 50% of all transaction fees
    ConsensusDayMinting,  // Approved budgets from annual vote
    ValidatorSlashing,    // 50% of slashing penalties
    CrossChainFees,       // 10% of bridge transaction fees
    Other,                // Donations, etc.
}
\`\`\`

**Funding Flow Example**:
\`\`\`
Transaction: 1000 √ãTR fee collected
‚Üí 50% (500 √ãTR) burned (deflationary)
‚Üí 40% (400 √ãTR) to validators
‚Üí 10% (100 √ãTR) to treasury

Consensus Day: 100M √ãTR minted
‚Üí 98.3M to treasury for budgets
‚Üí 1.0M to participation rewards
‚Üí 0.5M to validator bonuses
‚Üí 0.2M to director stipends
\`\`\`

#### Storage Items

**Core Storage**:
\`\`\`rust
/// Total √ãTR balance in treasury
TreasuryBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// EDSC stablecoin balance
EdscBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Budget allocation percentages
BudgetAllocationsStorage<T: Config> = StorageValue<_, BudgetAllocations>

/// Category-specific allocated amounts
CategoryAllocations<T: Config> = StorageMap<_, BudgetCategory, BalanceOf<T>>

/// Pending and historical disbursements
Disbursements<T: Config> = StorageMap<_, u64, Disbursement<T>>

/// Director approvals per disbursement
DirectorApprovals<T: Config> = StorageMap<_, u64, BoundedVec<T::AccountId, ConstU32<9>>>

/// Current 9 directors
Directors<T: Config> = StorageValue<_, BoundedVec<T::AccountId, ConstU32<9>>>

/// Emergency reserve balance
EmergencyReserve<T: Config> = StorageValue<_, BalanceOf<T>>
\`\`\`

#### Extrinsics

**Public Functions**:
\`\`\`rust
// Fund treasury from various sources
fund_treasury(source: FundingSource, amount: Balance)

// Director proposes spending
propose_disbursement(category, recipient, amount, description)

// Director approves proposal (6/9 needed)
approve_disbursement(disbursement_id)

// Emergency reserve access (7/9 needed)
emergency_withdrawal(recipient, amount, description)
\`\`\`

**Governance Functions** (Root/Consensus Day only):
\`\`\`rust
// Update budget percentages
set_budget_allocations(allocations: BudgetAllocations)

// Allocate funds to categories
allocate_to_categories(total_amount: Balance)

// Add/remove directors
add_director(director: AccountId)
remove_director(director: AccountId)
\`\`\`

---

### 2. PALLET-MULTIASSET-RESERVE IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-multiasset-reserve/src/lib.rs\`

The multiasset reserve pallet enables diversified reserve management with automatic rebalancing capabilities.

#### Multi-Asset Reserve Management

**Asset Configuration**:
\`\`\`rust
pub struct AssetMetadata {
    pub symbol: BoundedVec<u8, ConstU32<16>>,  // BTC, ETH, etc.
    pub decimals: u8,
    pub is_active: bool,
    pub min_holding: u128,
    pub max_holding: u128,
    pub target_allocation: Permill,
    pub last_rebalance: u32,
}
\`\`\`

**Reserve Composition**:
\`\`\`rust
pub struct AssetHolding {
    pub asset_id: u32,
    pub amount: u128,
    pub value_usd: u128,      // Cached with 8 decimals
    pub last_price_update: u32,
}
\`\`\`

**Supported Asset Types**:
- Native √ãTR token
- Bridged Bitcoin (sBTC)
- Bridged Ethereum (sETH)
- Stablecoins (USDC, USDT)
- Synthetic gold (sXAU)
- Other governance-approved assets

#### Allocation Strategies

Four distinct strategies available:

\`\`\`rust
pub enum AllocationStrategy {
    /// Equal weight allocation (each asset gets equal %)
    EqualWeight = 0,

    /// Market cap weighted (higher cap = higher allocation)
    MarketCapWeighted = 1,

    /// Risk-adjusted (lower volatility = higher allocation)
    RiskAdjusted = 2,

    /// Custom manual allocations (default)
    Custom = 3,
}
\`\`\`

**Strategy Selection**:
\`\`\`rust
// Governance can set strategy via:
pub fn set_allocation_strategy(
    origin: OriginFor<T>,
    strategy_code: u8,  // 0-3 corresponding to enum
) -> DispatchResult
\`\`\`

**Example Custom Allocation**:
\`\`\`
For EDSC backing:
- 40% √ãTR (native token, low correlation)
- 30% sBTC (store of value, established)
- 20% sETH (smart contract ecosystem)
- 10% Other (USDC, sXAU, diversification)
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
/// Triggered when deviation exceeds 5% threshold
#[pallet::constant]
type RebalanceThreshold: Get<Permill>;  // Default: 500 (5%)
\`\`\`

**Rebalancing Logic**:
\`\`\`rust
pub fn needs_rebalancing() -> bool {
    let threshold = T::RebalanceThreshold::get();

    for (asset_id, config) in AssetConfigs::<T>::iter() {
        let current_alloc = Self::get_asset_allocation(asset_id)?;
        let target = config.target_allocation;

        let deviation = if current_alloc > target {
            current_alloc.saturating_sub(target)
        } else {
            target.saturating_sub(current_alloc)
        };

        if deviation > threshold {
            return true;  // Rebalancing needed
        }
    }

    false
}
\`\`\`

**Rebalancing Execution**:
\`\`\`rust
pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    // Check rebalance interval (minimum time between rebalances)
    // Calculate required swaps to reach target allocations
    // Execute swaps via DEX integration
    // Update holdings and emit events
    // Record rebalancing history
}
\`\`\`

#### Oracle Integration

**Price Oracle Dependency**:
\`\`\`rust
trait Config: frame_system::Config + pallet_reserve_oracle::Config {
    // Inherits oracle functionality for real-time pricing
}
\`\`\`

**Price Updates**:
- Real-time asset prices from oracle network
- Cached USD values for performance
- 8 decimal precision for accuracy
- Automatic updates on reserve operations

#### Vault Integration

**Secure Asset Storage**:
- Integration with \`pallet-reserve-vault\` for custody
- Multi-signature controls for asset movements
- Separation of hot/cold storage
- Audit trail for all asset transfers

#### Asset Whitelisting and Position Limits

**Whitelisting**:
\`\`\`rust
/// Governance-controlled asset approval
pub type WhitelistedAssets<T: Config> = StorageMap<
    _, Blake2_128Concat, u32, bool
>;

// Only whitelisted assets can be added to reserve
ensure!(WhitelistedAssets::<T>::get(asset_id), Error::<T>::AssetNotWhitelisted);
\`\`\`

**Position Limits**:
\`\`\`rust
// Per-asset min/max holdings
ensure!(amount >= config.min_holding, Error::<T>::BelowMinimumHolding);
ensure!(amount <= config.max_holding, Error::<T>::ExceedsMaximumHolding);
\`\`\`

**Risk Management**:
- Maximum exposure limits per asset class
- Diversification requirements
- Liquidity constraints
- Correlation monitoring

#### Storage Items

\`\`\`rust
/// Asset configuration registry
AssetConfigs<T: Config> = StorageMap<_, u32, AssetMetadata>

/// Reserve composition (holdings per asset)
ReserveComposition<T: Config> = StorageMap<_, u32, AssetHolding>

/// Current allocation strategy (0=EqualWeight, 1=MarketCapWeighted, 2=RiskAdjusted, 3=Custom)
CurrentStrategy<T: Config> = StorageValue<_, u8>

/// Total reserve value (cached, USD with 8 decimals)
TotalReserveValue<T: Config> = StorageValue<_, u128>

/// Whitelisted assets
WhitelistedAssets<T: Config> = StorageMap<_, u32, bool>

/// Asset count
AssetCount<T: Config> = StorageValue<_, u32>

/// Last rebalance status
LastRebalance<T: Config> = StorageValue<_, RebalanceStatus<BlockNumber>>

/// Rebalancing enabled flag
RebalancingEnabled<T: Config> = StorageValue<_, bool>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Add new asset to reserve
add_asset(asset_id, symbol, decimals, min_holding, max_holding, target_allocation)

// Remove asset from reserve
remove_asset(asset_id)

// Set target allocation for asset
set_target_allocation(asset_id, target: Permill)

// Set allocation strategy
set_allocation_strategy(strategy_code: u8)

// Enable/disable automatic rebalancing
set_rebalancing_enabled(enabled: bool)
\`\`\`

**Public Functions**:
\`\`\`rust
// Deposit asset into reserve
deposit_to_reserve(asset_id, amount)

// Trigger manual rebalance
trigger_rebalance()
\`\`\`

**Restricted Functions** (Governance only):
\`\`\`rust
// Withdraw asset from reserve
withdraw_from_reserve(asset_id, amount)
\`\`\`

---

### 3. PALLET-EDSC-STABILITY IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-edsc-stability/src/lib.rs\`

The EDSC stability pallet implements the protocol's stablecoin system with multi-asset reserve backing and peg defense mechanisms.

#### EDSC Stablecoin System

**Peg Target**: $1.00 USD (soft peg maintained via arbitrage and stability mechanisms)

**Reserve Architecture**:
\`\`\`rust
pub struct ReserveComposition {
    pub etr_allocation: u16,    // 40% (4000 basis points)
    pub sbtc_allocation: u16,   // 30% (3000 basis points)
    pub seth_allocation: u16,   // 20% (2000 basis points)
    pub other_allocation: u16,  // 10% (1000 basis points)
}
\`\`\`

**Multi-Asset Reserve Backing**:
- **40% √ãTR**: Native token, governance voting power
- **30% sBTC**: Synthetic Bitcoin, store of value
- **20% sETH**: Synthetic Ethereum, DeFi integration
- **10% Other**: USDC, sXAU, diversification assets

#### Collateralization Parameters

\`\`\`rust
/// Minimum collateralization ratio: 150% (15000 basis points)
#[pallet::constant]
type MinCollateralRatio: Get<u16>;  // Default: 15000

/// Liquidation threshold: 120% (12000 basis points)
#[pallet::constant]
type LiquidationThreshold: Get<u16>;  // Default: 12000

/// Liquidation penalty: 5% (500 basis points)
#[pallet::constant]
type LiquidationPenalty: Get<u16>;  // Default: 500
\`\`\`

**Collateralization Example**:
\`\`\`
To mint 1000 EDSC ($1000 value):
‚Üí Required collateral: $1500 (150%)
‚Üí Liquidation triggered at: $1200 (120%)
‚Üí Liquidation penalty: $60 (5%)

Scenario:
1. User deposits 150 √ãTR ($1500 at $10/√ãTR)
2. System mints 1000 EDSC
3. If √ãTR drops to $8/√ãTR:
   - Collateral value: 150 * $8 = $1200
   - Collateral ratio: 120% (at liquidation threshold)
   - Position can be liquidated
   - Liquidator pays 1000 EDSC, receives $1260 in √ãTR
   - Position holder loses $60 penalty
   - Treasury receives $60 penalty
\`\`\`

#### Interest Rate Adjustments for Peg Defense

**Dynamic Interest Rates**:
\`\`\`rust
/// Base interest rate (annual, in basis points)
#[pallet::constant]
type BaseInterestRate: Get<u16>;  // Default: 200 (2% annual)
\`\`\`

**Peg Defense Mechanism**:
\`\`\`rust
pub fn adjust_interest_rate(
    origin: OriginFor<T>,
    new_rate: u16,
) -> DispatchResult {
    // If EDSC > $1.01: Lower rate to encourage minting
    // If EDSC < $0.99: Raise rate to encourage burning

    let price = EDSCPrice::<T>::get();  // In cents (100 = $1.00)

    if price > 101 {
        // Trading above peg: lower interest to encourage minting
        new_rate = current_rate.saturating_sub(50);  // Reduce by 0.5%
    } else if price < 99 {
        // Trading below peg: raise interest to encourage burning
        new_rate = current_rate.saturating_add(50);  // Increase by 0.5%
    }

    InterestRate::<T>::put(new_rate);
}
\`\`\`

**Interest Calculation**:
\`\`\`rust
fn calculate_accrued_interest(
    position: &EDSCPosition<BalanceOf<T>>,
    current_block: u32,
) -> Result<u128, DispatchError> {
    let blocks_elapsed = current_block - position.last_interest_update;
    let blocks_per_year = 5_256_000u128;  // ~6 second blocks

    // Interest = principal * rate * time
    let interest = position.edsc_minted
        .checked_mul(position.interest_rate as u128)?
        .checked_mul(blocks_elapsed as u128)?
        .checked_div(10000)?  // Basis points to decimal
        .checked_div(blocks_per_year)?;

    Ok(interest)
}
\`\`\`

#### Liquidation System

**Liquidation Trigger**:
\`\`\`rust
pub fn liquidate_position(
    origin: OriginFor<T>,
    owner: T::AccountId,
) -> DispatchResult {
    let position = Positions::<T>::get(&owner)?;

    // Calculate current collateralization ratio
    let collateral_value = Self::balance_to_u128(position.collateral_amount)?;
    let debt_value = position.edsc_minted;

    let collateral_ratio = (collateral_value * 10000) / debt_value;

    // Check if undercollateralized (below 120%)
    ensure!(
        collateral_ratio < T::LiquidationThreshold::get(),
        Error::<T>::PositionHealthy
    );

    // Execute liquidation...
}
\`\`\`

**Liquidation Mechanics**:
1. Liquidator provides EDSC to burn debt
2. Liquidator receives collateral from position
3. 5% penalty deducted from collateral
4. Penalty sent to treasury
5. Position closed or updated

**Liquidation Penalty Distribution**:
\`\`\`
Total Collateral: $1200
Debt: $1000 EDSC
Penalty: 5% of collateral = $60

Distribution:
‚Üí Liquidator receives: $1140 ($1200 - $60)
‚Üí Treasury receives: $60 (penalty)
‚Üí Position holder loses: $60
\`\`\`

#### Automatic Rebalancing

**Rebalancing Trigger**:
\`\`\`rust
#[pallet::constant]
type RebalanceThreshold: Get<u16>;  // Default: 500 (5%)

pub fn trigger_rebalance(origin: OriginFor<T>) -> DispatchResult {
    let current = CurrentReserveComposition::<T>::get();
    let target = TargetReserveComposition::<T>::get();

    let deviation = Self::calculate_composition_deviation(&current, &target)?;

    ensure!(
        deviation > T::RebalanceThreshold::get(),
        Error::<T>::RebalancingNotNeeded
    );

    // Execute rebalancing...
}
\`\`\`

**Rebalancing Process**:
1. Calculate current asset allocations
2. Compare to target percentages
3. Determine required swaps
4. Execute trades via DEX
5. Update reserve composition
6. Emit rebalancing events

#### Treasury Integration

**Stability Fees Flow**:
\`\`\`rust
/// Accumulated stability fees for treasury
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

// Interest payments go to stability fees
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(interest_in_collateral);
});
\`\`\`

**Liquidation Penalties Flow**:
\`\`\`rust
// Penalty sent to treasury
StabilityFees::<T>::mutate(|fees| {
    *fees = fees.saturating_add(penalty);
});
\`\`\`

**Fee Collection**:
- Interest payments from EDSC positions
- Liquidation penalties (5% of collateral)
- Rebalancing fees (if applicable)
- All fees flow to treasury for protocol sustainability

#### Storage Items

\`\`\`rust
/// Main EDSC reserve balance
EDSCReserveBalance<T: Config> = StorageValue<_, BalanceOf<T>>

/// Current reserve composition
CurrentReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Target reserve composition (governance-updatable)
TargetReserveComposition<T: Config> = StorageValue<_, ReserveComposition>

/// Current collateralization ratio (basis points)
CollateralizationRatio<T: Config> = StorageValue<_, u16>

/// Current interest rate (annual, basis points)
InterestRate<T: Config> = StorageValue<_, u16>

/// Total EDSC supply
TotalEDSCSupply<T: Config> = StorageValue<_, u128>

/// User EDSC balances
EDSCBalances<T: Config> = StorageMap<_, T::AccountId, u128>

/// User collateral positions
Positions<T: Config> = StorageMap<_, T::AccountId, EDSCPosition<BalanceOf<T>>>

/// Accumulated stability fees
StabilityFees<T: Config> = StorageValue<_, BalanceOf<T>>

/// Emergency pause flag
EmergencyPaused<T: Config> = StorageValue<_, bool>

/// Liquidation history
LiquidationHistory<T: Config> = StorageMap<_, u32, EDSCLiquidation>

/// Rebalancing history
RebalanceHistory<T: Config> = StorageMap<_, u32, RebalanceRecord>

/// Current EDSC price (in cents, 100 = $1.00)
EDSCPrice<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**User Functions**:
\`\`\`rust
// Deposit collateral and mint EDSC
deposit_collateral_mint_edsc(collateral_amount, edsc_amount)

// Burn EDSC and withdraw collateral
burn_edsc_withdraw_collateral(edsc_amount)

// Add collateral to existing position
add_collateral(amount)
\`\`\`

**Liquidation Functions** (Anyone can call):
\`\`\`rust
// Liquidate undercollateralized position
liquidate_position(owner: AccountId)

// Trigger reserve rebalancing
trigger_rebalance()
\`\`\`

**Governance Functions** (Root only):
\`\`\`rust
// Adjust interest rate for peg defense
adjust_interest_rate(new_rate: u16)

// Emergency pause system
emergency_pause()

// Deactivate emergency pause
deactivate_emergency_pause()

// Update target reserve composition
update_target_composition(new_composition)
\`\`\`

---

### 4. PALLET-CIRCUIT-BREAKER IMPLEMENTATION

**Location**: \`/Users/macbook/Desktop/etrid/src/pallets/pallet-circuit-breaker/src/lib.rs\`

The circuit breaker pallet provides emergency safety controls for the EDSC stability system.

#### Circuit Breaker Statuses

\`\`\`rust
pub enum CircuitStatus {
    /// Normal operation - all functions available
    Normal,

    /// Throttled - limited operations, reduced volume caps
    Throttled,

    /// Paused - critical operations suspended
    Paused,

    /// Emergency - all non-critical operations halted
    Emergency,
}
\`\`\`

**Status Transitions**:
\`\`\`
Normal ‚Üí Throttled:  Reserve ratio drops below 95%
Throttled ‚Üí Paused:  Volume limits exceeded
Paused ‚Üí Emergency:  Reserve ratio drops below 90%
Emergency ‚Üí Normal:  Requires governance approval
\`\`\`

#### Volume Caps

**Hourly and Daily Limits**:
\`\`\`rust
/// Maximum hourly redemption volume (in EDSC)
#[pallet::constant]
type MaxHourlyVolume: Get<u128>;  // Default: 1M EDSC/hour

/// Maximum daily redemption volume (in EDSC)
#[pallet::constant]
type MaxDailyVolume: Get<u128>;  // Default: 10M EDSC/day
\`\`\`

**Volume Tracking**:
\`\`\`rust
pub struct VolumeTracker<BlockNumber> {
    pub hourly_volume: u128,
    pub hourly_start_block: BlockNumber,
    pub daily_volume: u128,
    pub daily_start_block: BlockNumber,
}

pub fn track_volume(amount: u128) -> DispatchResult {
    let mut tracker = RedemptionVolume::<T>::get();

    tracker.hourly_volume = tracker.hourly_volume.saturating_add(amount);
    tracker.daily_volume = tracker.daily_volume.saturating_add(amount);

    // Check limits
    if tracker.hourly_volume > T::MaxHourlyVolume::get() {
        Self::trigger_circuit(b"Hourly volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    if tracker.daily_volume > T::MaxDailyVolume::get() {
        Self::trigger_circuit(b"Daily volume limit exceeded");
        return Err(Error::<T>::VolumeLimitExceeded);
    }

    Ok(())
}
\`\`\`

#### Reserve Ratio Thresholds

**Threshold Configuration**:
\`\`\`rust
/// Reserve ratio threshold for throttling (95%)
#[pallet::constant]
type ThrottleThreshold: Get<u16>;  // Default: 9500 basis points

/// Reserve ratio threshold for emergency pause (90%)
#[pallet::constant]
type EmergencyThreshold: Get<u16>;  // Default: 9000 basis points
\`\`\`

**Automatic Status Updates**:
\`\`\`rust
pub fn check_reserve_ratio(reserve_ratio: u16) -> DispatchResult {
    let current_status = Status::<T>::get();

    // Emergency threshold (90%)
    if reserve_ratio < T::EmergencyThreshold::get() {
        if current_status != CircuitStatus::Emergency {
            Self::trigger_circuit(b"Emergency reserve threshold breached");
            Status::<T>::put(CircuitStatus::Emergency);
        }
        return Err(Error::<T>::ReserveRatioTooLow);
    }

    // Throttle threshold (95%)
    if reserve_ratio < T::ThrottleThreshold::get() {
        if current_status == CircuitStatus::Normal {
            Status::<T>::put(CircuitStatus::Throttled);
        }
    } else {
        // Healthy - return to normal if throttled
        if current_status == CircuitStatus::Throttled {
            Status::<T>::put(CircuitStatus::Normal);
        }
    }

    Ok(())
}
\`\`\`

#### Auto-Pause Mechanisms

**Peg Deviation Auto-Pause**:
\`\`\`rust
/// Emergency pause threshold (10% peg deviation)
#[pallet::constant]
type EmergencyPauseThreshold: Get<u16>;  // Default: 1000 (10%)

// If EDSC price deviates >10% from $1.00, auto-pause
let price = EDSCPrice::<T>::get();  // In cents
let target = 100;  // $1.00

let deviation = if price > target {
    ((price - target) * 10000) / target
} else {
    ((target - price) * 10000) / target
};

if deviation > T::EmergencyPauseThreshold::get() {
    EmergencyPaused::<T>::put(true);
    Self::trigger_circuit(b"Peg deviation exceeded 10%");
}
\`\`\`

**Automatic Triggers**:
1. **Volume Spike**: >1M EDSC redeemed in 1 hour
2. **Reserve Depletion**: Reserve ratio <90%
3. **Peg Break**: EDSC price >$1.10 or <$0.90
4. **Rapid Liquidations**: >100 liquidations per hour
5. **Oracle Failure**: Price feed stale >1 hour

#### Whitelist System

**Whitelist Configuration**:
\`\`\`rust
/// Accounts exempt from circuit breaker restrictions
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

pub fn is_operation_allowed(account: &T::AccountId, amount: u128) -> DispatchResult {
    // Whitelisted accounts bypass restrictions
    if Whitelist::<T>::get(account) {
        return Ok(());
    }

    // Check circuit status for others
    match Status::<T>::get() {
        CircuitStatus::Emergency => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Paused => Err(Error::<T>::CircuitBreakerActive),
        CircuitStatus::Throttled => Ok(()),  // Limited operations allowed
        CircuitStatus::Normal => Ok(()),
    }
}
\`\`\`

**Whitelist Use Cases**:
- Emergency recovery accounts
- Protocol-owned liquidity providers
- Authorized market makers
- Treasury disbursement accounts

#### Storage Items

\`\`\`rust
/// Current circuit breaker status
Status<T: Config> = StorageValue<_, CircuitStatus>

/// Volume tracker for redemptions
RedemptionVolume<T: Config> = StorageValue<_, VolumeTracker<BlockNumber>>

/// Manual pause flag (governance-controlled)
ManualPauseEnabled<T: Config> = StorageValue<_, bool>

/// Whitelist of exempt accounts
Whitelist<T: Config> = StorageMap<_, T::AccountId, bool>

/// Total circuit trigger count
TriggerCount<T: Config> = StorageValue<_, u32>
\`\`\`

#### Extrinsics

**Governance Functions** (Root only):
\`\`\`rust
// Manually pause circuit
activate_manual_pause()

// Resume normal operations
resume()

// Add account to whitelist
add_to_whitelist(account: AccountId)

// Remove account from whitelist
remove_from_whitelist(account: AccountId)

// Reset circuit breaker
reset_circuit()
\`\`\`

**Automatic Functions** (Called by other pallets):
\`\`\`rust
// Check if operation allowed
is_operation_allowed(account, amount)

// Track redemption volume
track_volume(amount)

// Check reserve ratio thresholds
check_reserve_ratio(reserve_ratio)
\`\`\`

---

### 5. EMERGENCY RECOVERY PROCEDURES

This section documents critical emergency response protocols for the treasury and reserve system.

#### Treasury Emergency Freeze

**Scenario**: Suspected treasury compromise or unauthorized access

**Procedure**:
\`\`\`rust
// 1. Any Director can trigger immediate freeze
pub fn emergency_freeze_treasury() {
    // Pause all disbursements
    // Require 7/9 approval to unfreeze
    // Alert all directors via on-chain event
}

// 2. Investigation period (72 hours maximum)
// - Analyze suspicious transactions
// - Verify director identities
// - Check multisig signatures

// 3. Resolution requires 7/9 directors
pub fn unfreeze_treasury() {
    // Verify 7/9 director approvals
    // Resume normal operations
    // Document incident for transparency
}
\`\`\`

**Multi-Signature Recovery**:
\`\`\`bash
# Generate recovery transaction
etrid-cli treasury emergency-freeze \
  --director-keys /path/to/keys \
  --reason "Suspicious activity detected"

# Requires 7/9 signatures to unfreeze
etrid-cli treasury unfreeze \
  --approvals director1,director2,...,director7 \
  --verify-signatures
\`\`\`

#### Stuck Funds Recovery

**Scenario**: Funds locked due to smart contract bug or runtime upgrade issue

**Emergency Withdrawal Protocol**:
\`\`\`rust
pub fn emergency_withdrawal(
    origin: OriginFor<T>,
    recipient: T::AccountId,
    amount: BalanceOf<T>,
    description: Vec<u8>,
) -> DispatchResult {
    // Requires 7-of-9 director approvals
    // Can only withdraw from EmergencyReserve
    // Full audit trail recorded on-chain

    ensure!(
        disbursement.approval_count >= 7,
        Error::<T>::EmergencyThresholdNotMet
    );

    // Execute emergency transfer
    T::Currency::transfer(&Self::account_id(), &recipient, amount)?;

    // Emit detailed event
    Self::deposit_event(Event::EmergencyWithdrawal(amount, recipient, 7));
}
\`\`\`

**Recovery Steps**:
1. Directors identify stuck funds
2. Create emergency withdrawal proposal
3. Collect 7/9 director approvals
4. Execute recovery transaction
5. Post-mortem analysis and report
6. Protocol upgrade if needed

#### EDSC Peg Break Response

**Scenario**: EDSC price deviates >10% from $1.00 peg

**Response Protocol**:

**Phase 1: Automatic Circuit Breaker (Immediate)**
\`\`\`rust
// Auto-triggered when peg breaks
if edsc_price > 110 || edsc_price < 90 {  // In cents
    EmergencyPaused::<T>::put(true);
    Status::<T>::put(CircuitStatus::Emergency);

    Self::deposit_event(Event::EmergencyPauseActivated {
        triggered_by: system_account,
        reason: b"EDSC peg break >10%",
    });
}
\`\`\`

**Phase 2: Reserve Injection (Directors, <6 hours)**
\`\`\`rust
// Directors vote to inject reserves
pub fn inject_reserves_for_peg(
    amount: BalanceOf<T>,
) -> DispatchResult {
    // Requires 6/9 director approval
    // Deploy reserves to support peg
    // Buy EDSC if <$0.90 or sell if >$1.10
}
\`\`\`

**Phase 3: Interest Rate Adjustment (Immediate)**
\`\`\`rust
// Automatic interest rate response
if edsc_price < 99 {
    // EDSC trading below $1: Raise rates to encourage burning
    new_rate = current_rate.saturating_add(100);  // +1% annual
} else if edsc_price > 101 {
    // EDSC trading above $1: Lower rates to encourage minting
    new_rate = current_rate.saturating_sub(100);  // -1% annual
}

InterestRate::<T>::put(new_rate);
\`\`\`

**Phase 4: Governance Response (24-48 hours)**
- Emergency governance vote (if needed)
- Adjust collateralization requirements
- Modify reserve composition targets
- Implement additional stability mechanisms

#### Validator Payment Failure Recovery

**Scenario**: Validator rewards fail to distribute due to runtime issue

**Manual Distribution Procedure**:
\`\`\`bash
# 1. Identify affected validators and amounts
etrid-cli validator list-pending-rewards \
  --epoch 12345 \
  --output rewards.json

# 2. Create manual distribution proposal
etrid-cli treasury propose-batch-payment \
  --recipients rewards.json \
  --category Operations \
  --description "Manual validator reward distribution for epoch 12345"

# 3. Directors approve (6/9 required)
etrid-cli treasury approve-disbursement \
  --id 42 \
  --director-key /path/to/director/key

# 4. Verify distributions
etrid-cli validator verify-payments \
  --epoch 12345 \
  --check-balances
\`\`\`

**Compensation Protocol**:
- Calculate exact owed amounts per validator
- Include missed staking rewards
- Add compensation for delayed payment (0.1% per day)
- Execute via treasury Operations budget
- Document incident for protocol improvement

#### Consensus Day Failure Recovery

**Scenario**: Consensus Day process fails mid-execution

**Recovery Options**:

**Option 1: Rollback and Retry**
\`\`\`bash
# If failure detected early (within 1 hour)
# Rollback to pre-Consensus Day state
etrid-cli governance rollback-consensus-day \
  --snapshot-block 1234567 \
  --requires-7-of-9-approval

# Schedule retry
etrid-cli governance schedule-consensus-day-retry \
  --date "2025-12-02" \
  --preserve-votes
\`\`\`

**Option 2: Manual Execution**
\`\`\`bash
# If Minting phase fails
etrid-cli governance manual-mint \
  --approved-proposals approved.json \
  --director-approvals 7-of-9

# If Distribution phase fails
etrid-cli governance manual-distribute \
  --rewards rewards.json \
  --verify-totals
\`\`\`

**Option 3: Emergency Governance**
\`\`\`bash
# If complete failure
# Activate emergency governance mode
etrid-cli governance activate-emergency-mode \
  --requires-7-of-9-directors

# Execute critical operations manually
# Schedule special Consensus Day retry
\`\`\`

#### Multi-Signature Transaction System

**Emergency Multi-Sig Setup**:
\`\`\`rust
// 9 Directors with 6-of-9 threshold (normal)
// 7-of-9 threshold for emergency actions

pub struct MultiSigConfig {
    pub signatories: Vec<AccountId>,  // 9 directors
    pub normal_threshold: u8,         // 6
    pub emergency_threshold: u8,      // 7
}

// Create multi-sig transaction
pub fn create_multisig_call(
    call: Box<RuntimeCall>,
    is_emergency: bool,
) -> MultiSigTransaction {
    let threshold = if is_emergency { 7 } else { 6 };

    MultiSigTransaction {
        call,
        threshold,
        approvals: Vec::new(),
        created_at: current_block,
        expires_at: current_block + EXPIRATION_BLOCKS,
    }
}
\`\`\`

**Multi-Sig Emergency Workflow**:
\`\`\`bash
# 1. Create emergency transaction
etrid-cli multisig create \
  --call "treasury.emergency_withdrawal" \
  --threshold 7 \
  --signatories director1,director2,...,director9

# 2. Directors sign (collect 7 signatures)
etrid-cli multisig sign \
  --tx-hash 0x1234... \
  --director-key /path/to/key1

# 3. Execute when threshold reached
etrid-cli multisig execute \
  --tx-hash 0x1234... \
  --verify-signatures 7

# 4. Broadcast to network
etrid-cli multisig broadcast \
  --tx-hash 0x1234... \
  --wait-for-finality
\`\`\`

**Security Considerations**:
- Directors use hardware wallets for signing
- Multi-geographic distribution of signers
- Time-locked execution for certain actions
- Transparent on-chain audit trail
- Social recovery mechanisms
- Regular key rotation procedures

---

### 6. MONITORING AND TRANSPARENCY

#### Real-Time Dashboards

**Treasury Dashboard** (\`treasury.etrid.org\`):
- Total treasury balance (√ãTR + EDSC)
- Budget allocations vs. spending
- Pending disbursement proposals
- Director voting records
- Historical funding sources
- Monthly/yearly spending reports

**Reserve Dashboard** (\`reserve.etrid.org\`):
- Current reserve composition
- Asset allocations vs. targets
- Rebalancing history
- Total reserve value (USD)
- Whitelisted assets
- Oracle price feeds

**EDSC Dashboard** (\`edsc.etrid.org\`):
- Current EDSC price
- Total supply and circulation
- Collateralization ratio (system-wide)
- Interest rate history
- Active positions count
- Recent liquidations
- Stability fee revenue

**Circuit Breaker Dashboard** (\`safety.etrid.org\`):
- Current circuit status
- Hourly/daily volume metrics
- Reserve ratio trends
- Trigger count history
- Whitelisted accounts
- Recent status changes

#### On-Chain Transparency

All treasury and reserve operations emit detailed events:

\`\`\`rust
// Treasury Events
Event::FundsDeposited(source, amount)
Event::DisbursementProposed(id, proposer, category, amount, recipient)
Event::DisbursementApproved(id, director, approval_count)
Event::DisbursementExecuted(id, recipient, amount)
Event::EmergencyWithdrawal(amount, recipient, approvals)

// Reserve Events
Event::AssetAdded { asset_id, symbol }
Event::RebalanceTriggered { total_value, assets_count }
Event::ReserveValueUpdated { total_value_usd }

// EDSC Events
Event::EDSCMinted { who, collateral, edsc_amount, interest_rate }
Event::PositionLiquidated { owner, liquidator, edsc_amount, collateral_seized, penalty }
Event::InterestRateAdjusted { old_rate, new_rate, reason }

// Circuit Breaker Events
Event::StatusChanged { old_status, new_status }
Event::CircuitTriggered { reason }
Event::VolumeLimitExceeded { period, current_volume, max_volume }
\`\`\`

#### Audit Reports

**Quarterly Treasury Reports**:
- Total funds received (by source)
- Total funds disbursed (by category)
- Budget utilization rates
- Director approval statistics
- Emergency actions (if any)

**Annual Reserve Audit**:
- Asset holdings verification
- Rebalancing performance
- Oracle price accuracy
- Risk metrics analysis
- Recommendations for improvements

---

### 7. INTEGRATION WITH CONSENSUS DAY

The treasury and reserve systems integrate tightly with the annual Consensus Day governance process:

#### Budget Allocation Updates

During Consensus Day, the community votes on budget allocations:

\`\`\`rust
// After Consensus Day voting concludes:
pub fn update_allocations_from_consensus(
    approved_allocations: BudgetAllocations,
) -> DispatchResult {
    // Validate allocations sum to 100%
    ensure!(approved_allocations.is_valid(), Error::<T>::InvalidBudgetAllocations);

    // Update treasury allocations
    BudgetAllocationsStorage::<T>::put(approved_allocations.clone());

    Self::deposit_event(Event::BudgetAllocationsUpdated(approved_allocations));

    Ok(())
}
\`\`\`

#### Minting Phase Integration

Approved budgets are minted and allocated:

\`\`\`rust
// Called by pallet-consensus-day during Phase 3: Minting
pub fn receive_consensus_day_minting(amount: BalanceOf<T>) -> DispatchResult {
    // Mint to treasury
    let treasury_account = Self::account_id();
    T::Currency::deposit_creating(&treasury_account, amount);

    // Update balance
    TreasuryBalance::<T>::mutate(|balance| {
        *balance = balance.saturating_add(amount);
    });

    // Allocate to categories based on approved percentages
    Self::allocate_to_categories(amount)?;

    Ok(())
}
\`\`\`

#### Reserve Composition Updates

Community can vote to adjust EDSC reserve targets:

\`\`\`rust
// Consensus Day proposal to update reserve composition
pub fn update_target_composition(
    origin: OriginFor<T>,
    new_composition: ReserveComposition,
) -> DispatchResult {
    ensure_root(origin)?;  // Only via governance vote

    // Validate composition sums to 100%
    let total = new_composition.etr_allocation as u32
        + new_composition.sbtc_allocation as u32
        + new_composition.seth_allocation as u32
        + new_composition.other_allocation as u32;

    ensure!(total == 10000, Error::<T>::InvalidReserveComposition);

    TargetReserveComposition::<T>::put(new_composition.clone());

    // Trigger rebalancing to new targets
    Self::trigger_automatic_rebalance()?;

    Ok(())
}
\`\`\`

---

### 8. CONCLUSION

The treasury and reserve system implementation represents a comprehensive financial infrastructure for the √ãtrid protocol. Through four specialized pallets, the system provides:

- **Transparent Governance**: Multi-signature controls with 9 elected Directors
- **Fiscal Sustainability**: Multiple funding sources and disciplined budget management
- **Stablecoin Stability**: Multi-asset reserve backing with automatic rebalancing
- **Risk Management**: Circuit breaker protections and emergency response protocols

This infrastructure enables √ãtrid to operate as a truly self-governing, self-funding decentralized network without relying on centralized entities.

**System Status**: Production-ready (Q4 2025)
**Audit Status**: Pending external security audit
**Documentation**: Complete technical specifications available in pallet source code

---

*"Financial sovereignty begins with transparent, community-controlled treasury management."*

**‚Äì Treasury & Reserve System Implementation Team**
**√ãtrid Foundation**

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    }
        };

    let base_reward = participation_pool * voter_share;
    let final_reward = base_reward * completeness_multiplier;

    Balance::from(final_reward as u128)
}
\`\`\`

**Distribution Components**:
1. **Participation Rewards**: 1% of minted tokens divided among voters
2. **Validator Rewards**: Validators receive 0.5% bonus for participation
3. **Proposer Rewards**: Approved proposals earn 100 √âTR per proposal
4. **Director Stipends**: 9 Directors receive equal shares (total: 0.2% of mint)

**Distribution Example**:

If 100M √âTR minted during Consensus Day:
\`\`\`
Total Minted:            100,000,000 √âTR
Participation Pool (1%):   1,000,000 √âTR ‚Üí Divided among voters
Validator Bonus (0.5%):      500,000 √âTR ‚Üí Divided among validators
Director Stipends (0.2%):    200,000 √âTR ‚Üí 22,222 √âTR per Director
Proposer Rewards:            100 √âTR √ó approved proposals
Remaining:               98,300,000 √âTR ‚Üí Treasury for budgets
\`\`\`

---

## 2. GOVERNANCE ROLES & RESPONSIBILITIES

### Role Hierarchy

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Community (All √âTR Holders)      ‚îÇ
‚îÇ  - Vote on proposals                        ‚îÇ
‚îÇ  - Elect Directors                          ‚îÇ
‚îÇ  - Propose changes (‚â•10k √âTR)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Directors   ‚îÇ   ‚îÇ    Validators    ‚îÇ
‚îÇ  (9 members) ‚îÇ   ‚îÇ  (Active Set)    ‚îÇ
‚îÇ  - Oversee   ‚îÇ   ‚îÇ  - Validate      ‚îÇ
‚îÇ  - Veto      ‚îÇ   ‚îÇ  - Secure        ‚îÇ
‚îÇ  - Emergency ‚îÇ   ‚îÇ  - Vote          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

### The Community (Token Holders)

**Power**:
- Vote on all proposals during Consensus Day
- Elect 9 Decentralized Directors annually
- Propose protocol changes (requires ‚â•10,000 √âTR bond)
- Delegate voting power to trusted parties

**Responsibilities**:
- Participate in annual governance
- Review proposals and technical documentation
- Report bugs, vulnerabilities, exploits
- Contribute to ecosystem growth

**Rights**:
- Receive staking rewards
- Access to all governance decisions and data
- Freedom to fork the network (GPLv3)

### Decentralized Directors (The Board)

**Composition**: 9 individuals elected annually

**Requirements**:
- **Minimum stake: 128 √âTR**
- **Must serve as OD Flare Nodes** (Operational Director Flare Nodes)
- Must maintain active participation in network operations

**Term**: 1 year (renewable via re-election)

**Term Limits**:
- **One-year terms**
- **One-year cooldown** between terms
- **Maximum 3 lifetime terms** (cannot serve more than 3 total terms)

**Election Process**:
1. Candidates announce during Pre-Consensus Period (Jan 1 - Oct 31)
2. Community votes on Consensus Day (December 1)
3. Top 9 vote-getters elected
4. Ties resolved by stake-weighted runoff
5. Voting power = Staked √âTR √ó Coinage

**Powers**:
1. **Governance Oversight**: Oversee development and consensus proposals
2. **Protocol Maintenance**: Coordinate security audits, bug bounties
3. **Representation**: Speak for √ãtrid at conferences, media, partnerships
4. **Treasury Management**: Approve budget disbursements (community-authorized)
5. **Emergency Coordination**: Coordinate response to network emergencies

**Limitations**:
- Cannot change protocol without community consensus vote
- Cannot mint tokens outside Consensus Day
- **No hierarchy** among Directors - all decisions are community-driven
- Cannot override community supermajority
- Subject to term limits (max 3 lifetime terms)

**Compensation**:
- **Community-voted salaries** (determined annually on Consensus Day)
- No predetermined amounts - stakeholders decide compensation
- Funded from Consensus Day distribution

**Accountability**:
- Regular public reports required
- Can be removed mid-term via emergency community vote
- All communications public and logged
- Bound by Foundation bylaws

### VALIDITY Nodes (Validators)

**Role**: √ãtrid Partitioned Burst Chain nodes in consensus, syncing with Flare Chain. Responsible for block production, finality attestation, and cross-chain state verification.

**Requirements**:
- **Minimum stake: 64 √âTR**
- Hardware: 8-core CPU, 32GB RAM, 1TB SSD, 1Gbps network
- Uptime: >98% (measured over 30-day rolling window)
- Must run full nodes for FlareChain + ‚â•1 PBC
- Identity: Must verify on-chain identity (no KYC, just persistent identity)

**Node Statuses**:
- Registered
- Pending
- Sequenced
- Chilled
- De-Sequenced
- Re-Sequenced

**Rewards**:
\`\`\`rust
fn calculate_validator_reward(
    validator: &Validator,
    epoch_duration: BlockNumber,
    total_validator_pool: Balance,
) -> Balance {
    // Base reward proportional to stake
    let stake_ratio = validator.stake / total_active_stake();
    let base_reward = total_validator_pool * stake_ratio;

    // Uptime multiplier (0.90 - 1.10)
    let uptime_multiplier = 0.9 + (validator.uptime - 0.95).max(0.0) * 2.0;

    // Finality contribution (signed blocks / expected blocks)
    let finality_multiplier = validator.blocks_signed / validator.blocks_expected;

    // Final reward
    base_reward * uptime_multiplier * finality_multiplier
}
\`\`\`

**Slashing**:
- **Downtime**: -1% stake per day offline (after 24h grace period)
- **Equivocation**: -10% stake for double-signing blocks
- **Malicious Behavior**: -50% stake + removal for provable attacks
- **Censorship**: -5% stake for ignoring valid transactions

### Common Stake Peers

**Role**: Stakeholders who participate in governance without running full node infrastructure

**Requirements**:
- **Minimum stake: 1+ √âTR**

**Privileges**:
- Voting on proposals during Consensus Day
- Campaigning for proposals
- Reporting faults and issues
- Earning rewards based on stake, coinage, and activity

**Voting Power Formula**:
\`\`\`
Voting Power = Staked √âTR √ó Coinage
\`\`\`

Where coinage represents how long tokens have been staked (time-weighted stake)
- Must run full nodes for FlareChain + ‚â•3 PBCs
- Must respond to verification requests within 10 blocks

**Rewards**:
- 0.1% fee on all cross-chain transactions
- Proportional to verification work performed
- Paid from cross-chain transaction fees

**Slashing**:
- -20% stake for incorrect verification
- -50% stake for colluding to pass invalid proofs

### The Foundation (Pre-Mainnet Only)

**Role**: Bootstrap the network until first Consensus Day

**Powers**:
- Set initial parameters (inflation, fees, block times)
- Deploy initial infrastructure
- Fund initial development
- Conduct security audits

**Sunset Clause**:
- Foundation dissolves after first successful Consensus Day
- All remaining funds transferred to community treasury
- No ongoing authority or control

---

## 3. FISCAL CYCLE & TREASURY MANAGEMENT

### Treasury Architecture

**Treasury Account**: On-chain multisig controlled by 9 Directors (6-of-9 threshold)

**Funding Sources**:
1. **Transaction Fees**: 50% of all fees ‚Üí Treasury (50% burned)
2. **Consensus Day Minting**: Approved budgets minted to treasury
3. **Validator Slashing**: 50% of slashed stakes ‚Üí Treasury (50% burned)
4. **Cross-Chain Fees**: 10% of bridge fees ‚Üí Treasury

**Treasury Balance Formula**:
\`\`\`rust
fn calculate_treasury_balance() -> Balance {
    let inflows = transaction_fees * 0.5
                + consensus_day_mint
                + slashing_proceeds * 0.5
                + bridge_fees * 0.1;

    let outflows = budget_disbursements
                 + validator_rewards
                 + director_stipends
                 + emergency_expenses;

    previous_balance + inflows - outflows
}
\`\`\`

### Fiscal Year Cycle

**Fiscal Year**: December 1st ‚Üí November 30th (aligned with Consensus Day)

**Budget Categories**:
1. **Development** (40% of budget): Core protocol, tools, libraries
2. **Marketing** (20% of budget): Education, outreach, partnerships
3. **Operations** (15% of budget): Infrastructure, monitoring, support
4. **Grants** (15% of budget): Community projects, research, ecosystem
5. **Emergency Reserve** (10% of budget): Held for crisis response

**Budget Approval Process**:
1. **Consensus Day**: Community votes on budget allocation per category
2. **Director Oversight**: Directors approve individual disbursements
3. **Quarterly Review**: Directors publish spending reports every 3 months
4. **Annual Audit**: Third-party audit published before next Consensus Day

### Treasury Transparency

**All treasury actions emit events**:
\`\`\`rust
enum TreasuryEvent {
    Deposit { source: DepositSource, amount: Balance },
    Disbursement { category: BudgetCategory, recipient: AccountId, amount: Balance },
    DirectorVote { director: AccountId, proposal_id: u64, vote: bool },
    QuarterlyReport { quarter: u8, total_spent: Balance, category_breakdown: Vec<(BudgetCategory, Balance)> },
}
\`\`\`

**Public Dashboard**:
- Real-time treasury balance
- All incoming/outgoing transactions
- Budget vs. actual spending per category
- Director voting records
- Historical trends (YoY comparison)

### Mint and Burn Dynamics

**Minting Events**:
1. **Consensus Day**: Annual minting for approved budgets
2. **Emergency Minting**: Directors can mint (7/9 vote) in crisis (max 1% of supply)

**Burning Events**:
1. **Transaction Fees**: 50% of all fees burned
2. **Validator Slashing**: 50% of slashed stakes burned
3. **Deflationary Votes**: Community can vote to burn treasury reserves

**Net Supply Formula**:
\`\`\`rust
fn calculate_net_supply_change(epoch: Epoch) -> i128 {
    let minted = consensus_day_mint + emergency_mint;
    let burned = transaction_fees * 0.5 + slashing_proceeds * 0.5 + voluntary_burns;

    (minted as i128) - (burned as i128)
}
\`\`\`

**Target**: Long-term supply should stabilize or decrease slowly (deflationary tendency)

---

## 4. TOKEN ECONOMICS (√âTR, EDSC, VMw)

### √âTR (√ãtrid Token)

**Purpose**: Governance, staking, gas fees

**Total Supply**: 1 Billion √âTR (initial), subject to inflation/deflation

**Initial Distribution**:
\`\`\`
Genesis Block:           1,000,000,000 √âTR

Allocation:
- Public Sale (40%):       400,000,000 √âTR
- Foundation (25%):        250,000,000 √âTR (4-year vesting)
- Team (15%):              150,000,000 √âTR (3-year vesting)
- Validators (10%):        100,000,000 √âTR (incentive pool)
- Ecosystem Grants (10%):  100,000,000 √âTR (unlocked)
\`\`\`

**Inflation/Deflation**:
- **Inflation**: Voted annually (0-5% cap), minted on Consensus Day
- **Deflation**: Transaction fees + slashing continuously burned
- **Net Effect**: Tends toward slight deflation long-term

**Use Cases**:
1. **Staking**: Lock √âTR to become validator or voter
2. **Gas Fees**: Pay for transactions (measured in VMw, priced in √âTR)
3. **Governance**: Vote on proposals during Consensus Day
4. **Collateral**: Back EDSC stablecoin (over-collateralized)

### EDSC (√ãtrid Dollar Stablecoin)

**Purpose**: Stable unit of account for payments, contracts

**Peg**: $1.00 USD (soft peg maintained by arbitrage + liquidations)

**Collateral**: Over-collateralized by multi-asset reserve (target: 150%)

**Reserve Infrastructure**:

EDSC is backed by a diversified multi-asset reserve managed through two specialized pallets:

1. **pallet-multiasset-reserve**: Manages reserve composition and automated rebalancing
2. **pallet-reserve-backed-token**: Handles EDSC minting and collateral positions

**Reserve Composition**:
\`\`\`
Target Allocation (example):
- 40% √âTR (native token)
- 30% BTC (bridged from BTC-PBC)
- 20% ETH (bridged from ETH-PBC)
- 10% Other assets (governance-approved)

Rebalancing:
- Triggered when deviation exceeds 5%
- Automated via pallet-multiasset-reserve
- Governance can adjust allocation strategy
\`\`\`

**Allocation Strategies**:
- **EqualWeight**: Equal distribution across all reserve assets
- **MarketCapWeighted**: Weight by market capitalization
- **RiskAdjusted**: Weight by volatility/risk metrics
- **Custom**: Custom weights set by governance vote

**Minting Process**:
\`\`\`rust
fn mint_edsc(collateral_amount: Balance) -> Result<Balance, Error> {
    let etr_price_usd = oracle::get_etr_price(); // From price oracle
    let collateral_value_usd = collateral_amount * etr_price_usd;

    // Require 150% collateralization
    let max_edsc_mintable = collateral_value_usd / 1.5;

    // Lock collateral in reserve
    lock_collateral(caller, collateral_amount)?;

    // Mint EDSC via pallet-reserve-backed-token
    mint_stablecoin(caller, max_edsc_mintable)?;

    // Reserve automatically rebalances if needed
    if should_rebalance() {
        trigger_rebalance()?;
    }

    Ok(max_edsc_mintable)
}
\`\`\`

**Liquidation Process**:
\`\`\`rust
fn check_liquidation(cdp: &CollateralDebtPosition) -> bool {
    let etr_price_usd = oracle::get_etr_price();
    let collateral_value = cdp.collateral_amount * etr_price_usd;
    let debt_value = cdp.edsc_minted; // 1 EDSC = $1

    let collateralization_ratio = collateral_value / debt_value;

    // Liquidate if ratio falls below 120% (updated threshold)
    if collateralization_ratio < 1.2 {
        liquidate_cdp(cdp);
        true
    } else {
        false
    }
}
\`\`\`

**Collateralization Parameters**:
\`\`\`
Minimum Collateral Ratio: 150%
Liquidation Threshold:     120%
Liquidation Penalty:       5%

Example:
To mint 1000 EDSC ($1000 value):
‚Üí Requires: $1500 in collateral (150%)
‚Üí Liquidated if collateral falls to $1200 (120%)
‚Üí Liquidator receives: $1200 + 5% penalty = $1260
‚Üí Position holder loses: $60 to liquidator
\`\`\`

**Stability Mechanisms**:
1. **Multi-Asset Reserve**: Reduces correlation risk compared to single-asset backing
2. **Automated Rebalancing**: Maintains target allocations via pallet-multiasset-reserve
3. **Over-Collateralization**: 150% target ratio prevents undercollateralization
4. **Liquidation**: Automated liquidations at 120% ratio (updated from 110%)
5. **Liquidation Penalty**: 5% penalty incentivizes proper position management
6. **Interest Rates**: Dynamic interest on borrowed EDSC adjusts to maintain peg
7. **Arbitrage**: Price deviations create profitable arbitrage opportunities
8. **DEX Integration**: FlareSwap enables efficient √âTR/EDSC trading and price discovery

**Reserve-Backed Token Framework**:

Beyond EDSC, the reserve infrastructure enables creation of diverse synthetic assets:

**Synthetic Asset Types**:
- **Stablecoins**: EDSC (USD), EEUR (Euro), EGBP (Pound)
- **Commodities**: EXAU (Gold), EXAG (Silver), EXOIL (Oil)
- **Equities**: ETSLA (Tesla), EAAPL (Apple), EGOOG (Google)
- **Indices**: ES&P (S&P 500), ENASDAQ (Nasdaq), EDJI (Dow Jones)

**Governance Controls**:
- Whitelisting of reserve assets (Consensus Day vote required)
- Adjustment of collateralization ratios per synthetic
- Rebalancing strategy selection
- Emergency pause of minting/liquidations

### VMw (Virtual Machine Watts)

**Purpose**: Measure computational cost (gas metering)

**Definition**: 1 VMw = 1 Watt-second of CPU energy

**Pricing**:
\`\`\`rust
fn calculate_gas_price() -> Balance {
    // Dynamic pricing based on block fullness
    let block_utilization = current_block_vmw / max_block_vmw; // 0.0 - 1.0

    // Base price: 1 VMw = 0.000001 √âTR
    let base_price = 1_000_000_000_000u128; // 1e-6 √âTR in plancks

    // Price increases exponentially with utilization
    let surge_multiplier = if block_utilization > 0.75 {
        1.0 + ((block_utilization - 0.75) * 8.0)
    } else {
        1.0
    };

    Balance::from((base_price as f64 * surge_multiplier) as u128)
}
\`\`\`

**Block Limits**:
- **Max VMw per block**: 10,000,000 VMw
- **Target utilization**: 50% (5,000,000 VMw)
- **Surge pricing**: Kicks in above 75% utilization

**Example Transaction Costs**:
\`\`\`
Simple Transfer:           100 VMw   ‚âà 0.0001 √âTR   ($0.001 at $10/√âTR)
Token Swap:              5,000 VMw   ‚âà 0.005 √âTR    ($0.05)
Complex Contract:       50,000 VMw   ‚âà 0.05 √âTR     ($0.50)
Cross-Chain Bridge:    200,000 VMw   ‚âà 0.2 √âTR      ($2.00)
\`\`\`

---

## 5. PROPOSAL SYSTEM & VOTING MECHANISMS

### Proposal Lifecycle

\`\`\`
1. Draft ‚Üí 2. Submission ‚Üí 3. Discussion ‚Üí 4. Voting ‚Üí 5. Execution
   (Off-chain)  (Registration)   (48h window)    (12h vote)   (Minting + Distribution)
\`\`\`

### Proposal Template

**Minimum Requirements**:
\`\`\`markdown
# Proposal Title (max 100 chars)

## Summary (max 300 chars)
One-paragraph overview accessible to all voters.

## Motivation
Why is this proposal necessary? What problem does it solve?

## Specification
Technical details. How will this be implemented?

## Budget Request (if applicable)
Amount: _______ √âTR
Breakdown:
  - Development: _______ √âTR
  - Audit: _______ √âTR
  - Deployment: _______ √âTR

## Implementation Timeline
Phase 1: (date range) - Milestone 1
Phase 2: (date range) - Milestone 2
...

## Success Criteria
How will we know this proposal succeeded?

## Risks & Mitigations
What could go wrong? How will we address it?

## Supporting Validators (min 3)
- Validator 1: [address]
- Validator 2: [address]
- Validator 3: [address]
\`\`\`

### Voting Rules

**Vote Types**:
1. **Yes**: Support the proposal
2. **No**: Reject the proposal
3. **Abstain**: Count toward quorum but not approval

**Quadratic Voting** (Optional, for contentious issues):
\`\`\`rust
fn calculate_quadratic_vote_cost(num_votes: u32) -> Balance {
    // Cost increases quadratically
    // 1 vote = 1 √âTR, 2 votes = 4 √âTR, 3 votes = 9 √âTR, etc.
    let cost_per_vote = num_votes * num_votes;
    Balance::from(cost_per_vote as u128 * VOTE_COST_BASE)
}
\`\`\`

**Conviction Voting** (Optional, for long-term decisions):
\`\`\`rust
enum Conviction {
    None,       // 1x voting power, unlock immediately
    Locked1x,   // 1x voting power, locked 1 epoch after vote
    Locked2x,   // 2x voting power, locked 2 epochs
    Locked4x,   // 4x voting power, locked 4 epochs
    Locked8x,   // 8x voting power, locked 8 epochs
}
\`\`\`

### Proposal Execution

**Automatic Execution**:
- If proposal approved with quorum ‚Üí Executed in Phase 3 (Minting)
- If proposal rejected ‚Üí Bond returned (if >5% quorum), proposal archived
- If proposal doesn't reach quorum ‚Üí Bond slashed, proposal discarded

**Manual Execution** (for protocol upgrades):
- Directors + validators coordinate deployment
- Upgrade scheduled for specific block height
- All nodes must upgrade before deadline

---

## 6. REWARD DISTRIBUTION & SLASHING

### Validator Rewards

**Annual Validator Reward Pool**: ~3% of circulating supply

**Distribution**:
\`\`\`rust
fn distribute_epoch_rewards(epoch: Epoch) {
    let total_pool = circulating_supply() * 0.03 / EPOCHS_PER_YEAR;

    for validator in active_validators() {
        let base_reward = total_pool * (validator.stake / total_stake);
        let adjusted_reward = base_reward * validator.performance_multiplier;

        // Pay 50% to validator, 50% to delegators
        pay_reward(validator.account, adjusted_reward * 0.5);
        pay_delegators(validator, adjusted_reward * 0.5);
    }
}
\`\`\`

**Performance Multiplier**:
\`\`\`rust
fn calculate_performance_multiplier(validator: &Validator) -> f64 {
    let uptime_score = validator.uptime; // 0.0 - 1.0
    let finality_score = validator.blocks_signed / validator.blocks_expected;
    let participation_score = if validator.voted_consensus_day { 1.1 } else { 1.0 };

    uptime_score * finality_score * participation_score
}
\`\`\`

### Delegator Rewards

**Delegation Mechanism**:
- Token holders can delegate √âTR to validators
- Validators charge commission (0-100%, set by validator)
- Rewards automatically distributed each epoch

**Commission Structure**:
\`\`\`rust
fn distribute_delegation_rewards(validator: &Validator, total_reward: Balance) {
    let commission_rate = validator.commission; // e.g., 0.10 = 10%
    let commission_amount = total_reward * commission_rate;
    let delegator_pool = total_reward - commission_amount;

    // Pay commission to validator
    pay_reward(validator.account, commission_amount);

    // Distribute remaining to delegators proportionally
    for delegator in validator.delegators() {
        let delegator_share = delegator.stake / validator.total_delegated;
        let delegator_reward = delegator_pool * delegator_share;
        pay_reward(delegator.account, delegator_reward);
    }
}
\`\`\`

### Slashing Conditions

**Offense Types**:

| Offense | Severity | Slash Amount | Cooldown |
|---------|----------|--------------|----------|
| Downtime (>24h) | Low | 1% per day | 7 days |
| Missed blocks (>10%) | Low | 0.5% | 3 days |
| Equivocation (double-sign) | High | 10% | 30 days |
| Invalid finality vote | High | 5% | 14 days |
| Censorship (provable) | Medium | 5% | 14 days |
| Coordinated attack | Critical | 50% + removal | Permanent ban |

**Slashing Execution**:
\`\`\`rust
fn execute_slash(
    validator: AccountId,
    offense: OffenseType,
    evidence: Vec<u8>,
) -> Result<(), Error> {
    // Verify evidence
    verify_offense_evidence(offense, evidence)?;

    // Calculate slash amount
    let slash_amount = match offense {
        OffenseType::Downtime => validator.stake * 0.01,
        OffenseType::Equivocation => validator.stake * 0.10,
        OffenseType::MaliciousAttack => validator.stake * 0.50,
        // ... other offenses
    };

    // Execute slash
    burn_tokens(validator, slash_amount * 0.5); // 50% burned
    transfer_to_treasury(slash_amount * 0.5);   // 50% to treasury

    // Apply cooldown
    apply_validator_cooldown(validator, offense.cooldown_period);

    // Emit event
    emit_event(Event::ValidatorSlashed {
        validator,
        offense,
        amount: slash_amount,
        timestamp: current_block(),
    });

    Ok(())
}
\`\`\`

### Appeal Process

**Validators can appeal slashing**:
1. Submit appeal within 72 hours (costs 1,000 √âTR bond)
2. Directors review evidence (7/9 vote required to overturn)
3. If appeal successful: slash reversed, bond returned
4. If appeal rejected: bond added to treasury

---

## 7. ECONOMIC SUSTAINABILITY MODEL

### Long-Term Supply Dynamics

**Target**: Slightly deflationary long-term (~1% annual deflation)

**Inflows** (Minting):
- Consensus Day approved budgets: 0-5% per year (voted)
- Emergency minting: <0.1% per year (rare)

**Outflows** (Burning):
- Transaction fees: ~50% of fees (continuous)
- Slashing: ~50% of slashed stakes (episodic)
- Voluntary burns: Community-voted (rare)

**Net Supply Projection**:
\`\`\`
Year 1:  1.00B √âTR (genesis)
Year 2:  1.02B √âTR (+2% voted inflation - 1% burned = +1% net)
Year 3:  1.03B √âTR (+2% inflation - 1.5% burned = +0.5% net)
Year 5:  1.04B √âTR (+1.5% inflation - 2% burned = -0.5% net)
Year 10: 1.00B √âTR (back to genesis, deflationary equilibrium)
\`\`\`

### Fee Market Dynamics

**Transaction Fee Formula**:
\`\`\`rust
fn calculate_transaction_fee(vmw_cost: u64, priority: Priority) -> Balance {
    let base_fee = vmw_cost * get_current_vmw_price(); // Dynamic pricing

    let priority_multiplier = match priority {
        Priority::Low => 0.8,
        Priority::Normal => 1.0,
        Priority::High => 1.5,
        Priority::Urgent => 3.0,
    };

    base_fee * priority_multiplier
}
\`\`\`

**Fee Allocation**:
- 50% burned (deflationary pressure)
- 40% to validators (reward for block production)
- 10% to treasury (public goods funding)

### Economic Security

**Attack Cost Analysis**:

To attack √ãtrid, an adversary must:
1. Acquire >33% of staked √âTR (to disrupt finality)
2. Operate attack for multiple epochs before detection
3. Survive slashing and social coordination against them

**Cost**:
\`\`\`
Assume 40% of supply staked (400M √âTR)
33% of staked = 132M √âTR
At $10/√âTR = $1.32 Billion capital requirement

Cost of attack:
- Capital cost: $1.32B
- Slashing risk: 50% = $660M loss if caught
- Opportunity cost: 8% APY = $105M/year forgone rewards
- Reputation cost: √âTR price crash ‚Üí total loss

Total cost: >$2 Billion for 51% attack
\`\`\`

**Conclusion**: Economic security increases with network value and participation

---

## 8. EMERGENCY PROCEDURES & CRISIS RESPONSE

### Emergency Powers

**Directors Emergency Authority** (7-of-9 vote):
1. **Pause Chains**: Temporarily halt block production (max 72 hours)
2. **Emergency Upgrade**: Deploy hotfix without Consensus Day vote
3. **Slash Malicious Actors**: Immediate slashing for provable attacks
4. **Emergency Mint**: Mint up to 1% of supply for critical bug bounty

### Crisis Response Protocol

**Level 1: Minor Issue** (e.g., validator downtime spike)
- Response Team: On-call validators
- Action: Monitor, alert community
- Timeline: 24-hour resolution

**Level 2: Moderate Issue** (e.g., smart contract exploit)
- Response Team: Directors + Security Team
- Action: Pause affected pallets, deploy patch
- Timeline: 48-hour resolution

**Level 3: Critical Issue** (e.g., consensus failure)
- Response Team: All Directors + Core Developers + Community
- Action: Emergency governance vote, possible chain halt
- Timeline: Immediate action, 7-day resolution

### Social Recovery

**If network becomes compromised beyond repair**:
1. **Snapshot**: Take state snapshot at last known good block
2. **Fork**: Create new chain from snapshot
3. **Migrate**: Community coordinates migration to new chain
4. **Deprecate**: Old chain deprecated, new chain becomes canonical

**GPLv3 Protection**: Anyone can fork and continue the network

---

## 9. CONCLUSION: GOVERNANCE AS A LIVING SYSTEM

### Why This Model Works

1. **Alignment**: Token holders, validators, and users all benefit from network success
2. **Adaptation**: Annual Consensus Day forces regular evolution
3. **Transparency**: All decisions on-chain, all treasury actions public
4. **Resilience**: No single point of failure, multiple layers of accountability
5. **Sustainability**: Self-funding via fees, deflationary tendency prevents inflation

### Comparison to Other Models

| Feature | √ãtrid | Bitcoin | Ethereum | Polkadot |
|---------|-------|---------|----------|----------|
| **Governance** | On-chain annual vote | Off-chain (BIPs) | Off-chain (EIPs) | On-chain (referenda) |
| **Treasury** | Autonomous | None | Foundation-controlled | Autonomous |
| **Inflation** | Voted (0-5%) | Fixed (halving) | Fixed (~1%) | Fixed (~10%) |
| **Participation** | >33% quorum | N/A | ~5% typical | ~10% typical |
| **Emergency Powers** | Directors (7/9) | None | Foundation | Council |

### The Path to Sovereignty

√ãtrid governance is designed to achieve **true decentralization** through:
- **Economic incentives** (rewards for participation)
- **Social accountability** (transparent decisions, elected directors)
- **Technical constraints** (protocol-enforced caps, slashing)
- **Regular rhythm** (annual Consensus Day prevents drift)

**The goal**: A network that governs itself, funds itself, and evolves without relying on any central authority.

---

## APPENDIX A: Consensus Day Checklist

**For Voters**:
- [ ] Review all proposals (published 7 days before Consensus Day)
- [ ] Lock √âTR during Registration Phase (6 hours)
- [ ] Vote on all proposals during Voting Phase (12 hours)
- [ ] Claim participation rewards during Distribution Phase (1 hour)

**For Validators**:
- [ ] Signal participation during Registration Phase
- [ ] Vote on all proposals during Voting Phase
- [ ] Monitor network health during Minting Phase
- [ ] Verify reward distribution during Distribution Phase

**For Directors**:
- [ ] Review all proposals and publish recommendations
- [ ] Monitor quorum and voting during Voting Phase
- [ ] Execute approved budgets during Minting Phase
- [ ] Verify distribution accuracy during Distribution Phase

---

## APPENDIX B: Governance Formulas

### Quorum Calculation
\`\`\`rust
fn quorum_met(proposal: &Proposal) -> bool {
    let community_votes = proposal.total_votes;
    let validator_votes = proposal.validator_count;

    (community_votes >= circulating_supply() * 0.33) &&
    (validator_votes >= active_validator_count() * 0.51)
}
\`\`\`

### Approval Calculation
\`\`\`rust
fn proposal_approved(proposal: &Proposal) -> bool {
    let yes_votes = proposal.yes_votes;
    let total_votes = proposal.yes_votes + proposal.no_votes; // Abstain doesn't count

    let threshold = match proposal.category {
        ProposalCategory::BudgetAllocation => 0.50,
        ProposalCategory::ParameterChange => 0.50,
        ProposalCategory::ProtocolUpgrade => 0.66,
        ProposalCategory::EmergencyAction => 0.66,
    };

    (yes_votes as f64 / total_votes as f64) >= threshold
}
\`\`\`

---

## APPENDIX C: Further Reading

**Volume I**: Conceptual Architecture (Vision, Problem, Solution, Philosophy)
**Volume II**: Technical Specification (E¬≥20, ASF, VMw, Runtime)

**Online Resources**:
- Governance Portal: governance.etrid.org
- Proposal Archive: proposals.etrid.org
- Treasury Dashboard: treasury.etrid.org

---

**End of Volume III**

**√ãtrid Ivory Papers Complete**

---

*"Governance is not a feature to be added. It is the fundamental architecture of coordination."*

---

**Document Status**: ACTIVE PROTOCOL SPECIFICATION
**Next Review**: Consensus Day 2026 (December 1, 2026)

---

## CLOSING REMARKS

To be quite frank, I have never considered the status quo an unequivocal consensus of a group of people.

Considering the multitude of variables that go into decision-making, it is difficult to fathom how what was, still is, and will always be.

This idea does not promote growth, prosperity, fairness, or decentralization.

It often feels forced upon you and remains unchallenged due to cultural reinforcement and other factors.

This stagnation in society has shifted power from those who could effect change to those who benefit from maintaining the status quo.

We are in a unique period in which power can be reclaimed by the powerless.

Exploitation of personal data can be stopped, and disintermediation of trusted third parties can become the norm.

Borders can be reimagined.

When liberties such as digital rights, data protection, and decentralized finance are on the line for our generation and the generations to come, I will fight until my last breath.

The √ãtrid FOODOS Project will be our vehicle in this fight ‚Äî a free and open decentralized democracy of stakeholders.

By cutting the mental chains of reliance on a central intermediary and becoming self-sufficient stakeholders, we can achieve a brighter tomorrow.

**‚Äì Eoj Edred**
**Founder, √ãtrid FODDoS Project**

---

*"Provide a flare and guide the way, the future of tomorrow is decided today."*

**‚Äì Eoj Edred**

`
    },
};

        // Get URL parameters
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name) || 'ivory-paper';
        }

        // Load paper content
        function loadPaper(docKey) {
            const paper = embeddedPapers[docKey];
            if (!paper) {
                document.getElementById('content').innerHTML = '<p>Paper not found.</p>';
                return;
            }

            // Parse markdown to HTML using marked() for compatibility
            const htmlContent = marked(paper.content);
            document.getElementById('content').innerHTML = htmlContent;

            // Update active button
            document.querySelectorAll('.doc-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btn-${docKey}`).classList.add('active');

            // Update page title
            document.title = paper.title + ' - √ãTRID';

            // Scroll to top
            window.scrollTo(0, 0);
        }

        // Download current paper
        function downloadCurrent() {
            const docKey = getUrlParameter('doc');
            const paper = embeddedPapers[docKey];
            downloadMarkdown(paper.content, paper.filename);
        }

        // Download all papers as zip (simulate by downloading one by one)
        function downloadAll() {
            Object.keys(embeddedPapers).forEach((key, index) => {
                const paper = embeddedPapers[key];
                setTimeout(() => {
                    downloadMarkdown(paper.content, paper.filename);
                }, 500 * index);
            });
        }

        // Download markdown file
        function downloadMarkdown(content, filename) {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Back to top button
        function setupBackToTop() {
            const backToTop = document.getElementById('back-to-top');

            window.addEventListener('scroll', () => {
                if (window.pageYOffset > 300) {
                    backToTop.classList.add('visible');
                } else {
                    backToTop.classList.remove('visible');
                }
            });

            backToTop.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Check if marked is loaded
            if (typeof marked === 'undefined') {
                document.getElementById('content').innerHTML = '<p style="color: red;">Error: Markdown parser not loaded. Please refresh the page.</p>';
                return;
            }

            // Load initial paper
            const docKey = getUrlParameter('doc');
            loadPaper(docKey);

            // Setup event listeners
            document.querySelectorAll('.doc-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const href = btn.getAttribute('href');
                    const docKey = new URLSearchParams(href.split('?')[1]).get('doc');
                    loadPaper(docKey);
                    history.pushState(null, '', href);
                });
            });

            document.getElementById('download-current').addEventListener('click', downloadCurrent);
            document.getElementById('download-all').addEventListener('click', downloadAll);

            // Setup back to top
            setupBackToTop();

            // Handle browser back/forward
            window.addEventListener('popstate', () => {
                const docKey = getUrlParameter('doc');
                loadPaper(docKey);
            });
        });

        // Configure marked options
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: true,
                mangle: false
            });
        }
    </script>
</body>
</html>