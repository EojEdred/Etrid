"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[187],{62187:(e,t,n)=>{n.r(t),n.d(t,{isWeb3Injected:()=>y,packageInfo:()=>i,unwrapBytes:()=>p,web3Accounts:()=>F,web3AccountsSubscribe:()=>A,web3Enable:()=>x,web3EnablePromise:()=>E,web3FromAddress:()=>U,web3FromSource:()=>S,web3ListRpcProviders:()=>_,web3UseRpcProvider:()=>I,wrapBytes:()=>m});var r=n(98702);let o=(0,n(18353).D8)("catch","then");var a=n(37480),s=n(86430),c=n(30949);let i={name:"@polkadot/extension-dapp",path:new URL("file:///Users/macbook/Desktop/etrid/apps/wallet-web/etrid-crypto-website/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.substring(0,new URL("file:///Users/macbook/Desktop/etrid/apps/wallet-web/etrid-crypto-website/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.lastIndexOf("/")+1),type:"esm",version:"0.62.2"};var l=n(23442),u=n(88929);let d=(0,u.e)("\x19Ethereum Signed Message:\n"),b=(0,u.e)("<Bytes>"),h=(0,u.e)("</Bytes>"),w=b.length+h.length;function f(e,t){return e.length>=w&&(0,a.f)(e.subarray(0,b.length),b)&&(0,a.f)(e.slice(-h.length),h)||t&&e.length>=d.length&&(0,a.f)(e.subarray(0,d.length),d)}let p=function(e){let t=(0,u.e)(e);return f(t,!1)?t.subarray(b.length,t.length-h.length):t},m=function(e){let t=(0,u.e)(e);return f(t,!0)?t:(0,l.Q)([b,t,h])},g=window;g.injectedWeb3=g.injectedWeb3||{};let y=k(),E=null;function k(){return 0!==Object.values(g.injectedWeb3).filter(({connect:e,enable:t})=>!!(e||t)).length}function v(e){throw Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function j(e,t,n){return t.map(({address:t,genesisHash:r,name:o,type:a})=>({address:42===t.length?t:(0,s.j)((0,c.F)(t),n),meta:{genesisHash:r,name:o,source:e},type:a}))}function $(e,t,n){return e.filter(e=>(!e.type||!n||n.includes(e.type))&&(!e.genesisHash||!t||e.genesisHash===t))}async function P(e,t){return E?(await E).filter(({name:e})=>!t||t.includes(e)):v(e)}function x(e,t=[]){var n;if(!e)throw Error("You must pass a name for your app to the web3Enable function");let o=t.length?Promise.all(t.map(e=>e().catch(()=>!1))):Promise.resolve([!0]);return n=()=>o.then(()=>Promise.all(Object.entries(g.injectedWeb3).map(([t,{connect:n,enable:o,version:a}])=>Promise.resolve().then(()=>n?n(e):o?o(e).then(e=>(0,r.b)({name:t,version:a||"unknown"},e)):Promise.reject(Error("No connect(..) or enable(...) hook found"))).catch(({message:e})=>{console.error(`Error initializing ${t}: ${e}`)}))).then(e=>e.filter(e=>!!e)).then(e=>e.map(e=>(e.accounts.subscribe||(e.accounts.subscribe=t=>(e.accounts.get().then(t).catch(console.error),()=>{})),e))).catch(()=>[]).then(e=>{let t=e.map(({name:e,version:t})=>`${e}/${t}`);return y=k(),console.info(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${t.join(", ")}`),e})),E=new Promise(e=>{"complete"===document.readyState?e(n()):window.addEventListener("load",()=>e(n()))})}async function F({accountType:e,extensions:t,genesisHash:n,ss58Format:r}={}){let o=[],a=await P("web3Accounts",t);return(await Promise.all(a.map(async({accounts:t,name:o})=>{try{let a=await t.get();return j(o,$(a,n,e),r)}catch{return[]}}))).forEach(e=>{o.push(...e)}),console.info(`web3Accounts: Found ${o.length} address${1!==o.length?"es":""}`),o}async function A(e,{accountType:t,extensions:n,genesisHash:r,ss58Format:a}={}){let s=await P("web3AccountsSubscribe",n),c={},i=()=>e(Object.entries(c).reduce((e,[n,o])=>(e.push(...j(n,$(o,r,t),a)),e),[])),l=s.map(({accounts:{subscribe:e},name:t})=>e(e=>{c[t]=e;try{let e=i();e&&o(e)&&e.catch(console.error)}catch(e){console.error(e)}}));return()=>{l.forEach(e=>{e()})}}async function S(e){if(!E)return v("web3FromSource");let t=await E,n=e&&t.find(({name:t})=>t===e);if(!n)throw Error(`web3FromSource: Unable to find an injected ${e}`);return n}async function U(e){let t;if(!E)return v("web3FromAddress");let n=await F();if(e){let r=(0,c.F)(e);t=n.find(e=>(0,a.f)((0,c.F)(e.address),r))}if(!t)throw Error(`web3FromAddress: Unable to find injected ${e}`);return S(t.meta.source)}async function _(e){let{provider:t}=await S(e);return t?t.listProviders():(console.warn(`Extension ${e} does not expose any provider`),null)}async function I(e,t){let{provider:n}=await S(e);if(!n)throw Error(`Extension ${e} does not expose any provider`);return{meta:await n.startProvider(t),provider:n}}}}]);